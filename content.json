{"meta":{"title":"深入浅出区块链","subtitle":"系统学习区块链","description":"微信号:blockchaincore","author":"Tiny熊","url":"http://learnblockchain.cn"},"pages":[{"title":"","date":"2017-10-24T10:16:10.000Z","updated":"2017-11-01T09:59:49.000Z","comments":true,"path":"about/index.html","permalink":"http://learnblockchain.cn/about/index.html","excerpt":"","text":"关于我深入浅出区块链目标做最好的区块链技术分享博客，希望能为推动国内区块链技术尽绵薄之力。本博客完全开源、开放，鼓励分享，转载请注明出处。 博客地址 区块链涉及的技术太多，希望有兴趣的朋友能一起来参与进来写博客，把这个站打造成所有区块链开发人员的博客。 ####参与可以获得什么技术，技术，还是技术如果3年后，我们能成为区块链技术第一博客，那么你就是第一博客的创建者。 关于作者Tiny熊期待大家的大名"},{"title":"深入浅出区块链-文章分类","date":"2017-10-24T13:14:00.000Z","updated":"2017-10-24T13:15:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://learnblockchain.cn/categories/index.html","excerpt":"","text":""},{"title":"深入浅出区快链-文章标签","date":"2017-10-24T13:11:50.000Z","updated":"2017-10-24T13:15:39.000Z","comments":false,"path":"tags/index.html","permalink":"http://learnblockchain.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"用Python从零开始创建区块链","slug":"build_blockchain_by_python","date":"2017-10-27T02:15:28.000Z","updated":"2017-11-01T09:40:30.000Z","comments":true,"path":"2017/10/27/build_blockchain_by_python/","link":"","permalink":"http://learnblockchain.cn/2017/10/27/build_blockchain_by_python/","excerpt":"本文主要内容翻译自Learn Blockchains by Building One\b本文原始链接,转载请注明出处。作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。","text":"本文主要内容翻译自Learn Blockchains by Building One\b本文原始链接,转载请注明出处。作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。 对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。 但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。 准备工作本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。 我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。 如果你还不是很了解哈希，可以查看这篇文章 环境准备环境准备，确保已经安装Python3.6+, pip , Flask, requests安装方法：1pip install Flask==0.12.2 requests==2.18.4 同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。 参考源代码（原代码在我翻译的时候，无法运行，我fork了一份，修复了其中的错误，并添加了翻译，感谢star） 开始创建Blockchain新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码 Blockchain类首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。 以下是Blockchain类的框架：12345678910111213141516171819202122class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。 块结构每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。 以下是一个区块的结构：12345678910111213block = &#123; 'index': 1, 'timestamp': 1506057125.900785, 'transactions': [ &#123; 'sender': \"8527147fe1f5426f9dd545de4b27ee00\", 'recipient': \"a77f5cdfa2934df3954a5c7c7da5df1f\", 'amount': 5, &#125; ], 'proof': 324984774000, 'previous_hash': \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"&#125; 到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考区块链记账原理 加入交易接下来我们需要添加一个交易，来完善下new_transaction方法12345678910111213141516171819class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): \"\"\" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction \"\"\" self.current_transactions.append(&#123; 'sender': sender, 'recipient': recipient, 'amount': amount, &#125;) return self.last_block['index'] + 1 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。 创建新块当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。 为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import hashlibimport jsonfrom time import timeclass Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): \"\"\" 生成新块 :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block \"\"\" block = &#123; 'index': len(self.chain) + 1, 'timestamp': time(), 'transactions': self.current_transactions, 'proof': proof, 'previous_hash': previous_hash or self.hash(self.chain[-1]), &#125; # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): \"\"\" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction \"\"\" self.current_transactions.append(&#123; 'sender': sender, 'recipient': recipient, 'amount': amount, &#125;) return self.last_block['index'] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): \"\"\" 生成块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; \"\"\" # We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。 理解工作量证明新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。这就是工作量证明的核心思想。 为了方便理解，举个例子： 假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？ 用Python实现如下： 123456from hashlib import sha256x = 5y = 0 # y未知while sha256(f'&#123;x*y&#125;'.encode()).hexdigest()[-1] != \"0\": y += 1print(f'The solution is y = &#123;y&#125;') 结果是y=21. 因为：1hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。 实现工作量证明让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 12345678910111213141516171819202122232425262728293031323334353637import hashlibimport jsonfrom time import timefrom uuid import uuid4class Blockchain(object): ... def proof_of_work(self, last_proof): \"\"\" 简单的工作量证明: - 查找一个 p' 使得 hash(pp') 以4个0开头 - p 是上一个块的证明, p' 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; \"\"\" proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): \"\"\" 验证证明: 是否hash(last_proof, proof)以4个0开头? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. \"\"\" guess = f'&#123;last_proof&#125;&#123;proof&#125;'.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == \"0000\" 衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。 现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。 Blockchain作为API接口我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。 我们将创建三个接口： /transactions/new 创建一个交易并添加到区块 /mine 告诉服务器去挖掘新的区块 /chain 返回整个区块链 创建节点我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibimport jsonfrom textwrap import dedentfrom time import timefrom uuid import uuid4from flask import Flaskclass Blockchain(object): ...# Instantiate our Nodeapp = Flask(__name__)# Generate a globally unique address for this nodenode_identifier = str(uuid4()).replace('-', '')# Instantiate the Blockchainblockchain = Blockchain()@app.route('/mine', methods=['GET'])def mine(): return \"We'll mine a new Block\" @app.route('/transactions/new', methods=['POST'])def new_transaction(): return \"We'll add a new transaction\"@app.route('/chain', methods=['GET'])def full_chain(): response = &#123; 'chain': blockchain.chain, 'length': len(blockchain.chain), &#125; return jsonify(response), 200if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 简单的说明一下以上代码： 第15行: 创建一个节点. 第18行: 为节点创建一个随机的名字. 第21行: 实例Blockchain类. 第24–26行: 创建/mine GET接口。 第28–30行: 创建/transactions/new POST接口,可以给接口发送交易数据. 第32–38行: 创建 /chain 接口, 返回整个区块链。 第40–41行: 服务运行在端口5000上. 发送交易发送到节点的交易数据结构如下：12345&#123; \"sender\": \"my address\", \"recipient\": \"someone else's address\", \"amount\": 5&#125; 之前已经有添加交易的方法，基于接口来添加交易就很简单了 123456789101112131415161718192021222324import hashlibimport jsonfrom textwrap import dedentfrom time import timefrom uuid import uuid4from flask import Flask, jsonify, request...@app.route('/transactions/new', methods=['POST'])def new_transaction(): values = request.get_json() # Check that the required fields are in the POST'ed data required = ['sender', 'recipient', 'amount'] if not all(k in values for k in required): return 'Missing values', 400 # Create a new Transaction index = blockchain.new_transaction(values['sender'], values['recipient'], values['amount']) response = &#123;'message': f'Transaction will be added to Block &#123;index&#125;'&#125; return jsonify(response), 201 挖矿挖矿正是神奇所在，它很简单，做了一下三件事： 计算工作量证明PoW 通过新增一个交易授予矿工（自己）一个币 构造新区块并将其添加到链中 123456789101112131415161718192021222324252627282930313233343536import hashlibimport jsonfrom time import timefrom uuid import uuid4from flask import Flask, jsonify, request...@app.route('/mine', methods=['GET'])def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block['proof'] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励. # 发送者为 \"0\" 表明是新挖出的币 blockchain.new_transaction( sender=\"0\", recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain block = blockchain.new_block(proof) response = &#123; 'message': \"New Block Forged\", 'index': block['index'], 'transactions': block['transactions'], 'proof': block['proof'], 'previous_hash': block['previous_hash'], &#125; return jsonify(response), 200 注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下 运行区块链你可以使用cURL 或Postman 去和API进行交互 启动server:12$ python blockchain.py* Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit) 让我们通过请求 http://localhost:5000/mine 来进行挖矿 通过post请求，添加一个新交易 如果不是使用Postman，则用一下的cURL语句也是一样的：12345$ curl -X POST -H \"Content-Type: application/json\" -d '&#123; \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5&#125;' \"http://localhost:5000/transactions/new\" 在挖了两次矿之后，就有3个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息。 1234567891011121314151617181920212223242526272829303132333435363738&#123; \"chain\": [ &#123; \"index\": 1, \"previous_hash\": 1, \"proof\": 100, \"timestamp\": 1506280650.770839, \"transactions\": [] &#125;, &#123; \"index\": 2, \"previous_hash\": \"c099bc...bfb7\", \"proof\": 35293, \"timestamp\": 1506280664.717925, \"transactions\": [ &#123; \"amount\": 1, \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\", \"sender\": \"0\" &#125; ] &#125;, &#123; \"index\": 3, \"previous_hash\": \"eff91a...10f2\", \"proof\": 35089, \"timestamp\": 1506280666.1086972, \"transactions\": [ &#123; \"amount\": 1, \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\", \"sender\": \"0\" &#125; ] &#125; ], \"length\": 3&#125; 一致性（共识）我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。 注册节点在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口： /nodes/register 接收URL形式的新节点列表 /nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链 我们修改下Blockchain的init函数并提供一个注册节点方法：1234567891011121314151617181920...from urllib.parse import urlparse...class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): \"\"\" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000' :return: None \"\"\" parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。 实现共识算法前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。 我们使用一下的算法，来达到网络中的共识12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667...import requestsclass Blockchain(object) ... def valid_chain(self, chain): \"\"\" Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not \"\"\" last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f'&#123;last_block&#125;') print(f'&#123;block&#125;') print(\"\\n-----------\\n\") # Check that the hash of the block is correct if block['previous_hash'] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block['proof'], block['proof']): return False last_block = block current_index += 1 return True def resolve_conflicts(self): \"\"\" 共识算法解决冲突 使用网络中最长的链. :return: &lt;bool&gt; True 如果链被取代, 否则为False \"\"\" neighbours = self.nodes new_chain = None # We're only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f'http://&#123;node&#125;/chain') if response.status_code == 200: length = response.json()['length'] chain = response.json()['chain'] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False 第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof. 第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， 如果发现有效更长链，就替换掉自己的链 让我们添加两个路由，一个用来注册节点，一个用来解决冲突。12345678910111213141516171819202122232425262728293031323334@app.route('/nodes/register', methods=['POST'])def register_nodes(): values = request.get_json() nodes = values.get('nodes') if nodes is None: return \"Error: Please supply a valid list of nodes\", 400 for node in nodes: blockchain.register_node(node) response = &#123; 'message': 'New nodes have been added', 'total_nodes': list(blockchain.nodes), &#125; return jsonify(response), 201@app.route('/nodes/resolve', methods=['GET'])def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = &#123; 'message': 'Our chain was replaced', 'new_chain': blockchain.chain &#125; else: response = &#123; 'message': 'Our chain is authoritative', 'chain': blockchain.chain &#125; return jsonify(response), 200 你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：http://localhost:5000 和 http://localhost:5001 12pipenv run python blockchain.pypipenv run python blockchain.py -p 5001 然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。 好啦，你可以邀请朋友们一起来测试你的区块链","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://learnblockchain.cn/categories/BlockChain/"}],"tags":[{"name":"python","slug":"python","permalink":"http://learnblockchain.cn/tags/python/"},{"name":"创建区块链","slug":"创建区块链","permalink":"http://learnblockchain.cn/tags/创建区块链/"},{"name":"翻译","slug":"翻译","permalink":"http://learnblockchain.cn/tags/翻译/"}]},{"title":"区块链记账原理","slug":"whatbc","date":"2017-10-25T15:26:04.000Z","updated":"2017-11-01T09:41:01.000Z","comments":true,"path":"2017/10/25/whatbc/","link":"","permalink":"http://learnblockchain.cn/2017/10/25/whatbc/","excerpt":"区块链(1.0)是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。 通常认为与智能合约相结合的区块链为区块链2.0, 如以太坊是典型的区块链2.0 很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发少关心币价，多关心技术。 本文将讲解区块链1.0技术是如何实现的。","text":"区块链(1.0)是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。 通常认为与智能合约相结合的区块链为区块链2.0, 如以太坊是典型的区块链2.0 很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发少关心币价，多关心技术。 本文将讲解区块链1.0技术是如何实现的。 哈希函数在讲区块链技术之前，先说明一下哈希函数。哈希函数：Hash(原始信息) = 摘要信息原始信息可以是任意的信息,hash之后会得到一个简短的摘要信息 哈希函数有几个特点: 同样的原始信息用同一个哈希函数总能得到相同的摘要信息 原始信息任何微小的变化都会哈希出面目全非的摘要信息 从摘要信息无法逆向推算出原始信息 举例说明：Hash(张三借给李四100万，利息1%，1年后还本息 …..) = AC4635D34DEF账本上记录了AC4635D34DEF这样一条记录。 可以看出哈希函数有4个作用： 简化信息很好理解，哈希后的信息变短了。 标识信息可以使用AC4635D34DEF来标识原始信息，摘要信息也称为原始信息的id。 隐匿信息账本是AC4635D34DEF这样一条记录，原始信息被隐匿。 验证信息假如李四在还款时欺骗说，张三只借给李四10万，双方可以用AC4635D34DEF来验证原始信息 哈希函数的这4个作用在区块链技术里有广泛的运用。（哈希函数是一组函数或算法，以后会发文章专门介绍哈希） 区块链记账方法假设有一个账页序号为0的账页交易记录如下: 账号 入账 出账 余额 备注说明 王二 100 190 收到xxx货款 张三 100 30 xxxx 李四 120 90 170 xxxx 记账时间为：2017-10-22 10:22:02 区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行Hash, 得到一个Hash值，如：787635ACD, 用函数表示为：1Hash(序号0、记账时间、交易记录) = 787635ACD 账页信息和Hash值组合在一起就构成了第一个区块。 比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟在记第2个账页的时候，会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash,即： 1Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD 这样第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。这样形成的区块链在一起就构成了一个便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）的总账本。","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://learnblockchain.cn/categories/BlockChain/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://learnblockchain.cn/tags/区块链/"},{"name":"原理","slug":"原理","permalink":"http://learnblockchain.cn/tags/原理/"},{"name":"哈希","slug":"哈希","permalink":"http://learnblockchain.cn/tags/哈希/"},{"name":"如何记账","slug":"如何记账","permalink":"http://learnblockchain.cn/tags/如何记账/"}]},{"title":"比特币是什么","slug":"whatisbitcoin","date":"2017-10-23T14:36:05.000Z","updated":"2017-10-26T07:04:01.000Z","comments":true,"path":"2017/10/23/whatisbitcoin/","link":"","permalink":"http://learnblockchain.cn/2017/10/23/whatisbitcoin/","excerpt":"到底什么是比特币，它到底是怎么运行的","text":"到底什么是比特币，它到底是怎么运行的 比特币是什么 比特币是一种基于分布式网络的数字货币。 数字货币是什么凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币） 运行原理大家知道，在银行系统的数据库里记录着跟我们身份id对应的财产，下文称这样的记录为账本，如张三的卡10月1日转入1w, 余额10w。比特币系统也同样有这样的账本，不同银行由单一的组织负责记录,比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从1万改为1百万，他这个账本和大多数人的账本不一致，就会被比特的系统认为是无效的。 比特币使用区块链技术来维护系统运行，细节可参考区块链技术原理","categories":[{"name":"Bitcoin","slug":"Bitcoin","permalink":"http://learnblockchain.cn/categories/Bitcoin/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"http://learnblockchain.cn/tags/比特币/"},{"name":"定义","slug":"定义","permalink":"http://learnblockchain.cn/tags/定义/"}]},{"title":"前言-如何学习区块链","slug":"前言","date":"2017-10-20T07:03:36.000Z","updated":"2017-10-26T13:12:55.000Z","comments":true,"path":"2017/10/20/前言/","link":"","permalink":"http://learnblockchain.cn/2017/10/20/前言/","excerpt":"区块链未来3到5年应该会出现行业井喷式发展，相应所需的人才必定水涨船高，每一个开发人员都不应该错过这样的机会。区块链涉及的技术很多，很多开发人员看了一些资料后，感觉好像懂了，又好像没懂。如何系统的学习区块链技术，是很多想从事区块链开发的程序员的问题，我们来一起讨论下，希望可以帮助更多的人掌握区块链开发技术。","text":"区块链未来3到5年应该会出现行业井喷式发展，相应所需的人才必定水涨船高，每一个开发人员都不应该错过这样的机会。区块链涉及的技术很多，很多开发人员看了一些资料后，感觉好像懂了，又好像没懂。如何系统的学习区块链技术，是很多想从事区块链开发的程序员的问题，我们来一起讨论下，希望可以帮助更多的人掌握区块链开发技术。 确定方向从事区块链开发也有很多方向，如:区块链应用开发人员、区块链架构师、底层核心开发、共识算法研究等等。 方向不同，需要学习的内容就不一样，如果做基于区块链应用开发，只需要了解一门编程语言（nodejs, Go, Python, C++ 等）, 大概了解区块链的原理，不一定要深入，当能理解越深入开发应用就越顺。如果做区块链基础开发，就需要了解加密算法，P2P通信，共识算法等等。 投入时间学习-动手实践由于区块链涉及的技术很多，可以相对各个技术有一个概念了解，再逐步深入原理。 当你在学习了解概念的时候，必定会产生很多疑问， 例如我们经常可以看到一句： 比特币的共识机制是通过工作量证明（POW）来实现的。就有了新疑问:什么是工作量证明，进一步了解，它是通过验证的一个特定结果，就能确认参与者完成了相应的工作量（不理解没关系，可以简单为，张三考试考了100分，就确认张三肯定好好学习了）。这时又有了新的疑问，比特币在验证什么样的结果，这时你又需要了解密码学和Hash。 逐步深入的过程也是解答疑问的过程，需要我们善用Google搜索。 如果觉得已进理解一个概念或原理时，可以尝试动手实现它，如在理解挖矿后，可以写代码模拟挖矿过程。 学习是一个长期的过期，没有捷径，必须得多读书，读代码，写代码。 学习资源介绍下面是一些学习资源的介绍，相信对大家有帮助 比特币:一种点对点的电子现金系统-英文 比特币:一种点对点的电子现金系统-中文 以太坊白皮书-英文 以太坊白皮书-中文 区块链技术指南-电子书 区块链开发指南-纸书 比特币 - 官网 以太坊 - github 超级账本Hyperledger ETHFANS - 社区 深入浅出区块链","categories":[{"name":"Bitcoin","slug":"Bitcoin","permalink":"http://learnblockchain.cn/categories/Bitcoin/"}],"tags":[{"name":"如何学习","slug":"如何学习","permalink":"http://learnblockchain.cn/tags/如何学习/"}]}]}