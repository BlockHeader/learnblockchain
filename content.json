{"meta":{"title":"深入浅出区块链","subtitle":"系统学习区块链","description":"微信号:blockchaincore","author":"Tiny熊","url":"http://learnblockchain.cn"},"pages":[{"title":"","date":"2017-10-24T10:16:10.000Z","updated":"2017-11-03T05:31:44.000Z","comments":true,"path":"about/index.html","permalink":"http://learnblockchain.cn/about/index.html","excerpt":"","text":"关于我深入浅出区块链目标做最好的区块链技术分享博客，希望能为推动国内区块链技术尽绵薄之力。本博客完全开源、开放，鼓励分享，转载请注明出处。 博客地址 区块链涉及的技术太多，希望有兴趣的朋友能一起来参与进来写博客，把这个站打造成所有区块链开发人员的博客。 参与可以获得什么技术，技术，还是技术如果3年后，我们能成为区块链技术第一博客，那么你就是第一博客的创建者。 关于作者Tiny熊期待大家的大名"},{"title":"深入浅出区块链-文章分类","date":"2017-10-24T13:14:00.000Z","updated":"2017-11-03T05:31:44.000Z","comments":false,"path":"categories/index.html","permalink":"http://learnblockchain.cn/categories/index.html","excerpt":"","text":""},{"title":"深入浅出区快链-文章标签","date":"2017-10-24T13:11:50.000Z","updated":"2017-11-03T05:31:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://learnblockchain.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"比特币如何挖矿（挖矿原理）-工作量证明","slug":"bitcoin-pow","date":"2017-11-04T08:12:29.000Z","updated":"2017-11-05T15:28:04.000Z","comments":true,"path":"2017/11/04/bitcoin-pow/","link":"","permalink":"http://learnblockchain.cn/2017/11/04/bitcoin-pow/","excerpt":"在区块链记账原理 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”，本文将详细讨论这个过程。","text":"在区块链记账原理 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”，本文将详细讨论这个过程。 记账工作由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是12.5比特币，博文写作时每个比特币是4万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下： 一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功 通过解决密码学难题（即工作量证明）竞争获得唯一记账权 其他节点复制记账结果 不过在进行工作量证明之前，记账节点会做进行如下准备工作： 收集广播中还没有被记录账本的原始交易信息 检查每个交易信息中付款地址有没有足够的余额 验证交易是否有正确的签名 把验证通过的交易信息进行打包记录 添加一个奖励交易：给自己的地址增加12.5比特币 如果节点争夺记账权成功的话，就可以得到12.5比特币的奖励。 工作量证明区块链记账原理我们了解到，每次记账的时候回把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash。如果仅仅是这样，显然每个人都可以很轻松的完成记账。为了保证10分钟左右只有一个人可以记账，就必须要提高记账的难度，使得Hash的结果必须以若干个0开头。同是为了满足这个条件，在进行Hash时引入一个随机数变量。用伪代码表示一下：12# 没有难度时为：Hash(上一个Hash值，交易记录集) = 456635BCDHash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD 我们知道改变Hash的原始信息的任何一部分，Hash值也会随之不断的变化，因此在运算Hash时，不断的改变随机数的值，总可以找的一个随机数使的Hash的结果以若干个0开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。 计算量分析（这部分可选阅读）我们简单分析下记账难度有多大，Hash值是由数字和大小写字母构成的字符串，每一位有62种可能性（可能为26个大写字母、26个小写字母，10个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为0的概率是1/62（其他位出现什么字符先不管），理论上需要尝试62次Hash运算才会出现一次第一位为0的情况，如果前两2位为0，就得尝试62的平方次Hash运算，以n个0开头就需要尝试62的n次方次运算。我们结合当前实际区块#493050信息来看看： 注：数据来源于https://blockchain.info我们可以看到Hash值以18个0开头，理论上需要尝试62的18次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力来分收益）。 从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。 题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上 验证在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。 如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。 假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。 说明矿工的收益其实不仅仅包含12.5比特币奖励，同时还有交易费收益，忽略一些些细节只有让主干更清晰。有兴趣的同学可以看看图中区块都包含了那些信息，红箭头标示出的是本文涉及的信息。 本文中有提到共识协议，比特币共识协议主要是由工作量证明和最长链机制 两部分组成，之后会有博文详细讲解。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客","categories":[{"name":"Bitcoin","slug":"Bitcoin","permalink":"http://learnblockchain.cn/categories/Bitcoin/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"http://learnblockchain.cn/tags/比特币/"},{"name":"挖矿","slug":"挖矿","permalink":"http://learnblockchain.cn/tags/挖矿/"},{"name":"工作量证明","slug":"工作量证明","permalink":"http://learnblockchain.cn/tags/工作量证明/"},{"name":"共识机制","slug":"共识机制","permalink":"http://learnblockchain.cn/tags/共识机制/"}]},{"title":"比特币所有权及隐私问题-非对称加密应用","slug":"bitcoin-own","date":"2017-11-02T09:19:29.000Z","updated":"2017-11-04T08:24:13.000Z","comments":true,"path":"2017/11/02/bitcoin-own/","link":"","permalink":"http://learnblockchain.cn/2017/11/02/bitcoin-own/","excerpt":"比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？ 如果你对这个问题还不是很明白，那就一起来看看吧。","text":"比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？ 如果你对这个问题还不是很明白，那就一起来看看吧。 银行系统我们先来回顾下现实的银行系统： 首先我们需要把我们的个人信息（如身份证）给银行，银行给我们开立相对应的账户，银行在开户的时候确立了对账户的所有权。 进行支付的时候，银行对交易双方完成转账（银行在开户的时候已经知道我们对应的账户）。 同时银行会对账户信息进行保密（这点其实不能保证）。 匿名账本那么比特币如何在没有第三方银行的参与下，在确保隐私的同时如何确定账户所有权的呢？ 实际上比特币的账户是用地址来表示，账本上不显示个人信息，转账是把比特币从一个地址转移到另一个地址。转账记录如这样：12345&#123; \"付款地址\"：\"2A39CBa2390FDe\" \"收款地址\"：\"AAC9CBa239aFcc\" \"金额\"：\"0.2btc\"&#125; 接下来问题就变为了 谁有权用某个地址进行付款。 支付和所有权 实际是同一个问题，如果此比特币只有我可以用来支付，那么说明我拥有所有权 地址与私钥比特币的解决方案是，谁拥有某个地址的私钥(如果完全没有加密概念的人，可以简单的把私钥当作密码)，谁就能用这个地址进行支付。（所以私钥一定保管好，如果私钥泄漏，比特币就可能丢失） 比特币地址和私钥是一个非对称的关系,私钥经过一序列运算（其中有两次Hash）之后，可以得到地址, 但是无法从地址反推得到私钥。1234地址： 2A39CBa2390FDe私钥： sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgalHash(Hash(fun(sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal))) -&gt; 2A39CBa2390FDe 银行系统银行账号和密码是完全独立的，无法互相推导，转出时需要同时验证账号和密码 还是上面交易的例子：12345&#123; \"付款地址\"：\"2A39CBa2390FDe\", \"收款地址\"：\"AAC9CBa239aFcc\", \"金额\"：\"0.2btc\"&#125; 只有拥有地址2A39CBa2390FDe的私钥才能进行支付。 非对称加密技术这个时候问题就变为了，如何证明你拥有某个地址的私钥（在不泄漏私钥的情况下）。 对交易信息进行签名实际在签名之前，会先对交易信息进行Hash运算的到摘要信息，然后对摘要信息进行签名。过程大概是这样：1.对交易进行hash， 得到一个摘要信息（Hash值） 12345hash(&apos; &#123;&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;, &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;, &quot;金额&quot;：&quot;0.2btc&quot; &#125;&apos;) -&gt; 8aDB23CDEA6 2.用私钥对交易摘要进行签名（付款方在安全的环境下进行，以避免私钥泄密）, 用代码表示大概是这样。1234#参数1为交易摘要#参数2为私钥#返回签名信息sign(\"8aDB23CDEA6\", \"J78sknJhidhLIqdngalket\") -&gt; \"3cdferdadgadg\" 广播在签名运算之后，付款节点就开始在全网进行广播：我支付了0.2btc到AAC9CBa239aFcc,签名信息是3cdferdadgadg，你们来确认一下吧。 广播过程实际上是发信息到相连的其它节点，其它节点在验证通过后再转发到与之相连的节点，这样的扩散过程。 广播的信息包含了交易原始信息和签名信息 验证其它节点在收到广播信息之后，会验证签名信息是不是付款方用私钥对交易原始信息签名产生的，如果验证通过说明确实是付款方本人发出的交易，说明交易有效，才会记录到账本中去。（实际还会验证付款账号有没有足够的余额，我们暂时忽略这点）验证过程实际是签名过程的逆运算，用代码表示大概过程是这样的： 1234#参数1为签名信息#参数2为付款方地址#返回交易摘要verify(\"3cdferdadgadg\", \"2A39CBa2390FDe\") -&gt; \"8aDB23CDEA6\" 如果验证输出的信息和原始交易信息的hash一致，则验证通过，记录账本，用代码表示大概是这样： 12345678if(verify(\"3cdferdadgadg\", \"2A39CBa2390FDe\") == hash('&#123;\"付款地址\"：\"2A39CBa2390FDe\", \"收款地址\"：\"AAC9CBa239aFcc\", \"金额\"：\"0.2btc\"&#125;')) : # \b\b写入账本 # 广播else: # donothing 大家可以理解为付款地址为公钥，签名过程即为用私钥对交易摘要的加密过程，验证过程为用公钥解密的过程(为方便大家理解，严格来讲是不准确的)。 补充说明上面为了更好的理解，我对一些信息进行了简化。 比特币系统使用了椭圆曲线签名算法，算法的私钥由32个字节随机数组成，通过私钥可以计算出公钥，公钥经过一序列哈希算法和编码算法得到比特币地址，地址也可以理解为公钥的摘要。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://learnblockchain.cn/categories/BlockChain/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://learnblockchain.cn/tags/区块链/"},{"name":"所有权问题","slug":"所有权问题","permalink":"http://learnblockchain.cn/tags/所有权问题/"},{"name":"隐私问题","slug":"隐私问题","permalink":"http://learnblockchain.cn/tags/隐私问题/"},{"name":"非对称加密","slug":"非对称加密","permalink":"http://learnblockchain.cn/tags/非对称加密/"}]},{"title":"用Python从零开始创建区块链","slug":"build_blockchain_by_python","date":"2017-10-27T02:15:28.000Z","updated":"2017-11-03T05:31:44.000Z","comments":true,"path":"2017/10/27/build_blockchain_by_python/","link":"","permalink":"http://learnblockchain.cn/2017/10/27/build_blockchain_by_python/","excerpt":"本文主要内容翻译自Learn Blockchains by Building One\b本文原始链接,转载请注明出处。作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。","text":"本文主要内容翻译自Learn Blockchains by Building One\b本文原始链接,转载请注明出处。作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。 对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。 但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。 准备工作本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。 我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。 如果你还不是很了解哈希，可以查看这篇文章 环境准备环境准备，确保已经安装Python3.6+, pip , Flask, requests安装方法：1pip install Flask==0.12.2 requests==2.18.4 同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。 参考源代码（原代码在我翻译的时候，无法运行，我fork了一份，修复了其中的错误，并添加了翻译，感谢star） 开始创建Blockchain新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码 Blockchain类首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。 以下是Blockchain类的框架：12345678910111213141516171819202122class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。 块结构每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。 以下是一个区块的结构：12345678910111213block = &#123; 'index': 1, 'timestamp': 1506057125.900785, 'transactions': [ &#123; 'sender': \"8527147fe1f5426f9dd545de4b27ee00\", 'recipient': \"a77f5cdfa2934df3954a5c7c7da5df1f\", 'amount': 5, &#125; ], 'proof': 324984774000, 'previous_hash': \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"&#125; 到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考区块链记账原理 加入交易接下来我们需要添加一个交易，来完善下new_transaction方法12345678910111213141516171819class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): \"\"\" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction \"\"\" self.current_transactions.append(&#123; 'sender': sender, 'recipient': recipient, 'amount': amount, &#125;) return self.last_block['index'] + 1 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。 创建新块当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。 为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import hashlibimport jsonfrom time import timeclass Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): \"\"\" 生成新块 :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block \"\"\" block = &#123; 'index': len(self.chain) + 1, 'timestamp': time(), 'transactions': self.current_transactions, 'proof': proof, 'previous_hash': previous_hash or self.hash(self.chain[-1]), &#125; # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): \"\"\" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction \"\"\" self.current_transactions.append(&#123; 'sender': sender, 'recipient': recipient, 'amount': amount, &#125;) return self.last_block['index'] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): \"\"\" 生成块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; \"\"\" # We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。 理解工作量证明新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。这就是工作量证明的核心思想。 为了方便理解，举个例子： 假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？ 用Python实现如下： 123456from hashlib import sha256x = 5y = 0 # y未知while sha256(f'&#123;x*y&#125;'.encode()).hexdigest()[-1] != \"0\": y += 1print(f'The solution is y = &#123;y&#125;') 结果是y=21. 因为：1hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。 实现工作量证明让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 12345678910111213141516171819202122232425262728293031323334353637import hashlibimport jsonfrom time import timefrom uuid import uuid4class Blockchain(object): ... def proof_of_work(self, last_proof): \"\"\" 简单的工作量证明: - 查找一个 p' 使得 hash(pp') 以4个0开头 - p 是上一个块的证明, p' 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; \"\"\" proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): \"\"\" 验证证明: 是否hash(last_proof, proof)以4个0开头? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. \"\"\" guess = f'&#123;last_proof&#125;&#123;proof&#125;'.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == \"0000\" 衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。 现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。 Blockchain作为API接口我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。 我们将创建三个接口： /transactions/new 创建一个交易并添加到区块 /mine 告诉服务器去挖掘新的区块 /chain 返回整个区块链 创建节点我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibimport jsonfrom textwrap import dedentfrom time import timefrom uuid import uuid4from flask import Flaskclass Blockchain(object): ...# Instantiate our Nodeapp = Flask(__name__)# Generate a globally unique address for this nodenode_identifier = str(uuid4()).replace('-', '')# Instantiate the Blockchainblockchain = Blockchain()@app.route('/mine', methods=['GET'])def mine(): return \"We'll mine a new Block\" @app.route('/transactions/new', methods=['POST'])def new_transaction(): return \"We'll add a new transaction\"@app.route('/chain', methods=['GET'])def full_chain(): response = &#123; 'chain': blockchain.chain, 'length': len(blockchain.chain), &#125; return jsonify(response), 200if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 简单的说明一下以上代码： 第15行: 创建一个节点. 第18行: 为节点创建一个随机的名字. 第21行: 实例Blockchain类. 第24–26行: 创建/mine GET接口。 第28–30行: 创建/transactions/new POST接口,可以给接口发送交易数据. 第32–38行: 创建 /chain 接口, 返回整个区块链。 第40–41行: 服务运行在端口5000上. 发送交易发送到节点的交易数据结构如下：12345&#123; \"sender\": \"my address\", \"recipient\": \"someone else's address\", \"amount\": 5&#125; 之前已经有添加交易的方法，基于接口来添加交易就很简单了 123456789101112131415161718192021222324import hashlibimport jsonfrom textwrap import dedentfrom time import timefrom uuid import uuid4from flask import Flask, jsonify, request...@app.route('/transactions/new', methods=['POST'])def new_transaction(): values = request.get_json() # Check that the required fields are in the POST'ed data required = ['sender', 'recipient', 'amount'] if not all(k in values for k in required): return 'Missing values', 400 # Create a new Transaction index = blockchain.new_transaction(values['sender'], values['recipient'], values['amount']) response = &#123;'message': f'Transaction will be added to Block &#123;index&#125;'&#125; return jsonify(response), 201 挖矿挖矿正是神奇所在，它很简单，做了一下三件事： 计算工作量证明PoW 通过新增一个交易授予矿工（自己）一个币 构造新区块并将其添加到链中 123456789101112131415161718192021222324252627282930313233343536import hashlibimport jsonfrom time import timefrom uuid import uuid4from flask import Flask, jsonify, request...@app.route('/mine', methods=['GET'])def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block['proof'] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励. # 发送者为 \"0\" 表明是新挖出的币 blockchain.new_transaction( sender=\"0\", recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain block = blockchain.new_block(proof) response = &#123; 'message': \"New Block Forged\", 'index': block['index'], 'transactions': block['transactions'], 'proof': block['proof'], 'previous_hash': block['previous_hash'], &#125; return jsonify(response), 200 注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下 运行区块链你可以使用cURL 或Postman 去和API进行交互 启动server:12$ python blockchain.py* Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit) 让我们通过请求 http://localhost:5000/mine 来进行挖矿 通过post请求，添加一个新交易 如果不是使用Postman，则用一下的cURL语句也是一样的：12345$ curl -X POST -H \"Content-Type: application/json\" -d '&#123; \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5&#125;' \"http://localhost:5000/transactions/new\" 在挖了两次矿之后，就有3个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息。 1234567891011121314151617181920212223242526272829303132333435363738&#123; \"chain\": [ &#123; \"index\": 1, \"previous_hash\": 1, \"proof\": 100, \"timestamp\": 1506280650.770839, \"transactions\": [] &#125;, &#123; \"index\": 2, \"previous_hash\": \"c099bc...bfb7\", \"proof\": 35293, \"timestamp\": 1506280664.717925, \"transactions\": [ &#123; \"amount\": 1, \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\", \"sender\": \"0\" &#125; ] &#125;, &#123; \"index\": 3, \"previous_hash\": \"eff91a...10f2\", \"proof\": 35089, \"timestamp\": 1506280666.1086972, \"transactions\": [ &#123; \"amount\": 1, \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\", \"sender\": \"0\" &#125; ] &#125; ], \"length\": 3&#125; 一致性（共识）我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。 注册节点在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口： /nodes/register 接收URL形式的新节点列表 /nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链 我们修改下Blockchain的init函数并提供一个注册节点方法：1234567891011121314151617181920...from urllib.parse import urlparse...class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): \"\"\" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000' :return: None \"\"\" parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。 实现共识算法前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。 我们使用一下的算法，来达到网络中的共识12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667...import requestsclass Blockchain(object) ... def valid_chain(self, chain): \"\"\" Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not \"\"\" last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f'&#123;last_block&#125;') print(f'&#123;block&#125;') print(\"\\n-----------\\n\") # Check that the hash of the block is correct if block['previous_hash'] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block['proof'], block['proof']): return False last_block = block current_index += 1 return True def resolve_conflicts(self): \"\"\" 共识算法解决冲突 使用网络中最长的链. :return: &lt;bool&gt; True 如果链被取代, 否则为False \"\"\" neighbours = self.nodes new_chain = None # We're only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f'http://&#123;node&#125;/chain') if response.status_code == 200: length = response.json()['length'] chain = response.json()['chain'] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False 第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof. 第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， 如果发现有效更长链，就替换掉自己的链 让我们添加两个路由，一个用来注册节点，一个用来解决冲突。12345678910111213141516171819202122232425262728293031323334@app.route('/nodes/register', methods=['POST'])def register_nodes(): values = request.get_json() nodes = values.get('nodes') if nodes is None: return \"Error: Please supply a valid list of nodes\", 400 for node in nodes: blockchain.register_node(node) response = &#123; 'message': 'New nodes have been added', 'total_nodes': list(blockchain.nodes), &#125; return jsonify(response), 201@app.route('/nodes/resolve', methods=['GET'])def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = &#123; 'message': 'Our chain was replaced', 'new_chain': blockchain.chain &#125; else: response = &#123; 'message': 'Our chain is authoritative', 'chain': blockchain.chain &#125; return jsonify(response), 200 你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：http://localhost:5000 和 http://localhost:5001 12pipenv run python blockchain.pypipenv run python blockchain.py -p 5001 然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。 好啦，你可以邀请朋友们一起来测试你的区块链","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://learnblockchain.cn/categories/BlockChain/"}],"tags":[{"name":"python","slug":"python","permalink":"http://learnblockchain.cn/tags/python/"},{"name":"创建区块链","slug":"创建区块链","permalink":"http://learnblockchain.cn/tags/创建区块链/"},{"name":"翻译","slug":"翻译","permalink":"http://learnblockchain.cn/tags/翻译/"}]},{"title":"区块链记账原理","slug":"whatbc","date":"2017-10-25T15:26:04.000Z","updated":"2017-11-04T08:28:53.000Z","comments":true,"path":"2017/10/25/whatbc/","link":"","permalink":"http://learnblockchain.cn/2017/10/25/whatbc/","excerpt":"区块链(1.0)是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。 通常认为与智能合约相结合的区块链为区块链2.0, 如以太坊是典型的区块链2.0 很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。 本文将讲解区块链1.0技术是如何实现的。","text":"区块链(1.0)是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。 通常认为与智能合约相结合的区块链为区块链2.0, 如以太坊是典型的区块链2.0 很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。 本文将讲解区块链1.0技术是如何实现的。 哈希函数在讲区块链记账之前，先说明一下哈希函数。哈希函数：Hash(原始信息) = 摘要信息原始信息可以是任意的信息, hash之后会得到一个简短的摘要信息 哈希函数有几个特点: 同样的原始信息用同一个哈希函数总能得到相同的摘要信息 原始信息任何微小的变化都会哈希出面目全非的摘要信息 从摘要信息无法逆向推算出原始信息 举例说明：Hash(张三借给李四100万，利息1%，1年后还本息 …..) = AC4635D34DEF账本上记录了AC4635D34DEF这样一条记录。 可以看出哈希函数有4个作用： 简化信息很好理解，哈希后的信息变短了。 标识信息可以使用AC4635D34DEF来标识原始信息，摘要信息也称为原始信息的id。 隐匿信息账本是AC4635D34DEF这样一条记录，原始信息被隐匿。 验证信息假如李四在还款时欺骗说，张三只借给李四10万，双方可以用AC4635D34DEF来验证原始信息 哈希函数的这4个作用在区块链技术里有广泛的运用。（哈希函数是一组函数或算法，以后会发文章专门介绍哈希） 区块链记账方法假设有一个账页序号为0的账页交易记录如下: 账号 入账 出账 余额 备注说明 王二 100 190 收到xxx货款 张三 100 30 xxxx 李四 120 90 170 xxxx 记账时间为：2017-10-22 10:22:02 区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行Hash, 得到一个Hash值，如：787635ACD, 用函数表示为：1Hash(序号0、记账时间、交易记录) = 787635ACD 账页信息和Hash值组合在一起就构成了第一个区块。 比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟 在记第2个账页的时候，会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash,即： 1Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD 这样第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。 所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）的总账本。 记账有成本，想了解节点为什么要记账，请看这篇：在比特币如何挖矿-工作量证明 深入浅出区块链系统学习区块链，打造最好的区块链技术博客","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://learnblockchain.cn/categories/BlockChain/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://learnblockchain.cn/tags/区块链/"},{"name":"原理","slug":"原理","permalink":"http://learnblockchain.cn/tags/原理/"},{"name":"哈希","slug":"哈希","permalink":"http://learnblockchain.cn/tags/哈希/"},{"name":"如何记账","slug":"如何记账","permalink":"http://learnblockchain.cn/tags/如何记账/"}]},{"title":"比特币是什么","slug":"whatisbitcoin","date":"2017-10-23T14:36:05.000Z","updated":"2017-11-05T14:59:14.000Z","comments":true,"path":"2017/10/23/whatisbitcoin/","link":"","permalink":"http://learnblockchain.cn/2017/10/23/whatisbitcoin/","excerpt":"对于比特币也许一千个人有一千种理解。本文作为入门篇（写给完全没有了解过比特币概念的新手，老手可忽略），我尽量用简单易懂的语言来介绍比特币。 到底什么是比特币，它到底是怎么运行的呢。","text":"对于比特币也许一千个人有一千种理解。本文作为入门篇（写给完全没有了解过比特币概念的新手，老手可忽略），我尽量用简单易懂的语言来介绍比特币。 到底什么是比特币，它到底是怎么运行的呢。 比特币是什么 比特币是一种基于分布式网络的数字货币。比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。 本文主要讲解狭义的比特币概念。 数字货币是什么凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币） 运行原理大家知道，在银行系统的数据库里记录着跟我们身份id对应的财产，下文称这样的记录为账本，如张三的卡10月1日转入1w, 余额10w。比特币系统也同样有这样的账本，不同银行由单一的组织负责记录,比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从1万改为1百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。 比特币使用区块链技术来支撑整个系统的运行，这几篇博文有详细的阐述：区块链记账原理 、 比特币所有权问题、比特币如何挖矿 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客","categories":[{"name":"Bitcoin","slug":"Bitcoin","permalink":"http://learnblockchain.cn/categories/Bitcoin/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"http://learnblockchain.cn/tags/比特币/"},{"name":"定义","slug":"定义","permalink":"http://learnblockchain.cn/tags/定义/"}]},{"title":"前言-如何学习区块链","slug":"前言","date":"2017-10-20T07:03:36.000Z","updated":"2017-11-03T05:31:44.000Z","comments":true,"path":"2017/10/20/前言/","link":"","permalink":"http://learnblockchain.cn/2017/10/20/前言/","excerpt":"区块链未来3到5年应该会出现行业井喷式发展，相应所需的人才必定水涨船高，每一个开发人员都不应该错过这样的机会。区块链涉及的技术很多，很多开发人员看了一些资料后，感觉好像懂了，又好像没懂。如何系统的学习区块链技术，是很多想从事区块链开发的程序员的问题，我们来一起讨论下，希望可以帮助更多的人掌握区块链开发技术。","text":"区块链未来3到5年应该会出现行业井喷式发展，相应所需的人才必定水涨船高，每一个开发人员都不应该错过这样的机会。区块链涉及的技术很多，很多开发人员看了一些资料后，感觉好像懂了，又好像没懂。如何系统的学习区块链技术，是很多想从事区块链开发的程序员的问题，我们来一起讨论下，希望可以帮助更多的人掌握区块链开发技术。 确定方向从事区块链开发也有很多方向，如:区块链应用开发人员、区块链架构师、底层核心开发、共识算法研究等等。 方向不同，需要学习的内容就不一样，如果做基于区块链应用开发，只需要了解一门编程语言（nodejs, Go, Python, C++ 等）, 大概了解区块链的原理，不一定要深入，当能理解越深入开发应用就越顺。如果做区块链基础开发，就需要了解加密算法，P2P通信，共识算法等等。 投入时间学习-动手实践由于区块链涉及的技术很多，可以相对各个技术有一个概念了解，再逐步深入原理。 当你在学习了解概念的时候，必定会产生很多疑问， 例如我们经常可以看到一句： 比特币的共识机制是通过工作量证明（POW）来实现的。就有了新疑问:什么是工作量证明，进一步了解，它是通过验证的一个特定结果，就能确认参与者完成了相应的工作量（不理解没关系，可以简单为，张三考试考了100分，就确认张三肯定好好学习了）。这时又有了新的疑问，比特币在验证什么样的结果，这时你又需要了解密码学和Hash。 逐步深入的过程也是解答疑问的过程，需要我们善用Google搜索。 如果觉得已进理解一个概念或原理时，可以尝试动手实现它，如在理解挖矿后，可以写代码模拟挖矿过程。 学习是一个长期的过期，没有捷径，必须得多读书，读代码，写代码。 学习资源介绍下面是一些学习资源的介绍，相信对大家有帮助 比特币:一种点对点的电子现金系统-英文 比特币:一种点对点的电子现金系统-中文 以太坊白皮书-英文 以太坊白皮书-中文 区块链技术指南-电子书 区块链开发指南-纸书 比特币 - 官网 以太坊 - github 超级账本Hyperledger ETHFANS - 社区 深入浅出区块链","categories":[{"name":"Bitcoin","slug":"Bitcoin","permalink":"http://learnblockchain.cn/categories/Bitcoin/"}],"tags":[{"name":"如何学习","slug":"如何学习","permalink":"http://learnblockchain.cn/tags/如何学习/"}]}]}