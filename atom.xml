<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深入浅出区块链</title>
  
  <subtitle>系统学习区块链技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://learnblockchain.cn/"/>
  <updated>2019-04-07T12:26:31.072Z</updated>
  <id>https://learnblockchain.cn/</id>
  
  <author>
    <name>Tiny熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>以太坊DAO攻击解决方案代码解析</title>
    <link href="https://learnblockchain.cn/2019/04/07/dao/"/>
    <id>https://learnblockchain.cn/2019/04/07/dao/</id>
    <published>2019-04-07T11:41:25.000Z</published>
    <updated>2019-04-07T12:26:31.072Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 The DAO 攻击发生在2016年，但解除攻击的方案依然值得学习。</p><a id="more"></a><p>区块链本是去中心化架构，在以太坊首次遭遇严重黑客攻击智能合约事件时，采用的解决方案却破坏了去中心化理念。</p><p>这里不讨论其是否违背区块链精神，本文重点介绍解决方案的技术实施细节。<br>方案中涉及网络隔离技术和矿工共识投票技术。且只是从软件上处理，未破坏共识协议。解决方案的成功实施，为区块链分叉提供了实操经验，值得公链开发者学习。</p><h2 id="什么是-The-DAO-攻击"><a href="#什么是-The-DAO-攻击" class="headerlink" title="什么是 The DAO 攻击"></a>什么是 The DAO 攻击</h2><p>简单地讲，在2016年4月30日开始，一个名为“The DAO”的初创团队，在以太坊上通过智能合约进行ICO众筹。<br>28天时间，筹得1.5亿美元，成为历史上最大的众筹项目。</p><p>THE DAO创始人之一Stephan TualTual在6月12日宣布，他们发现了软件中存在的“递归调用漏洞”问题。 不幸的是，在程序员修复这一漏洞及其他问题的期间，一个不知名的黑客开始利用这一途径收集THE DAO代币销售中所得的以太币。6月18日，黑客成功挖到超过360万个以太币，并投入到一个DAO子组织中，这个组织和THE DAO有着同样的结构。</p><p>THE DAO持有近15%的以太币总数，因此THE DAO这次的问题对以太坊网络及其加密币都产生了负面影响。 </p><p>6月17日，以太坊基金会的Vitalik Buterin更新一项重要报告，他表示，DAO正在遭到攻击，不过他已经研究出了解决方案：</p><p>现在提出了软件分叉解决方案，通过这种软件分叉，任何调用代码或委托调用的交易——借助代码hash0x7278d050619a624f84f51987149ddb439cdaadfba5966f7cfaea7ad44340a4ba（也就是DAO和子DAO）来减少账户余额——都会视为无效…… </p><p>最终因为社交的不同意见，最终以太坊分裂出支持继续维持原状的以太经典 ETC，同意软件分叉解决方案的在以太坊当前网络实施。</p><blockquote><p>以上内容整理自文章<a href="http://chainb.com/?P=Cont&amp;id=1290" target="_blank" rel="noopener">The DAO 攻击</a>。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>因为投资者已经将以太币投入了 The DAO 合约或者其子合约中，在攻击后无法立刻撤回。<br>需要让投资者快速撤回投资，且能封锁黑客转移资产。</p><p>V神公布的解决方案是，在程序中植入转移合约以太币代码，让矿工选择是否支持分叉。<br>在分叉点到达时则将 The DAO 和其子合约中的以太币转移到一个新的安全的可取款合约中。<br>全部转移后，原投资者则可以直接从取款合约中快速的拿回以太币。</p><p>取款合约在讨论方案时，已经部署到主网。合约地址是 <a href="https://etherscan.io/address/0xbf4ed7b27f1d666546e30d74d50d173d20bca754" target="_blank" rel="noopener">0xbf4ed7b27f1d666546e30d74d50d173d20bca754</a>。</p><p>取款合约代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Deployed on mainnet at 0xbf4ed7b27f1d666546e30d74d50d173d20bca754</span><br><span class="line"></span><br><span class="line">contract DAO &#123;</span><br><span class="line">    function balanceOf(address addr) returns (uint);</span><br><span class="line">    function transferFrom(address from, address to, uint balance) returns (bool);</span><br><span class="line">    uint public totalSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract WithdrawDAO &#123;</span><br><span class="line">    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);</span><br><span class="line">    address public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;</span><br><span class="line"></span><br><span class="line">    function withdraw()&#123;</span><br><span class="line">        uint balance = mainDAO.balanceOf(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))</span><br><span class="line">            throw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function trusteeWithdraw() &#123;</span><br><span class="line">        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，为照顾两个阵营，软件提供硬分叉开关，选择权则交给社区。<br>支持分叉的矿工会在X区块到X+9区块出块时，在区块<code>extradata</code>字段中写入<code>0x64616f2d686172642d666f726b</code>（“dao-hard-fork”的十六进制数）。</p><p>从分叉点开始，如果连续10个区块均有硬分叉投票，则表示硬分叉成功。</p><h2 id="矿工投票与区块头校验"><a href="#矿工投票与区块头校验" class="headerlink" title="矿工投票与区块头校验"></a>矿工投票与区块头校验</h2><p>首先，选择权交给社区。<br>因此是否同意硬分叉，可通过参数进行选择。<br>但是在当前版本中，社区已完成硬分叉，所以已移除开关类代码。</p><p>当前，主网已默认配置支持DAO分叉，并设定了开始硬分叉高度 1920000，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// params/config.go:38</span></span><br><span class="line">MainnetChainConfig = &amp;ChainConfig&#123; </span><br><span class="line">DAOForkBlock:        big.NewInt(<span class="number">1920000</span>),</span><br><span class="line">DAOForkSupport:      <span class="literal">true</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果矿工支持分叉，则需要在从高度 192000 到 192009，<br>在区块头 <code>extradata</code> 写入指定信息 0x64616f2d686172642d666f726b ，以表示支持硬分叉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//params/dao.go:28</span></span><br><span class="line"><span class="keyword">var</span> DAOForkBlockExtra = common.FromHex(<span class="string">"0x64616f2d686172642d666f726b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// params/dao.go:32</span></span><br><span class="line"><span class="keyword">var</span> DAOForkExtraRange = big.NewInt(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>支持硬分叉时矿工写入固定的投票信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miner/worker.go:857</span></span><br><span class="line"><span class="keyword">if</span> daoBlock := w.config.DAOForkBlock; daoBlock != <span class="literal">nil</span> &#123; </span><br><span class="line">    <span class="comment">// 检查是否区块是否仍然属于分叉处理期间：[DAOForkBlock,DAOForkBlock+10)</span></span><br><span class="line">    limit := <span class="built_in">new</span>(big.Int).Add(daoBlock, params.DAOForkExtraRange)</span><br><span class="line">    <span class="keyword">if</span> header.Number.Cmp(daoBlock) &gt;= <span class="number">0</span> &amp;&amp; header.Number.Cmp(limit) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果支持分叉，则覆盖Extra，写入保留的投票信息</span></span><br><span class="line">        <span class="keyword">if</span> w.config.DAOForkSupport &#123;</span><br><span class="line">        header.Extra = common.CopyBytes(params.DAOForkBlockExtra)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;</span><br><span class="line">            <span class="comment">// 如果矿工反对，则不能让其使用保留信息，覆盖它。</span></span><br><span class="line">        header.Extra = []<span class="keyword">byte</span>&#123;&#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要连续10个区块的原因是为了防止矿工使用保留信息污染非分叉块和方便轻节点安全同步数据。<br>同时，所有节点在校验区块头时，必须安全地校验特殊字段信息，校验区块是否属于正确的分叉上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/ethash/consensus.go:294 </span></span><br><span class="line"><span class="keyword">if</span> err := misc.VerifyDAOHeaderExtraData(chain.Config(), header); err != <span class="literal">nil</span> &#123; <span class="comment">//❶</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consensus/misc/dao.go:47 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyDAOHeaderExtraData</span><span class="params">(config *params.ChainConfig, header *types.Header)</span> <span class="title">error</span></span> &#123; </span><br><span class="line"><span class="keyword">if</span> config.DAOForkBlock == <span class="literal">nil</span> &#123;<span class="comment">//❷</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">limit := <span class="built_in">new</span>(big.Int).Add(config.DAOForkBlock, params.DAOForkExtraRange) <span class="comment">//❸</span></span><br><span class="line"><span class="keyword">if</span> header.Number.Cmp(config.DAOForkBlock) &lt; <span class="number">0</span> || header.Number.Cmp(limit) &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> config.DAOForkSupport &#123;</span><br><span class="line"><span class="keyword">if</span> !bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123; <span class="comment">//❹</span></span><br><span class="line"><span class="keyword">return</span> ErrBadProDAOExtra</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;<span class="comment">//❺</span></span><br><span class="line"><span class="keyword">return</span> ErrBadNoDAOExtra</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// All ok, header has the same extra-data we expect</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>❶ 在校验区块头时增加 DAO 区块头识别校验。</li><li>❷ 如果节点未设置分叉点，则不校验。</li><li>❸ 确保只需在 DAO 分叉点的10个区块上校验。</li><li>❹ 如果节点允许分叉，则要求区块头 Extra 必须符合要求。</li><li>❺ 当然，如果节点不允许分叉，则也不能在区块头中加入非分叉链的 Extra 特殊信息。</li></ul><p>这种 <code>config.DAOForkBlock</code> 开关，类似于互联网公司产品新功能灰度上线的功能开关。<br>在区块链上，可以先实现功能代码逻辑。至于何时启用，则可以在社区、开发者讨论后，确定最终的开启时间。<br>当然区块链上区块高度等价于时间戳，比如 DAO 分叉点 1920000 也是讨论后敲定。</p><h3 id="如何分离网络？"><a href="#如何分离网络？" class="headerlink" title="如何分离网络？"></a>如何分离网络？</h3><p>如果分叉后不能快速地分离网络，会导致节点出现奇奇怪怪的问题。<br>长远来说，为针对以后可能出现的分叉，应设计一种通用解决方案，已降低代码噪音。<br>否则，你会发现代码中到处充斥着一些各种梗。<br>但时间又非常紧急，这次的 The DAO 分叉处理是通过特定代码拦截实现。</p><p>在我看来，区块链项目不同于其他传统软件，一旦发现严重BUG是非常致命的。<br>在上线后的代码修改，应保持尽可能少和充分测试。非常同意 the dao 的代码处理方式。<br>不必为以后可能的分叉，而做出觉得“很棒”的功能。<br>务实地解决问题才是正道。</p><p>不应该让节点同时成为两个阵营的中继点，应分离出两个网络，以让其互不干预。<br>The DAO 硬分叉的处理方式是:节点连接握手后，向对方请求分叉区块头信息。<br>在15秒必须响应，否则断开连接。</p><p>代码实现是在<code>eth/handler.go</code>文件中，在消息层进行拦截处理。</p><p>节点握手后，开始15秒倒计时，一旦倒计时结束，则断开连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eth/handler.go:300</span></span><br><span class="line">p.forkDrop = time.AfterFunc(daoChallengeTimeout, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.Log().Debug(<span class="string">"Timed out DAO fork-check, dropping"</span>)</span><br><span class="line">pm.removePeer(p.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在倒计时前，需要向对方索要区块头信息，以进行分叉校验。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eth/handler.go:297</span></span><br><span class="line"><span class="keyword">if</span> err := p.RequestHeadersByNumber(daoBlock.Uint64(), <span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此时，对方在接收到请求时，如果存在此区块头则返回，否则忽略。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="comment">// eth/handler.go:348</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == GetBlockHeadersMsg:  </span><br><span class="line"><span class="keyword">var</span> query getBlockHeadersData</span><br><span class="line"><span class="keyword">if</span> err := msg.Decode(&amp;query); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errResp(ErrDecode, <span class="string">"%v: %v"</span>, msg, err)</span><br><span class="line">&#125;</span><br><span class="line">hashMode := query.Origin.Hash != (common.Hash&#123;&#125;)</span><br><span class="line">first := <span class="literal">true</span></span><br><span class="line">maxNonCanonical := <span class="keyword">uint64</span>(<span class="number">100</span>) </span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">bytes   common.StorageSize</span><br><span class="line">headers []*types.Header</span><br><span class="line">unknown <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//省略一部分 ...</span></span><br><span class="line"><span class="keyword">return</span> p.SendBlockHeaders(headers)</span><br></pre></td></tr></table></figure><p>这样，有几种情况出现。根据不同情况分别处理：</p><ol><li>有返回区块头：</li></ol><p>如果返回的区块头不一致，则校验不通过，等待倒计时结束。<br>如果区块头一致，则根据前面提到的校验分叉区块方式检查。<br>校验失败，此直接断开连接，说明已经属于不同分叉。<br>校验通过，则关闭倒计时，完成校验。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eth/handler.go:465</span></span><br><span class="line"><span class="keyword">if</span> p.forkDrop != <span class="literal">nil</span> &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[<span class="number">0</span>].Number) == <span class="number">0</span> &#123; </span><br><span class="line">p.forkDrop.Stop()</span><br><span class="line">p.forkDrop = <span class="literal">nil</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[<span class="number">0</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">p.Log().Debug(<span class="string">"Verified to be on the other side of the DAO fork, dropping"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">p.Log().Debug(<span class="string">"Verified to be on the same side of the DAO fork"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>没有返回区块头：</li></ol><p>如果自己也没有到达分叉高度，则不校验，假定双方在同一个网络。<br>但我自己已经到达分叉高度，则考虑对方的TD是否高于我的分叉块。<br>如果是，则包容，暂时认为属于同一网络。否则，则校验失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eth/handler.go:442 </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &amp;&amp; p.forkDrop != <span class="literal">nil</span> &#123; </span><br><span class="line">verifyDAO := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">verifyDAO = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> verifyDAO &#123;</span><br><span class="line">p.Log().Debug(<span class="string">"Seems to be on the same side of the DAO fork"</span>)</span><br><span class="line">p.forkDrop.Stop()</span><br><span class="line">p.forkDrop = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转移资产"><a href="#转移资产" class="headerlink" title="转移资产"></a>转移资产</h3><p>上述所做的一切均为安全、稳定的硬分叉，隔离两个网络。<br>硬分叉的目的是，以人为介入的方式拦截攻击者资产。</p><p>一旦到达分叉点，则立即激活资产转移操作。<br>首先，矿工在挖到分叉点时，需执行转移操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miner/worker.go:877</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">commitNewWork</span><span class="params">(interrupt *<span class="keyword">int32</span>, noempty <span class="keyword">bool</span>, timestamp <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Create the current work task and check any fork transitions needed</span></span><br><span class="line">env := w.current</span><br><span class="line"><span class="keyword">if</span> w.config.DAOForkSupport &amp;&amp; w.config.DAOForkBlock != <span class="literal">nil</span> &amp;&amp; w.config.DAOForkBlock.Cmp(header.Number) == <span class="number">0</span> &#123;</span><br><span class="line">misc.ApplyDAOHardFork(env.state)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，任何节点在接收区块，进行本地处理校验时同样需要在分叉点执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_processor.go:66</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *StateProcessor)</span> <span class="title">Process</span><span class="params">(block *types.Block, statedb *state.StateDB, cfg vm.Config)</span> <span class="params">(types.Receipts, []*types.Log, <span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// Mutate the block and state according to any hard-fork specs</span></span><br><span class="line"><span class="keyword">if</span> p.config.DAOForkSupport &amp;&amp; p.config.DAOForkBlock != <span class="literal">nil</span> &amp;&amp; p.config.DAOForkBlock.Cmp(block.Number()) == <span class="number">0</span> &#123;</span><br><span class="line">misc.ApplyDAOHardFork(statedb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转移资金也是通过取款合约处理。<br>将The DAO 合约包括子合约的资金，全部转移到新合约中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApplyDAOHardFork</span><span class="params">(statedb *state.StateDB)</span></span> &#123;</span><br><span class="line"><span class="comment">// Retrieve the contract to refund balances into</span></span><br><span class="line"><span class="keyword">if</span> !statedb.Exist(params.DAORefundContract) &#123;</span><br><span class="line">statedb.CreateAccount(params.DAORefundContract)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move every DAO account and extra-balance account funds into the refund contract</span></span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> params.DAODrainList() &#123;</span><br><span class="line">statedb.AddBalance(params.DAORefundContract, statedb.GetBalance(addr))</span><br><span class="line">statedb.SetBalance(addr, <span class="built_in">new</span>(big.Int))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，合约资金已全部强制转移到新合约。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://eips.ethereum.org/EIPS/eip-779" target="_blank" rel="noopener">EIP 779: Hardfork Meta: DAO Fork</a></li><li><a href="https://blog.slock.it/hard-fork-specification-24b889e70703" target="_blank" rel="noopener">Hard Fork Specification</a></li><li><a href="https://github.com/ethereum/go-ethereum/pull/2814" target="_blank" rel="noopener">PR#2814-finalize the DAO fork</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然 The DAO 攻击发生在2016年，但解除攻击的方案依然值得学习。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="攻击" scheme="https://learnblockchain.cn/tags/%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一款以太坊安卓钱包系列5 - 发送转账交易</title>
    <link href="https://learnblockchain.cn/2019/04/04/eth-wallet-dev-5/"/>
    <id>https://learnblockchain.cn/2019/04/04/eth-wallet-dev-5/</id>
    <published>2019-04-04T06:34:14.000Z</published>
    <updated>2019-04-05T10:29:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>这是如何开发以太坊安卓钱包系列第5篇，利用钱包对交易进行本地签名，然后发送到以太坊网络。</p><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>发送一个交易， 逻辑上会包含三个步骤：</p><ol><li>构造交易对象；</li><li>对交易进行签名；</li><li>把签名后的交易序列化后发送到网络节点。</li></ol><p>第 2 3步，web3j 提供的API 几句代码就可以解决，关键第 1 步构造交易对象，我们来逐步分解。</p><h2 id="一个交易长什么样"><a href="#一个交易长什么样" class="headerlink" title="一个交易长什么样"></a>一个交易长什么样</h2><p>一个交易的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RawTransaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="keyword">private</span> BigInteger value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigInteger gasLimit;    </span><br><span class="line">    <span class="keyword">private</span> BigInteger gasPrice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigInteger nonce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起交易的时候，就是需要填充<strong>每一个字段</strong>，构建这样一个交易结构，每个字段含义如下：</p><ul><li><code>to</code> : 用户要转账的目标地址；</li><li><code>value</code>: 转账的金额；</li><li><code>gasLimit</code>: 表示用户愿意为交易准备的（计算和存储空间）工作量；</li><li><code>gasPrice</code>: 交易发起者愿意支付的<strong>单位工作量</strong>费用，矿工在选择交易的时候，是按照<code>gasPrice</code>进行排序，先服务高出价者，因此如果出价过低会导致交易迟迟不能打包确认，出价过高则费用较大；</li></ul><blockquote><p>Gas是以太坊的工作计费机制，是交易者给矿工打包的一笔<strong>预算</strong>，预算= gasLimit <em> gasPrice， 可以类比为请货车的运费：公里数 </em> 每公里单价。</p></blockquote><ul><li><p><code>nonce</code>: 交易序列号， 它可以用来防止重放攻击，如果没有nonce的活，同一笔交易就可以多次广播。同样的道理，如果遇到一个交易很久没有打包，可以使用相同的交易nonce序列号， 用更高的gasPrice 重发这笔交易；</p></li><li><p><code>data</code>: 交易的附加的消息，对于代币Token转账，则data就是调用函数的ABI编码数据，参考：<a href="https://learnblockchain.cn/2018/08/09/understand-abi/">如何理解以太坊ABI</a></p></li></ul><blockquote><p>这个结构中没有<code>from</code>地址 ，是因为在对交易用私钥签名后，可以推倒出用户地址。</p></blockquote><h2 id="交易界面"><a href="#交易界面" class="headerlink" title="交易界面"></a>交易界面</h2><p>用户在App界面通过以下界面来发起一个交易：<br><img src="https://img.learnblockchain.cn/2019/15543662438500.jpg!wl" alt=""></p><p>这个界面对应的<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">代码</a>是<code>SendActivity.java</code>，构造交易目标地址和金额可以直接从界面获得。</p><h2 id="设置-Gas"><a href="#设置-Gas" class="headerlink" title="设置 Gas"></a>设置 Gas</h2><p>如果 Gas 设置丢给用户，从体验上说有点说不过去，因此我们给用户一些推荐值。</p><h3 id="Gas-Price"><a href="#Gas-Price" class="headerlink" title="Gas Price"></a>Gas Price</h3><p>先说说gas price， <strong>gas price</strong> 是一个竞争值， 一个矿工能做的工作量基本是固定的，因此他总是会挑给价最高的，如果一个时间段内，提交的交易数量很多，价格也会随之水涨船高，如果交易少，价格就会下降。</p><p>那么设置一个合理的价格就显得很重要，怎么恰到好处设置一个不至于浪费又不用等待长时间的gas price呢？</p><p>幸运的是web3 提供了一个接口获取最近区块的gas price，因此可以这个作为推荐值。</p><blockquote><p>也有一些第三方提供的预测gas price的接口，如：<a href="https://www.etherchain.org/tools/gasPriceOracle" target="_blank" rel="noopener">gasPriceOracle</a> 、 <a href="https://ethgasstation.info/json/ethgasAPI.json" target="_blank" rel="noopener">ethgasAPI</a>、 <a href="https://etherscan.io/gastracker" target="_blank" rel="noopener">etherscan gastracker</a>，大家可自行选择。</p></blockquote><p>获取Gas设置，<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">代码</a>中提供了一个专门的类<code>FetchGasSettingsInteract</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchGasSettingsInteract</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;BigInteger&gt; gasPrice = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> BigInteger cachedGasPrice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FetchGasSettingsInteract</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        gasSettingsDisposable = Observable.interval(<span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS)</span></span></span><br><span class="line"><span class="function">                .<span class="title">doOnNext</span><span class="params">(l -&gt;fetchGasPriceByWeb3()</span></span></span><br><span class="line"><span class="function">                ).<span class="title">subscribe</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchGasPriceByWeb3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Web3j web3j = Web3j.build(rpcServerUrl));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EthGasPrice price = web3j.ethGasPrice().send();</span><br><span class="line">            <span class="keyword">if</span> (price.getGasPrice().compareTo(BalanceUtils.gweiToWei(BigDecimal.ONE)) &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cachedGasPrice = price.getGasPrice();</span><br><span class="line">                gasPrice.postValue(cachedGasPrice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// silently</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;BigInteger&gt; <span class="title">gasPriceUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gasPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FetchGasSettingsInteract 类中<code>gasPrice</code>是一个可以订阅的<code>LiveData</code>数据，<code>fetchGasPriceByWeb3</code>函数用于获取价格，在构造函数中使用了Observable.interval来开启一个间隔一分钟的循环任务，即每分钟去取一下最新的价格。</p><h3 id="Gas-Limit"><a href="#Gas-Limit" class="headerlink" title="Gas Limit"></a>Gas Limit</h3><p>Gas Limit用来确定工作量，不像Gas Price 谁时间的变化而浮动，工作量任务确定后，这个值就是固定的，如一个转账到普通的交易，工作量中是<code>21000</code>。</p><p>对于智能合约交易，gasLimit则根据执行的任务而变化，如果设定的不够，会发生<em>out-of-gas</em> 错误，交易就不会打包上链，如果设定的过高，多余的就会退回交易发起者，这也是为什么我把这个费用称为预算的原因。</p><p>有些人会认为直接设置高一点的值，反正会退回，但如果合约执行出错，就会吃掉所有的gas，对于ERC20转账，一般推荐设置的值为<code>90000</code>， 如果是运行非标准的智能合约，如使用DAPP，可以使用<code>ethEstimateGas</code> 函数进行预测。</p><blockquote><p>在钱包中运行DAPP，也是钱包的一项重要功能，我会在<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>进行介绍。</p></blockquote><p>这里使用推荐默认值，在FetchGasSettingsInteract加入方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Single&lt;GasSettings&gt; <span class="title">fetch</span><span class="params">(ConfirmationType type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Single.fromCallable( () -&gt; &#123;</span><br><span class="line">        BigInteger gasLimit;</span><br><span class="line">        <span class="keyword">if</span> (type == ConfirmationType.ETH) &#123;</span><br><span class="line">            gasLimit = <span class="keyword">new</span> BigInteger(<span class="number">21000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ConfirmationType.ERC20) &#123;</span><br><span class="line">            gasLimit = <span class="keyword">new</span> BigInteger(<span class="number">21000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GasSettings(cachedGasPrice, gasLimit);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免 SendActivity（UI） 与数据的耦合使用了<code>ConfirmationViewModel</code>， <code>ConfirmationViewModel</code> 中保留了一个 <code>FetchGasSettingsInteract</code> 对象，界面提供推荐的gas的代码逻辑调用流程是这样：</p><p><img src="https://learnblockchain.cn/svg/wallet_gas.svg" alt="diagram"></p><p>其中虚线部分是数据订阅回调，在SendActivity拿到GasSettings就可以进行展示。</p><div style="display: none"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Title: 获取Gas 过程</span><br><span class="line">SendActivity-&gt;ConfirmationViewModel: prepare</span><br><span class="line">ConfirmationViewModel-&gt;FetchGasSettingsInteract: gasPriceUpdate</span><br><span class="line">Note right of FetchGasSettingsInteract: 定时请求</span><br><span class="line">FetchGasSettingsInteract--&gt;&gt;ConfirmationViewModel: onGasPrice</span><br><span class="line">ConfirmationViewModel-&gt;FetchGasSettingsInteract: fetch</span><br><span class="line">FetchGasSettingsInteract-&gt;FetchGasSettingsInteract: fetch</span><br><span class="line">FetchGasSettingsInteract--&gt;&gt;ConfirmationViewModel: onGasSettings</span><br><span class="line">ConfirmationViewModel--&gt;&gt;SendActivity: onGasSettings</span><br></pre></td></tr></table></figure><br><br>流程图源码， hexo 无法渲染，使用 <a href="https://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">https://bramp.github.io/js-sequence-diagrams/</a><br></div><p>代码调用代码逻辑，大家最好把代码<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">https://github.com/xilibi2003/Upchain-wallet</a> 克隆到本地跟一下。</p><h2 id="确认交易数据"><a href="#确认交易数据" class="headerlink" title="确认交易数据"></a>确认交易数据</h2><p>用户在没有填写收款地址、发送金额以及调整好Gas（可选），在发送交易之前，一般需要用户再次确认下交易详情，使用下面这个对话框：</p><p><img src="https://img.learnblockchain.cn/2019/15543883352378.jpg!wl" alt=""></p><p>代码中使用的一个自定义的ConfirmTransactionView来展示这个信息，UI部分的代码就不贴了。</p><p>在用户确认无误之后，点击确认，用户输入<strong>密码</strong>之后，就可以正式发起交易了。</p><h2 id="获取nonce"><a href="#获取nonce" class="headerlink" title="获取nonce"></a>获取nonce</h2><p>细心的同学可能会发现，现在构造交易结构还差<code>nonce</code>，web3j提供了相应的API，获取的逻辑在EthereumNetworkRepository类中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Single&lt;BigInteger&gt; <span class="title">getLastTransactionNonce</span><span class="params">(Web3j web3j, String walletAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Single.fromCallable(() -&gt; &#123;</span><br><span class="line">        EthGetTransactionCount ethGetTransactionCount = web3j</span><br><span class="line">                .ethGetTransactionCount(walletAddress, DefaultBlockParameterName.PENDING)</span><br><span class="line">                .send();</span><br><span class="line">        <span class="keyword">return</span> ethGetTransactionCount.getTransactionCount();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发起交易"><a href="#发起交易" class="headerlink" title="发起交易"></a>发起交易</h2><p>完整的交易流程调用序列图如下：</p><p><img src="https://learnblockchain.cn/svg/wallet_transfer.svg" alt="diagram-3"></p><div style="display: none"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Title: 用户发起交易调用</span><br><span class="line">Note left of SendActivity: 用户点击发送</span><br><span class="line">SendActivity-&gt;ConfirmationViewModel: createTransaction</span><br><span class="line">ConfirmationViewModel-&gt;CreateTransactionInteract: createEthTransaction</span><br><span class="line">CreateTransactionInteract-&gt;EthereumNetworkRepository: getLastTransactionNonce</span><br><span class="line">CreateTransactionInteract-&gt;CreateTransactionInteract: createRawTransaction</span><br><span class="line">CreateTransactionInteract-&gt;CreateTransactionInteract: signMessage</span><br><span class="line">CreateTransactionInteract-&gt;CreateTransactionInteract: ethSendRawTransaction</span><br><span class="line">CreateTransactionInteract--&gt;&gt;ConfirmationViewModel: onCreateTransaction</span><br><span class="line">ConfirmationViewModel--&gt;&gt;SendActivity:onTransaction</span><br></pre></td></tr></table></figure><br><br>流程图源码， 因 hexo 无法渲染，使用 <a href="https://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">https://bramp.github.io/js-sequence-diagrams/</a><br></div><p>交易主要在<code>createEthTransaction</code>函数完成，逻辑有：</p><ol><li>获取交易nonce</li><li>使用nonce, gasPrice, gasLimit, to, amount 构造一个原始交易</li><li>使用 密码 + keystore 对原始交易进行签名</li><li>发送交易， 把txHash 封装为一个可回调的数据</li></ol><p><code>createEthTransaction</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Single&lt;String&gt;  <span class="title">createEthTransaction</span><span class="params">(ETHWallet from,  String to,</span></span></span><br><span class="line"><span class="function"><span class="params">    BigInteger amount,</span></span></span><br><span class="line"><span class="function"><span class="params">    BigInteger gasPrice, BigInteger gasLimit,</span></span></span><br><span class="line"><span class="function"><span class="params">    String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Web3j web3j = Web3j.build(rpcServerUrl));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> networkRepository.getLastTransactionNonce(web3j, from.address)</span><br><span class="line">            .flatMap(nonce -&gt; Single.fromCallable( () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        Credentials credentials = WalletUtils.loadCredentials(password,  keystorePath);</span><br><span class="line">        RawTransaction rawTransaction = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, to, amount);</span><br><span class="line">        <span class="keyword">byte</span>[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);</span><br><span class="line"></span><br><span class="line">        String hexValue = Numeric.toHexString(signedMessage);</span><br><span class="line">        EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).send();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ethSendTransaction.getTransactionHash();</span><br><span class="line"></span><br><span class="line">    &#125; ).subscribeOn(Schedulers.computation())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Token-转账交易"><a href="#Token-转账交易" class="headerlink" title="Token 转账交易"></a>Token 转账交易</h3><p>Token 转账交易部分，请订阅我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>。</p><div style="display: none"><br><br>对于Token 转账交易，有两点需要注意：<br>1. 交易的目标地址（即交易字段的<code>to</code>字段）其实不是用户填写的收款人钱包地址，目标地址是Token 合约地址。<br>2.  需要把对转账函数transfer的调用转化为交易的附加数据<code>data</code>。<br><br>转化为交易的附加数据的方法如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createTokenTransferData</span><span class="params">(String to, BigInteger tokenAmount)</span> </span>&#123;</span><br><span class="line">    List&lt;Type&gt; params = Arrays.&lt;Type&gt;asList(<span class="keyword">new</span> Address(to), <span class="keyword">new</span> Uint256(tokenAmount));</span><br><span class="line"></span><br><span class="line">    List&lt;TypeReference&lt;?&gt;&gt; returnTypes = Arrays.&lt;TypeReference&lt;?&gt;&gt;asList(<span class="keyword">new</span> TypeReference&lt;Bool&gt;() &#123;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Function function = <span class="keyword">new</span> Function(<span class="string">"transfer"</span>, params, returnTypes);</span><br><span class="line">    <span class="keyword">return</span> FunctionEncoder.encode(function);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>ERC20转账函数<code>createERC20Transfer</code> 有一点点不同：得到调用函数附加数据之后，在构造交易对象时，加入附加数据，部分代码如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String callFuncData = createTokenTransferData(to, amount);</span><br><span class="line">rawTransaction = RawTransaction.createTransaction(</span><br><span class="line">                    nonce, gasPrice, gasLimit, contractAddress, callFuncData);</span><br></pre></td></tr></table></figure><br><br><br></div><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/web3j" target="_blank" rel="noopener">web3j</a> </p><p>微信：xlbxiong 备注：钱包， 加入钱包开发的微信群。</p><p>加入<a href="https://learnblockchain.cn/images/zsxq.png">知识星球</a>，和一群优秀的区块链开发者一起学习。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，学区块链的都在这里，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是如何开发以太坊安卓钱包系列第5篇，利用钱包对交易进行本地签名，然后发送到以太坊网络。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="web3j" scheme="https://learnblockchain.cn/tags/web3j/"/>
    
  </entry>
  
  <entry>
    <title>DApp教程：用Truffle 开发一个链上记事本</title>
    <link href="https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/"/>
    <id>https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/</id>
    <published>2019-03-30T13:29:55.000Z</published>
    <updated>2019-04-05T10:29:31.030Z</updated>
    
    <content type="html"><![CDATA[<p>以编写一个链上记事本为例，介绍如何开发DApp，一年多前写的<a href="https://learnblockchain.cn/2018/01/12/first-dapp/">开发、部署第一个DApp</a>因为Truffle 、MetaMask、Solidity都有升级，也随手更新了。<br>通过两个教程大家可以更好理解前端如何与合约进行交互， 本文也将介绍如何使用Truffle 把合约部署到以太坊正式网络上（貌似很多人遇到问题）。</p><a id="more"></a><h2 id="项目背景及效果"><a href="#项目背景及效果" class="headerlink" title="项目背景及效果"></a>项目背景及效果</h2><p>链上记事本让事件永久上链，让事件成为无法修改的历史，从此再无删帖，之前有一个帖子，介绍如何MetaMask上链记事，现在我们通过这个DApp来完成。</p><p>链上记事本有两个功能：</p><ol><li>添加一个新记事</li><li>查看之前(自己的)记事本</li></ol><p><strong>实现效果：</strong><br><img src="https://img.learnblockchain.cn/2019/15539548973073.jpg!wl" alt=""></p><p>本合约也部署到以太坊官方测试网络Ropsten， 如Englist first Note 的交易记录可以在<a href="https://ropsten.etherscan.io/tx/0xd6b7366fa06a643be0de7abc26e04b0509595f9a1cf216e6f7c29f1ad78c8775" target="_blank" rel="noopener">EtherScan查询</a>。</p><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>创建项目文件夹：noteOnChain，然后在目录下，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle unbox pet-shop</span><br></pre></td></tr></table></figure><p>使用Truffle 对项目初始化。</p><blockquote><p>如果没有使用过truffle 可以阅读<a href="https://learnblockchain.cn/2018/01/12/first-dapp/">开发、部署第一个DApp</a>。</p></blockquote><p>Truffle 的Box，是一套套的开发模板， 它会帮助我们安装好相应的依赖，快速的启动应用开发。<br>如果我们项目需要是使用到 JQuery， Bootstrap库，使用<code>pet-shop</code>这个Box 是不错的选择，官方还提供了React 、 Vue 项目相应的模板，所有的Box 可以在<a href="https://truffleframework.com/boxes" target="_blank" rel="noopener">这里</a>查询。</p><h2 id="合约实现"><a href="#合约实现" class="headerlink" title="合约实现"></a>合约实现</h2><p>项目初始化会在<code>noteOnChain</code>目录下生成<code>contracts</code>目录来存放合约文件，在<code>contracts</code>目录下添加一个合约文件<code>NoteContract.sol</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract NoteContract &#123;    </span><br><span class="line">    mapping(address =&gt; string [] ) public notes;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event NewNote(address, string note);</span><br><span class="line"></span><br><span class="line">// 添加记事</span><br><span class="line">    function addNote( string memory note) public &#123;</span><br><span class="line">        notes[msg.sender].push(note);</span><br><span class="line">        emit NewNote(msg.sender, note);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getNotesLen(address own) public view returns (uint) &#123;</span><br><span class="line">        return notes[own].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约关键是状态变量<code>notes</code>的定义，这是一个mapping， 保存着所有地址下所有的记事本。</p><h3 id="修改记事本逻辑"><a href="#修改记事本逻辑" class="headerlink" title="修改记事本逻辑"></a>修改记事本逻辑</h3><p>如果需要修改笔记功能，可以在合约中加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event ModifyNote(address, uint index);</span><br><span class="line"></span><br><span class="line">function modifyNote(address own, uint index, string memory note) public &#123;</span><br><span class="line">    notes[own][index] = note;</span><br><span class="line">    emit ModifyNote(own, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要只有自己能修改笔记可以modifyNote的第一行加上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(own == msg.sender);</span><br></pre></td></tr></table></figure></p><h2 id="合约部署"><a href="#合约部署" class="headerlink" title="合约部署"></a>合约部署</h2><p>先为合约添加一个部署脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Note = artifacts.require(&quot;./NoteContract.sol&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  deployer.deploy(Note);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>truffle部署的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle migrate</span><br></pre></td></tr></table></figure><p>默认情况下，会部署到本地的Ganache提供的测试网络，本文介绍下如何通过Truffle部署到太坊官方网络，这里以<br>Ropsten为例介绍。</p><blockquote><p>Ganache 的安装使用可阅读<a href="https://learnblockchain.cn/2018/01/12/first-dapp/">开发、部署第一个DApp</a></p></blockquote><h3 id="Infura-节点服务注册-与-HDWalletProvider-安装"><a href="#Infura-节点服务注册-与-HDWalletProvider-安装" class="headerlink" title="Infura 节点服务注册 与 HDWalletProvider 安装"></a>Infura 节点服务注册 与 HDWalletProvider 安装</h3><p>大多数人应该都没有部署自己的节点，我们可以使用<a href="https://infura.io/" target="_blank" rel="noopener">Infura</a> 提供的节点服务。</p><blockquote><p>有部分人可能不解 Infura 服务，其实 MetaMask 后面的节点服务就是Infura。</p></blockquote><p>然后通过 <code>HDWalletProvider</code> 连接到Infura节点，并为我们签署交易，通过下面命令安装HDWalletProvider：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install truffle-hdwallet-provider</span><br></pre></td></tr></table></figure><p>在使用Infura之前，我们需要注册一个访问Infura服务的Token， 注册地址为：<a href="https://infura.io/register" target="_blank" rel="noopener">https://infura.io/register</a>， 注册后创建一个  Project, 复制节点url：</p><p><img src="https://img.learnblockchain.cn/2019/15540848537217.jpg!wl" alt=""></p><h3 id="为-truffle-配置一个新网络"><a href="#为-truffle-配置一个新网络" class="headerlink" title="为 truffle 配置一个新网络"></a>为 truffle 配置一个新网络</h3><p>修改<code>truffle.js</code> 加入一个新网络.</p><ol><li>首先引入 HDWalletProvider：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);</span><br></pre></td></tr></table></figure><ol><li>配置签名的钱包助记词：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mnemonic = &quot;orange apple banana ... &quot;;</span><br></pre></td></tr></table></figure><p>助记词其实不应该明文配置保存，最好配置在一个隐私文件里，并被代码管理工具所忽略。</p><ol><li>加入新网络，以Ropsten为例：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">networks: &#123;</span><br><span class="line">  ropsten: &#123;</span><br><span class="line">    provider: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HDWalletProvider(mnemonic, <span class="string">"https://ropsten.infura.io/xxx"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    network_id: <span class="number">3</span>,</span><br><span class="line">    gas: <span class="number">7003605</span>,</span><br><span class="line">    gasPrice: <span class="number">100000000000</span>,</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HDWalletProvider 的第一个参数是助记词（确保账号有足够的余额），第二个参数是 上面复制的 Infura 节点服务地址，gas 和 gasPrice 分别配置部署时的Gas Limit 和 Gas Price。</p><p>Truffle 网络的配置可查阅<a href="https://truffleframework.com/docs/truffle/reference/configuration#networks" target="_blank" rel="noopener">链接</a>。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>通过以下命令来选择网络部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle migrate --network ropsten</span><br></pre></td></tr></table></figure><p>此过程大约需要等待半分钟，正常的话会输出像下面的提示：</p><figure class="highlight plain"><figcaption><span>network 'ropsten'.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Deploying Migrations...</span><br><span class="line">  ... 0xd79bc3c5a7d338a7f85db9f86febbee738ebdec9494f49bda8f9f4c90b649db7</span><br><span class="line">  Migrations: 0x0c6c4fc8831755595eda4b5724a61ff989e2f8b9</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xc37320561d0004dc149ea42d839375c3fc53752bae5776e4e7543ad16c1b06f0</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Deploying NoteContract...</span><br><span class="line">  ... 0x7efbb3e4f028aa8834d0078293e0db7ff8aff88e72f33960fc806a618a6ce4d3</span><br><span class="line">  NoteContract: 0xda05d7bfa5b6af7feab7bd156e812b4e564ef2b1</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0x6257dd237eb8b120c8038b066e257baee03b9c447c3ba43f843d1856de1fe132</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><p>我们可以用输出的交易Hash到<a href="https://ropsten.etherscan.io/" target="_blank" rel="noopener">https://ropsten.etherscan.io/</a> 查询。</p><h2 id="前端界面"><a href="#前端界面" class="headerlink" title="前端界面"></a>前端界面</h2><p>Truffle Boxs为项目生成了html前端文件<code>src/index.html</code>，删除原来Boxs提供的宠物相关代码，加入一下html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-8 col-sm-push-1 "</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"new_note"</span> &gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">for</span>=<span class="string">"new_note"</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"add_new"</span>&gt;</span>添加笔记<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"notes"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上html 定义了一个文本框<code>textarea</code>用来输入笔记，定义了一个<code>button</code>用来提交笔记上链。<br>定义了一个id为 notes 的div， 用来加载已有笔记。初始内容为空，后通过<a href="https://web3.learnblockchain.cn/0.2x.x/" target="_blank" rel="noopener">web3</a>读取到合约里笔记后，通过JQuery插入。</p><h2 id="合约交互"><a href="#合约交互" class="headerlink" title="合约交互"></a>合约交互</h2><p>删除原来Boxs提供的加载宠物逻辑，逻辑分三个部分：</p><ol><li>初始化 web3 及合约</li><li>获取笔记填充到前端页面</li><li>发布笔记上链</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p> 在<code>initWeb3</code>函数中，完成web3的初始化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最新dapp 浏览器或MetaMask  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.ethereum) &#123;</span><br><span class="line">  App.web3Provider = <span class="built_in">window</span>.ethereum;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 请求账号授权</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">window</span>.ethereum.enable();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// User denied account access...</span></span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"User denied account access"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Legacy dapp browsers...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.web3) &#123;</span><br><span class="line">  App.web3Provider = <span class="built_in">window</span>.web3.currentProvider;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  App.web3Provider = <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:9545'</span>);</span><br><span class="line">&#125;</span><br><span class="line">web3 = <span class="keyword">new</span> Web3(App.web3Provider);</span><br></pre></td></tr></table></figure><p>完成<code>initContract</code>初始化合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">initContract: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.getJSON(<span class="string">'NoteContract.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      App.contracts.noteContract = TruffleContract(data);</span><br><span class="line">      App.contracts.noteContract.setProvider(App.web3Provider);</span><br><span class="line"></span><br><span class="line">      App.contracts.noteContract.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">        App.noteIntance = instance;</span><br><span class="line">        <span class="keyword">return</span> App.getNotes();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> App.bindEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取笔记填充到前端页面"><a href="#获取笔记填充到前端页面" class="headerlink" title="获取笔记填充到前端页面"></a>获取笔记填充到前端页面</h3><p><code>initContract</code>函数里， <code>noteIntance</code>保存了部署后的合约实例，getNotes用来获取当前账号的所有笔记:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getNotes: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    App.noteIntance.getNotesLen(App.account).then(<span class="function"><span class="keyword">function</span>(<span class="params">len</span>) </span>&#123;</span><br><span class="line">      App.noteLength = len;</span><br><span class="line">      <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        App.loadNote( len - <span class="number">1</span>);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前solidity 还无法支持返回动态类型的数组，没有办法直接获取到如string 数组的内容，所有这里采用一个变通的方法，先获取到笔记的长度，然后通过loadNote来逐条获取笔记：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loadNote: <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    App.noteIntance.notes(App.account, index).then(<span class="function"><span class="keyword">function</span>(<span class="params">note</span>) </span>&#123;</span><br><span class="line">      $(<span class="string">"#notes"</span>).append(</span><br><span class="line">      <span class="string">'&lt;div &gt; &lt;textarea &gt;'</span></span><br><span class="line">      + note</span><br><span class="line">      + <span class="string">'&lt;/textarea&gt;&lt;/div&gt;'</span> ;</span><br><span class="line">      <span class="keyword">if</span> (index <span class="number">-1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        App.loadNote(index - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; ).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布笔记上链"><a href="#发布笔记上链" class="headerlink" title="发布笔记上链"></a>发布笔记上链</h3><p>使用JQuery监听用户点击<code>add_new</code>按钮，然后调用合约的 <code>addNote</code> 函数把用户输入的笔记存储到智能合约。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  bindEvents: function() &#123;</span><br><span class="line">    $(&quot;#add_new&quot;).on(&apos;click&apos;, function() &#123;</span><br><span class="line">      $(&quot;#loader&quot;).show();</span><br><span class="line"></span><br><span class="line">      App.noteIntance.addNote($(&quot;#new_note&quot;).val()).then(function(result) &#123;</span><br><span class="line">         return App.watchChange();</span><br><span class="line">      &#125;).catch(function (err) &#123;</span><br><span class="line">        console.log(err.message);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行DApp"><a href="#运行DApp" class="headerlink" title="运行DApp"></a>运行DApp</h2><p>使用以下命令，启动DApp 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>在浏览器打开<code>http://localhost:3000</code> 浏览器的MetaMask 也需要连接Ropsten网络，确保网络一致。</p><blockquote><p>不知道如何设置MetaMask 可阅读<a href="https://learnblockchain.cn/2018/01/12/first-dapp/">开发、部署第一个去中心化应用(</a>。</p></blockquote><p>本文为保持主干清晰，代码有删减， 网站代码请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://truffleframework.com/" target="_blank" rel="noopener">Truffle 官方文档</a> </p><p>加我微信：xlbxiong 备注：DApp， 加入以太坊DApp开发微信群。</p><p>加入<a href="https://learnblockchain.cn/images/zsxq.png">知识星球</a> 成长比别人快一点。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，学区块链的都在这里，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以编写一个链上记事本为例，介绍如何开发DApp，一年多前写的&lt;a href=&quot;https://learnblockchain.cn/2018/01/12/first-dapp/&quot;&gt;开发、部署第一个DApp&lt;/a&gt;因为Truffle 、MetaMask、Solidity都有升级，也随手更新了。&lt;br&gt;通过两个教程大家可以更好理解前端如何与合约进行交互， 本文也将介绍如何使用Truffle 把合约部署到以太坊正式网络上（貌似很多人遇到问题）。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Dapp" scheme="https://learnblockchain.cn/categories/ethereum/Dapp/"/>
    
    
      <category term="Dapp" scheme="https://learnblockchain.cn/tags/Dapp/"/>
    
      <category term="Truffle" scheme="https://learnblockchain.cn/tags/Truffle/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一款以太坊安卓钱包系列4 - 获取以太及Token余额</title>
    <link href="https://learnblockchain.cn/2019/03/26/eth-wallet-dev-4/"/>
    <id>https://learnblockchain.cn/2019/03/26/eth-wallet-dev-4/</id>
    <published>2019-03-26T13:40:50.000Z</published>
    <updated>2019-04-05T10:29:31.039Z</updated>
    
    <content type="html"><![CDATA[<p>这是如何开发以太坊安卓钱包系列，接<a href="https://learnblockchain.cn/2019/03/24/eth_wallet_dev_3/">上一篇</a>继续展示钱包账号资产信息，这篇来看看如何获取账号的以太余额及Token余额。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在<a href="https://learnblockchain.cn/2019/03/24/eth_wallet_dev_3/">上一篇</a>中，为了避免 UI 与上面4个数据的耦合，使用了一个<code>TokensViewModel</code>，并且已经完成当前选中账号<code>defaultWallet</code>的获取，我们在回看一下<code>TokensViewModel</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokensViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;ETHWallet&gt; defaultWallet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;NetworkInfo&gt; defaultNetwork;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Token[]&gt; tokens;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Ticker&gt; prices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面还有三个变量，一个是tokens， 当前账号下 所拥有的 Token 数组； 一个是<code>defaultNetwork</code>当前选中网络，还有一个<code>prices</code>我们下一遍介绍。</p><p>为什么需要 <code>defaultNetwork</code> 来保存网络信息呢？ 这是因为同一个账号，他在不同的网络下，其余额是不同的，而登链钱包又可以支持多个不同的网络，所有我们在获取账号余额前，需要确定一下其网络。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h3><p>这里补充下以太坊网络，当前以太坊在使用的网络有5个：</p><ul><li>Mainnet ：主网，真正有价值的网络，当前Pow共识；</li><li>Ropsten ：测试网网络， 使用Pow，和当前的公有链环境一致；</li><li>Kovan ：测试网网络， 使用PoA共识，仅parity钱包支持；</li><li>Rinkeby：测试网网络，使用PoA共识 仅geth钱包支持；</li><li>Goerli：测试网网络，为Eth2.0 作准备启动的一个跨客户端的网络。</li></ul><p>除此之外，登链钱包还支持本地开发网络。</p><h3 id="NetworkInfo"><a href="#NetworkInfo" class="headerlink" title="NetworkInfo"></a>NetworkInfo</h3><p>代码中使用 <code>NetworkInfo</code>类 来表示一个网络，其定义如下，大家看一下注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;  <span class="comment">// 网络名称，如 mainnet， ropsten</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String symbol;  <span class="comment">// ETH</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String rpcServerUrl;  <span class="comment">// 节点提供的rpc 服务地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String backendUrl;    <span class="comment">// 查询交易的列表的服务url</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String etherscanUrl;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> chainId;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isMainNetwork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>EthereumNetworkRepository.java</code>中用一个 NetworkInfo 数组 <code>NETWORKS</code> 列出了所有支持的网络，其中包含了一个本地开发网络，：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NetworkInfo[] NETWORKS = <span class="keyword">new</span> NetworkInfo[] &#123;</span><br><span class="line">        <span class="keyword">new</span> NetworkInfo(<span class="string">"Mainnet"</span>,<span class="string">"ETH"</span>,</span><br><span class="line">                <span class="string">"https://mainnet.infura.io/llyrtzQ3YhkdESt2Fzrk"</span>,</span><br><span class="line">                <span class="string">"https://api.trustwalletapp.com/"</span>,</span><br><span class="line">                <span class="string">"https://etherscan.io/"</span>,<span class="number">1</span>, <span class="keyword">true</span>),</span><br><span class="line">        <span class="comment">// ignore some ...  </span></span><br><span class="line">        <span class="keyword">new</span> NetworkInfo(<span class="string">"local_dev"</span>,<span class="string">"ETH"</span>,</span><br><span class="line">                <span class="string">"http://192.168.8.100:8545"</span>,</span><br><span class="line">                <span class="string">"http://192.168.8.100:8000/"</span>,</span><br><span class="line">                <span class="string">""</span>,<span class="number">1337</span>, <span class="keyword">false</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>NetworkInfo</code>中节点及交易查询服务，我们可以选择自己<a href="https://learnblockchain.cn/2018/03/18/create_private_blockchain/">搭建节点</a>（使用Geth、Ganache 等工具），或使用第三方的服务。</p><h3 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h3><p>如果是测试网络，就必须得自己搭建节点，如使用geth启动一个网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir  my_datadir --dev --rpc --rpcaddr <span class="string">"0.0.0.0"</span> console</span><br></pre></td></tr></table></figure><p>特别要注意，需要对<code>--rpcaddr</code> 进行设置，表示哪一个地址能接受RPC请求，因为默认情况下，geth只接受来自 localhost 的请求，这样就无法接受到来自手机的客户端的请求。<br>如果是Ganache，可以点击Ganache右上角的设置，进行配置。</p><h3 id="确定当前网络"><a href="#确定当前网络" class="headerlink" title="确定当前网络"></a>确定当前网络</h3><p>在钱包有一个设置项，会把用户选中的网络的<code>name</code>保存到 <code>SharedPreference</code>， 如图：</p><p><img src="https://img.learnblockchain.cn/2019/15536708197342.jpg!wl" alt=""></p><p>确定网络的代码逻辑就简单了： 从<code>SharedPreference</code>读取到选中的网络名再对<code>NETWORKS</code> 做一个匹配，<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">代码</a>在<code>EthereumNetworkRepository</code>中，大家可对照查看。</p><h2 id="Coin-还是-Token"><a href="#Coin-还是-Token" class="headerlink" title="Coin 还是 Token"></a>Coin 还是 Token</h2><p>Coin 指的是以太币，Token 是大家通常所说的代币 或 通证，以太余额何Token余额，他们的获取方式是不一样的，明白这一点很重要，有必要先介绍下以太坊账户模型。</p><h3 id="以太坊账户模型"><a href="#以太坊账户模型" class="headerlink" title="以太坊账户模型"></a>以太坊账户模型</h3><p>以太币Eth是以太坊的原生代币，在以太坊的账户模型中，有一个字段<code>balance</code>存储着余额，例如账号的定义像下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Account &#123;</span><br><span class="line">  nonce: &apos;0x01&apos;,</span><br><span class="line">  balance: &apos;0x03e7&apos;,  // wei</span><br><span class="line">  stateRoot: &apos;0x56abc....&apos;,</span><br><span class="line">  codeHash: &apos;0x56abc....&apos;, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取以太币的余额只需要调用web3j提供的RPC接口<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getbalance" target="_blank" rel="noopener"><code>eth_getBalance</code></a>。</p><p>而一个地址的Token余额，他记录在Token合约上，注意合约其实也是一个账户（合约账户），Token是指<br>符合<a href="https://learnblockchain.cn/2018/01/12/create_token/">ERC20标准</a>的合约， 每个地址的余额通常存储在一个<code>Mapping</code>类型的<code>balanceOf</code>变量中，获取地址的余额需要调用合约的balanceOf方法，并给他传递地址作为参数。</p><blockquote><p>如果在合约地址上调用 <code>eth_getBalance</code>， 获取的是合约上所存的 eth余额。</p></blockquote><h3 id="Token-amp-TokenInfo"><a href="#Token-amp-TokenInfo" class="headerlink" title="Token &amp; TokenInfo"></a>Token &amp; TokenInfo</h3><p>在登链代码里，每一种币及余额封装成了一个<code>Token</code>类，不论是以太币还是Token 都处理是一个<code>Token</code>实例。</p><p>这里Token 命名不是很严谨，以太币一般称为Coin，为了方便，<strong>Coin和Token 都统一作为Token处理</strong>，Coin 作为一个特殊的Token，了解这一点对后文阅读很重要。</p><p>Token的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> TokenInfo tokenInfo;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String balance;    <span class="comment">// 币余额</span></span><br><span class="line">    <span class="keyword">public</span> String value;            <span class="comment">// 币对应的法币价值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String address;  <span class="comment">// 合约地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String symbol;   <span class="comment">// 代币符号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> decimals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="账号所有资产"><a href="#账号所有资产" class="headerlink" title="账号所有资产"></a>账号所有资产</h2><p>资产包括以太币资产及Token资产。</p><h3 id="关联-Token"><a href="#关联-Token" class="headerlink" title="关联 Token"></a>关联 Token</h3><p>在获取账号余额之前，我们需要先知道有多少 Token 种类，然后再获取每种Token余额。在<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">登链钱包</a>中，每一账号在某个网络下所关联 Token种类，保存为一个 <a href="https://realm.io/docs/java/latest/" target="_blank" rel="noopener">Realm</a>文件，相关逻辑在<code>RealmTokenSource</code>类中。</p><blockquote><p>Realm 是一个移动端数据库，是替代sqlite的一种解决方案。</p></blockquote><p>在用户通过以下界面添加新资产，会调用<code>RealmTokenSource</code>类的<code>put</code>方法保存到<code>.realm</code>文件。<br><img src="https://img.learnblockchain.cn/2019/15536710194901.jpg!wl" alt=""></p><p>现在来看看如何获取账号所关联的 Token， 逻辑上比较简单，不过涉及了多个类，我把调用序列图梳理一下：</p><p><img src="https://img.learnblockchain.cn/2019/15536757559224.jpg!wl" alt=""></p><div style="display: none"><br><br>流程图源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: 获取账号Token种类</span><br><span class="line">TokensViewModel-&gt;FetchTokensInteract: fetch</span><br><span class="line">FetchTokensInteract-&gt;TokenRepository: fetch</span><br><span class="line">TokenRepository-&gt;TokenLocalSource: fetch</span><br><span class="line">TokenLocalSource--&gt;&gt;TokensViewModel: OnTokens</span><br></pre></td></tr></table></figure><br><br></div><p>通过这个调用过程，最终通过TokensViewModel类的onTokens获取到Token种类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onTokens</span><span class="params">(Token[] tokens)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.tokens.postValue(tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在PropertyFragmeng界面中订阅收到数据之后，把它设置到界面的Adapter里，完成Token列表的显示。</p><h3 id="Ethplorer-API-服务"><a href="#Ethplorer-API-服务" class="headerlink" title="Ethplorer-API 服务"></a>Ethplorer-API 服务</h3><p>TokenRepository在执行fetch方法时，如果是在主网下，会调用<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">代码</a>中<br><code>EthplorerTokenService</code>类，从第三方服务<a href="https://api.ethplorer.io" target="_blank" rel="noopener">Ethplorer-API</a>获取到获取到某一个地址所关联的所有的Token种类。</p><p>Ethplorer-API提供的API更多，不过我们只需要<a href="https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-address-info" target="_blank" rel="noopener">getAddressInfo</a>接口，请求接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/getAddressInfo/0xaccount?apiKey=freekey</span><br></pre></td></tr></table></figure><p>Ethplorer-API 的免费接口是有请求限额，每2秒才能发起一个请求，需要注意访问频度。</p><h2 id="余额-balance"><a href="#余额-balance" class="headerlink" title="余额 balance"></a>余额 balance</h2><h3 id="获取以太余额"><a href="#获取以太余额" class="headerlink" title="获取以太余额"></a>获取以太余额</h3><p>分为两步：</p><ol><li>先构造出web3j 对象</li><li>web3j 调用 ethGetBalance 获取以太余额</li></ol><p>web3j对象的构造方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3j = Web3j.build(<span class="keyword">new</span> HttpService(networkInfo.rpcServerUrl, httpClient, <span class="keyword">false</span>));</span><br></pre></td></tr></table></figure></p><p>web3j对象在TokenRepository初始化的时候完成，在TokenRepository获取到Token列表之后，如果是以太币会随即会调用<code>getEthBalance</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BigDecimal <span class="title">getEthBalance</span><span class="params">(String walletAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(web3j</span><br><span class="line">            .ethGetBalance(walletAddress, DefaultBlockParameterName.LATEST)</span><br><span class="line">            .send()</span><br><span class="line">            .getBalance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-Token-数量"><a href="#获取-Token-数量" class="headerlink" title="获取 Token 数量"></a>获取 Token 数量</h3><p>在TokenRepository获取到Token列表之后，如果是ERC20代币会随即会调用<code>getBalance</code> 方法。<br>根据前面的介绍获取代币的余额需要调用合约的balanceOf方法，在以太坊上<strong>对合约方法的调用实际上会合约地址发起一个调用，调用的附加数据是函数及参数的ABI编码数据</strong>。</p><blockquote><p>之前写过一篇文章：<a href="https://learnblockchain.cn/2018/08/09/understand-abi/">如何理解以太坊ABI</a>， 大家可以读一下。</p></blockquote><p>用以下方法构造出<code>balanceOf</code>的ABI函数类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> org.web3j.abi.datatypes.<span class="function">Function <span class="title">balanceOf</span><span class="params">(String owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> org.web3j.abi.datatypes.Function(</span><br><span class="line">            <span class="string">"balanceOf"</span>,</span><br><span class="line">            Collections.singletonList(<span class="keyword">new</span> Address(owner)),</span><br><span class="line">            Collections.singletonList(<span class="keyword">new</span> TypeReference&lt;Uint256&gt;() &#123;&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到balanceOf的ABI 之后，经过编码之后，使用 createEthCallTransaction来构造这样一个交易：交易的发起者是当前的账号，交易的目标地址是合约地址，附加数据是编码之后的数据，getBalance方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BigDecimal <span class="title">getBalance</span><span class="params">(String walletAddress, TokenInfo tokenInfo)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    org.web3j.abi.datatypes.Function function = balanceOf(walletAddress);</span><br><span class="line">    String responseValue = callSmartContractFunction(function, tokenInfo.address, walletAddress);</span><br><span class="line"></span><br><span class="line">    List&lt;Type&gt; response = FunctionReturnDecoder.decode(</span><br><span class="line">            responseValue, function.getOutputParameters());</span><br><span class="line">    <span class="keyword">if</span> (response.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(((Uint256) response.get(<span class="number">0</span>)).getValue());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">callSmartContractFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        org.web3j.abi.datatypes.Function function, String contractAddress, String walletAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String encodedFunction = FunctionEncoder.encode(function);</span><br><span class="line"></span><br><span class="line">    EthCall response = web3j.ethCall(</span><br><span class="line">            Transaction.createEthCallTransaction(walletAddress, contractAddress, encodedFunction),</span><br><span class="line">            DefaultBlockParameterName.LATEST)</span><br><span class="line">            .sendAsync().get();</span><br><span class="line">    <span class="keyword">return</span> response.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="余额格式化"><a href="#余额格式化" class="headerlink" title="余额格式化"></a>余额格式化</h3><p>上面获取到的余额，是以最小单位表示的一个数，如以太币余额用wei表示，而现示给用户的数据是ether，即大家说的以太。 </p><blockquote><p>注： 1 eth = 10^18 wei , 更多<a href="https://learnblockchain.cn/2018/02/02/solidity-unit/">单位转换</a></p></blockquote><p>转换方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal decimalDivisor = <span class="keyword">new</span> BigDecimal(Math.pow(<span class="number">10</span>, decimals));</span><br><span class="line">BigDecimal ethbalance = balance.divide(decimalDivisor);</span><br></pre></td></tr></table></figure><p>对以太币而言 decimals 为 18，之后 ethbalance 会转化为一个保留4位小数点数的字符串保存到Token类型的<code>balance</code>变量，转换方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethBalance.setScale(<span class="number">4</span>, RoundingMode.CEILING).toPlainString()</span><br></pre></td></tr></table></figure></p><p>UI界面最终通过订阅 tokens 数组获取Token种类及余额，代码查阅<code>PropertyFragment.java</code> 。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/web3j" target="_blank" rel="noopener">web3j</a><br><a href="https://realm.io/docs/java/latest/" target="_blank" rel="noopener">Realm</a><br><a href="https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API" target="_blank" rel="noopener">Ethplorer-API</a> </p><p>加我微信：xlbxiong 备注：钱包， 加入钱包开发的微信群。</p><p>加入<a href="https://learnblockchain.cn/images/zsxq.png">知识星球</a>，和一群优秀的区块链从业者一起学习。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，学区块链的都在这里，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是如何开发以太坊安卓钱包系列，接&lt;a href=&quot;https://learnblockchain.cn/2019/03/24/eth_wallet_dev_3/&quot;&gt;上一篇&lt;/a&gt;继续展示钱包账号资产信息，这篇来看看如何获取账号的以太余额及Token余额。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="web3j" scheme="https://learnblockchain.cn/tags/web3j/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一款以太坊安卓钱包系列3 - 资产信息展示</title>
    <link href="https://learnblockchain.cn/2019/03/24/eth_wallet_dev_3/"/>
    <id>https://learnblockchain.cn/2019/03/24/eth_wallet_dev_3/</id>
    <published>2019-03-24T13:59:44.000Z</published>
    <updated>2019-04-05T10:29:31.019Z</updated>
    
    <content type="html"><![CDATA[<p>这是如何开发以太坊（安卓）钱包系列第3篇， 钱包账号资产信息展示，展示信息主要包括账号地址、eth余额及该账号所拥有的Token及余额。</p><a id="more"></a><h2 id="预备知识-MVVM"><a href="#预备知识-MVVM" class="headerlink" title="预备知识 MVVM"></a>预备知识 MVVM</h2><p>本文会涉及和UI界面的交互，提前理解下界面和数据如何交互是非常有必要的，如果你已经很熟悉MVVM，可跳过这一小节。</p><p>最早写Android的时候，数据和界面经常耦合在一起，一个Activity文件总是特别大，每当产品界面改版就非常痛苦，吐槽下，很多产品经理都喜欢对界面改来改去。</p><p>后来Google 推荐多个架构模式： MPV、 MVVM模式来解决数据和UI耦合的问题，<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">登链钱包代码</a>，使用的就是MVVM模式，所以对它做一个简单介绍，下面是MVVM的视图和数据的交互图：</p><p><img src="https://img.learnblockchain.cn/2019/15532408840119.jpg!wl" alt=""></p><p>View 通常对应于Activity/Fragment/自定义View<br>Model：则是和数据相关的模块。</p><p>View 与 Model 不直接发生联系， 而是通过ViewModel负责接收View层的事件以及获取并处理数据，ViewModel层的数据变化也会通知给View层进行相应的UI的更新，从而实现业务逻辑和Ui的隔离。</p><p>使用MVVM模式最大的优点就是<strong>解耦</strong>， 因为数据处理逻辑是独立于View, 在UI更改时，ViewModel 不用做太多改动。</p><p>我们使用了Google在I/O大会推出的一套遵循MVVM开发模式的<strong>LiveData和ViewModel</strong>组件架构。</p><h3 id="ViewModel-和-LiveData"><a href="#ViewModel-和-LiveData" class="headerlink" title="ViewModel 和 LiveData"></a>ViewModel 和 LiveData</h3><p>ViewModel 会关注UI生命周期来存储和管理数据，在Activity发生变化（锁屏开屏、旋转）时，ViewModel 会自动保留之前的数据并给新的Activity或Fragment使用，当界面被系统销毁时，ViewModel也会进行资源清理，避免内存泄漏。</p><p>ViewModel 还可以用于不同界面间数据共享。</p><p>LiveData是一个可观察的数据持有者类。观察者可以方便我们以<strong>异步的方式获取数据</strong>，同时LiveData也是有生命周期感知的。如果其生命周期处于STARTED或RESUMED状态。LiveData会将观察者视为活动状态，并通知其数据的变化。LiveData未注册的观察对象以及非活动观察者是不会收到有关更新的通知。</p><p>了解更多，可自行以关键字： Lifecycle、ViewModel、LiveData 进行搜索。</p><h2 id="账号信息展示"><a href="#账号信息展示" class="headerlink" title="账号信息展示"></a>账号信息展示</h2><p>展示信息主要包括账号地址、eth余额及该账号所拥有的Token及余额， 其界面效果如下:</p><p><img src="https://img.learnblockchain.cn/2019/15532473043633.jpg!wl" alt="上图"></p><blockquote><p>这个界面应的是<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">登链钱包</a>的<code>PropertyFragment</code>，上图的UPT 是我自己发行的Token，所以没有显示价格</p></blockquote><p>现在我们来<strong>思考</strong>一下， 怎么来展现上面的数据， 别着急往下看， 可以先想想。</p><p>先对问题做一个拆分，把数据拆分为4个部分：</p><ol><li>显示当前选中的账号</li><li>显示当前账号 ETH 余额</li><li>显示当前账号下 Token 数量</li><li>显示对应的法币金额。</li></ol><p>为了避免 UI 与上面4个数据的耦合，代码使用了一个<code>TokensViewModel</code>， 获取到的数据用 LiveData做了一个Wrap，以便UI可以订阅数据，TokensViewModel类像下面，<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">代码</a>有删减：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokensViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;ETHWallet&gt; defaultWallet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;NetworkInfo&gt; defaultNetwork;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Token[]&gt; tokens;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Ticker&gt; prices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MutableLiveData</code>  是前面提到的 LiveData的子类，在UI界面中就可以对数据进行订阅，下面我们逐一拆解下每个数据。</p><h3 id="显示当前账号"><a href="#显示当前账号" class="headerlink" title="显示当前账号"></a>显示当前账号</h3><p>可以分为两个步骤： </p><ol><li>从数据库中读取账号；</li><li>界面显示账号</li></ol><p>TokensViewModel中定义了一个<code>MutableLiveData&lt;ETHWallet&gt; defaultWallet</code> ，从数据库中读取账号会保存在defaultWallet中，然后UI对 defaultWallet 进行观察显示。</p><blockquote><p>注解: <a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">登链钱包</a> 里大量使用的这个方式，通过一个LiveData 做数据桥接。</p></blockquote><p>在上一篇<a href="https://learnblockchain.cn/2019/03/18/eth-wallet-dev-2/">导入账号及账号管理</a>，所有的账号使用greenDao 存储起来， 因此我们只需要把所有账号从加载出来，挑选出当前选中的那一个。 结合代码看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WalletDaoUtils.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ETHWallet <span class="title">getCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ETHWallet&gt; ethWallets = ethWalletDao.loadAll();</span><br><span class="line">        <span class="keyword">for</span> (ETHWallet ethwallet : ethWallets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ethwallet.isCurrent()) &#123;</span><br><span class="line">                ethwallet.setCurrent(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> ethwallet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码先用 <code>ETHWalletDao.loadAll</code> 加载出所有的账号，返回当前选中的，上面的代码会被<code>FetchWalletInteract</code> 类的 <code>findDefault</code>方法调用，在ViewModle里，很多时候以数据进行交互的类，我们会命名为 <code>xxxInteract</code>，这也是一个习惯用法。</p><p>其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FetchWalletInteract.java</span></span><br><span class="line"><span class="comment">// 返回一个可订阅的Single&lt;ETHWallet&gt; 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Single&lt;ETHWallet&gt; <span class="title">findDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Single.fromCallable(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">return</span> WalletDaoUtils.getCurrent();</span><br><span class="line">     &#125;).subscribe(<span class="keyword">this</span>::onDefaultWallet);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取到默认钱包账号 设置到 defaultWallet 这个LiveData</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDefaultWallet</span><span class="params">(ETHWallet wallet)</span> </span>&#123;</span><br><span class="line">     defaultWallet.setValue(wallet);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>findDefault()</code>返回一个可订阅的<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Single.html" target="_blank" rel="noopener">Single</a><ethwallet> 对象，如果不熟悉可参考后面的文档。</ethwallet></p><p>之后，在UI界面<code>PropertyFragment.java</code> 中， 就可以对 <code>defaultWallet</code> 进行订阅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokensViewModel.defaultWallet().observe(<span class="keyword">this</span>,  <span class="keyword">this</span>::showWallet);</span><br></pre></td></tr></table></figure><p>当获取到默认账号时，就会回调<code>showWallet</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// UI 显示</span><br><span class="line">    public void showWallet(ETHWallet wallet) &#123;</span><br><span class="line">        tvWalletName.setText(wallet.getName());</span><br><span class="line">        tvWalletAddress.setText(wallet.getAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样， 界面的显示就完成了，<a href="https://learnblockchain.cn/2019/03/26/eth_wallet_dev_4/">下一篇</a>继续介绍获取余额。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">lifecycle官方文档地址</a></li><li><a href="https://github.com/ReactiveX/RxAndroid/" target="_blank" rel="noopener">RxAndroid</a> 了解更多响应式编程</li></ol><p>我创建了一个专门讨论钱包开发的微信群，加微信：xlbxiong 备注：钱包。</p><p>加入<a href="https://learnblockchain.cn/images/zsxq.png">知识星球</a>，和一群优秀的区块链从业者一起学习。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，学区块链的都在这里，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是如何开发以太坊（安卓）钱包系列第3篇， 钱包账号资产信息展示，展示信息主要包括账号地址、eth余额及该账号所拥有的Token及余额。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="web3j" scheme="https://learnblockchain.cn/tags/web3j/"/>
    
  </entry>
  
  <entry>
    <title>跨链技术的分析和思考</title>
    <link href="https://learnblockchain.cn/2019/03/23/blockchain_interoperability/"/>
    <id>https://learnblockchain.cn/2019/03/23/blockchain_interoperability/</id>
    <published>2019-03-23T04:04:30.000Z</published>
    <updated>2019-04-05T10:29:31.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当前的区块链底层技术平台百花齐放，不同的业务、不同的技术底层的区块链之间缺乏统一的互联互通的机制，这极大限制了区块链技术和应用生态的健康发展。跨链的需求由此而来，本文通过分析几种主流的跨链方案探讨跨链技术的本质及相应的解决思路。</p></blockquote><a id="more"></a><h2 id="跨链的类型"><a href="#跨链的类型" class="headerlink" title="跨链的类型"></a>跨链的类型</h2><p>跨链交互根据所跨越的区块链底层技术平台的不同可以分为同构链跨链和异构链跨链：同构链之间安全机制、共识算法、网络拓扑、区块生成验证逻辑都一致，它们之间的跨链交互相对简单。而异构链的跨链交互相对复杂，比如比特币采用PoW算法而联盟链Fabric采用传统确定性共识算法，其区块的组成形式和确定性保证机制均有很大不同，直接跨链交互机制不易设计。异构链之间的跨链交互一般需要第三方辅助服务辅助跨链交互。</p><h2 id="主流跨链机制概述"><a href="#主流跨链机制概述" class="headerlink" title="主流跨链机制概述"></a>主流跨链机制概述</h2><p>截至目前，主流的区块链跨链技术方案按照其具体的实现方式主要分为三大类，分别是公证人机制、侧链/中继和哈希锁定：</p><ol><li><strong>公证人机制（Notary schemes）</strong>: 公证人也称见证人机制，公证人机制本质上是一种中介的方式。具体而言，假设区块链A和B本身是不能直接进行互操作的，那么他们可以引入一个共同信任的第三方作为中介，由这个共同信任的中介进行跨链消息的验证和转发。公证人机制的优点在于能够灵活地支持各种不同结构的区块链（前提是公证人能够访问相关方的链上信息），缺点在于存在中心化风险。</li><li><strong>哈希锁定（Hash-locking</strong>）: 哈希锁定技术主要是支持跨链中的原子资产交换，最早起源自比特币的闪电网络。其典型实现是哈希时间锁定合约HTLC(Hashed TimeLock Contract)。哈希锁定的原理是通过时间差和影藏哈希值来达到资产的原子交换。哈希锁定只能做到交换而不能做到资产或者信息的转移，因此其使用场景有限。</li><li><strong>侧链/中继链（Sidechains / Relays）</strong>: 侧链是指完全拥有某链的功能的另一条区块链，侧链可以读取和验证主链上的信息。主链不知道侧链的存在，由侧链主动感知主链信息并进行相应的动作。而中继链则是侧链和公证人机制的结合体，中继链具有访问需要和验证进行互操作的链的关键信息并对两条链的跨链消息进行转移。从这个角度看中继链也是一种去中心的公证人机制。</li></ol><p>下面就这几种跨链方式的典型实现方式进行详细分析：</p><h2 id="典型跨链机制实现分析"><a href="#典型跨链机制实现分析" class="headerlink" title="典型跨链机制实现分析"></a>典型跨链机制实现分析</h2><h3 id="公证人机制"><a href="#公证人机制" class="headerlink" title="公证人机制"></a>公证人机制</h3><p>最传统的公证人机制是基于中心化交易所得跨链资产交换，这种跨链的方式比较单一，只支持资产的交换，如下图演示了Alice通过交易所，用比特币和Bob交换ETH的过程。 </p><p><img src="https://img.learnblockchain.cn/2019/15533141959843.jpg!wl" alt=""></p><ol><li>Alice 通过交易所钱包将自己的比特币打入交易所地址;</li><li>Alice 在交易所上挂上卖单1个BTC卖出20ETH价格；</li><li>Bob需要将自己的ETH打入交易所的以太坊地址；</li><li>Bob通过交易所挂出购买比特币的单子 20ETH买一个比特币；</li><li>交易所将Alice的卖单和Bob的卖单进行撮合；</li><li>交易所将Alice在交易所存储的1BTC 转移给Bob的比特币地址；</li><li>交易所将Bob在交易所存储的20ETH 转移给Alice的以太坊地址；</li></ol><p>至此完成了Alice和Bob的BTC和ETH的交换（案例中省去了交易所的服务费）。通过该例子可以看出交易所的方式目前仅能够支持资产的交换，且资产交换的原子性、安全性完全由中心化的交易所保障存在较大的中心化风险。</p><p><img src="https://img.learnblockchain.cn/2019/15533142153122.jpg!wl" alt=""></p><p>除此之外还有一种著名的分布式账本技术Ripple，也是采用类似公证人的机制来解决全球金融机构之间的资产交换。Ripple的系统架构如上图所示，Ripple系统中交易通过网络中的验证者进行交易的验证，验证者验证的交易通过加密算法保护交易内容不能被验证着窥探从而保证交易的隐私性。</p><p>公证人机制的跨链技术实现简单，且能够比较灵活地支持不同类型的底层区块链体系。公证人机制的主要问题在于公证人机制的安全性保障完全由公证人系统保障。参与跨链的相关方需要对中间人给予较大的信任。</p><h3 id="哈希锁定"><a href="#哈希锁定" class="headerlink" title="哈希锁定"></a>哈希锁定</h3><p>哈希时间锁定（HTLC）最早出现在比特币的闪电网络，跨链资产交换支持一定数量的A链资产和一定数量的B链资产进行原子交换。哈希时间锁定巧妙地采用了<a href="https://en.bitcoin.it/wiki/Hashlock" target="_blank" rel="noopener">哈希锁</a>和<a href="https://en.bitcoin.it/wiki/Timelock" target="_blank" rel="noopener">时间锁</a>，迫使资产的接收方在deadline内确定收款并产生一种收款证明给打款人，否则资产会归还给打款人。收款证明能够被付款人用来获取接收人区块链上的等量价值的数量资产或触发其他事件。</p><p>如下图所示，我们用一个例子来阐述如何使用哈希时间锁定进行跨链的原子资产交换，假设Alice和Bob有资产交换的需求，Alice想用1个BTC和Bob换20个ETH. 那么首先需要在两条链上设置哈希时间锁定合约，然后执行如下步骤：</p><p><img src="https://img.learnblockchain.cn/2019/15533142967423.jpg!wl" alt=""></p><ol><li>Alice 随机构建一个字符串s，并计算出其哈希 <code>h = hash(s)</code>；</li><li>Alice 将h发送给Bob的合约；</li><li>Alice锁定自己的1个BTC资产，并设置一个<code>较长</code>的锁定时间t1, 并设置了获取该BTC的一个条件：<code>谁能够提供h的原始值s就可以得到该BTC</code>;</li><li>Bob观察到Alice 合约中锁定了一个BTC, 然后Bob锁定自己的20个ETH资产，并设置一个<code>相对较短</code>的锁定时间t2, t2 &lt; t1, Bob也设置了同样获取条件（谁提供h的原始值s就可以获取20个ETH）；</li><li>Alice将自己最初生成的字符串s 发送到Bob的合约里取得了20个ETH;</li><li>Bob观察到步骤5中Alice的s值，将其发送给Alice的合约成功获取1个BTC; 至此Alice和Bob完成了资产的交换。</li></ol><p>从上述的过程我们可以看出哈希时间锁定合约有一些约束条件：</p><ul><li>进行跨链资产交换的双方必须能够解析双方的合约内部数据，例如s，例如锁定资产的证明等；</li><li>哈希锁定的超时时间设置时需要保证存在时间差，这样在单方面作弊时另一方可以及时撤回自己的资产。</li></ul><p>哈希锁定的思想运用在支付领域较多，例如<a href="https://lightning.network/" target="_blank" rel="noopener">闪电网络</a>、<a href="https://raiden.network/" target="_blank" rel="noopener">雷电网络</a>以及跨链资产转移协议<a href="https://interledger.org/" target="_blank" rel="noopener">Interledger</a>等。但是哈希锁定目前看只适合偏资产或者关键数据的交换，甚至不支持转移因此其试用场景受限。</p><h3 id="侧链-中继链"><a href="#侧链-中继链" class="headerlink" title="侧链/中继链"></a>侧链/中继链</h3><h4 id="侧链"><a href="#侧链" class="headerlink" title="侧链"></a>侧链</h4><p>侧链是相对于主链而言的，最初的侧链提出是针对比特币做新特性的测试和研发。侧链相对主链而言能够验证和解析主链中的区块数据和账本数据。侧链实现的基础技术是双向锚定（Two-way Peg），通过双向锚定技术可以将数字资产在主链上进行锁定，同时将等价的资产在侧链中释放。相反当侧链中相关资产进行锁定时，主链上锚定的等价资产也可以被释放。</p><p>BTC-Relay是号称的史上第一个侧链，BTC-Relay是通过以太坊构建了一个比特币的侧面，运用以太坊的智能合约允许用户验证比特币的交易。这里我们仍然以Alice 1BTC和Bob的20ETH数字资产交换为例阐述相应原理：</p><ol><li>Bob将20ETH发送到BTCSwap的合约进行冻结；(该合约只要能够确认BTC网络上Bob接收到来自Alice 1BTC就自动将20ETH转给Alice)</li><li>Alice 确认Bob冻结信息后，将1 BTC转给Bob比特币账户；</li><li>BTC Relayer将比特币区块头推送到BTCSwap合约；</li><li>Alice 接下来就可以调用relay tx;</li><li>BTCSwap合约结合tx和BTC链的区块链进行SPV验证，验证通过则将20ETH转给Alice以太坊地址。</li></ol><p><img src="https://img.learnblockchain.cn/2019/15533145100219.jpg!wl" alt=""></p><p>这种跨链的实现方式简单，但是BTC Relay需要额外的信任和维护成本，且智能合约内部的数据存储会有体积膨胀的问题。但是侧链的机制相对哈希锁定而言能够提供更多的跨链交互场景，侧链以及类SPV验证的思想适合所有跨链的场景。</p><h4 id="中继链"><a href="#中继链" class="headerlink" title="中继链"></a>中继链</h4><p>中继链本质上算是公证人机制和侧链机制的融合和扩展，目前社区内最活跃的两个跨链项目<code>Cosmos</code> 和 <code>Polkadot</code> 采用的都是基于中继链的多链多层架构，其中<code>Cosmos</code>目前支持的是跨链资产交互而<code>Polkadot</code>则宣称提供任意类型的跨链交互，具体实现还有待观察。</p><h5 id="Cosmos"><a href="#Cosmos" class="headerlink" title="Cosmos"></a>Cosmos</h5><p><strong>Cosmos</strong>网络是一个多链混合的区块链网格结构，如下图所示，该网络中主要包括两种角色：<br>Hub: 用于处理跨链交互的中继链；<br>Zone: Cosmos中的平行链， Cosmos中平行链需要具备两个前提条件： 1. 快速确定性（fast finality）, 这个特性由共识算法保障，也就是说Cosmos的跨链不直接支持PoW等概率确定模型的区块链； 2. 强监管性（Sovereignty)：每个平行链都具有一组验证者能够决定其出块。 </p><p><img src="https://img.learnblockchain.cn/2019/15533146074350.jpg!wl" alt=""></p><p>为了支持平行链之间的跨链互操作，Cosmos提出了一种跨链交互协议IBC(Inter-Blockchain Communication protocol), 并利用tendermint共识算法的即时确定性实现多个异构链之间的价值和数据传输。</p><p>首先我们以Chain A 到Chain B 转账10 token为例说明使用IBC的跨链交互： 1. 互相跟踪，也就是说如果A要和B进行跨链交易，那么A和B链需要分别运行相当于对方区块链的轻节点服务，这样互相可以实时接收到对方的区块头信息（方便后续执行类SPV验证）； 2. A链上初始化IBC协议，冻结相关资产10 token, 并生成相应的证明发送给B区块链； 3. B链接收到相应的IBC消息，通过A链的区块头信息确定A确实进行相应的资产冻结，然后B链会生成等价值10 token的资产。</p><p>以上是使用IBC协议的两个平行链直接进行跨链的基本过程，如果区块链很多，那么这种方式的两两跨链复杂度会呈现组合级别增加。因此Cosmos网络又引入了一种Hub的中继链，所有的平行链都通过IBC连接到Hub，让Hub辅助跨链交易的验证和转移，目前Cosmos实现了一个官方的Hub称为Cosmos Hub（如前图所示）。</p><p>如下图所示是Cosmos 网络的详细架构图，Cosmos为方便平行链开发提供了基本服务CosmosSDK包括：共识、网络以及IBC协议等，这样基于Cosmos SDK开发的子链之间都能够方便地互相交互。此外对于非Cosmos SDK 开发的区块链需要使用Peg Zone进行桥接，如图中的Ethereum。</p><p><img src="https://img.learnblockchain.cn/2019/15533146255840.jpg!wl" alt=""></p><p>笔者认为Cosmos为跨链带来的最大贡献在于IBC协议的设计，IBC协议提供了一种通用的跨链协议标准。IBC的设计使得跨链交易可以在多个Hub之间进行安全路由和转发，类似目前互联网的TCP/IP 协议。但是遗憾的是目前的Cosmos设计也只能够支持资产的跨链，而且由于不同区块链的业务不同其共识速率的不一致也会影响跨链交易有效性的证明。</p><h5 id="Polkadot"><a href="#Polkadot" class="headerlink" title="Polkadot"></a>Polkadot</h5><p>Polkadot也是一种集成平行链和中继链的多层多链架构，Polkadot区块链的整体架构图如下图所示，主要包含三种角色链和四种参与方：</p><p><img src="https://img.learnblockchain.cn/2019/15533146731752.jpg!wl" alt=""></p><p>三种链角色：</p><ol><li>中继链（Relay chain）: 中继链位于Polkadot的体系的核心地位，主要是为整个系统提供统一的共识和安全性保障；</li><li>平行链（Parachain）: 在Polkadot中平行链负责具体的业务场景，平行链自身不具备区块的共识，它们将共识的职责渡让给了中继链，所有平行链共享来自中继链的安全保障，中继链是Polkadot组成的一部分；</li><li>桥接链：桥接链指的是非Polkadot体系之外的区块链，如Bitcoin, Ethereum， 这些区块链有自身的共识算法，它们通过不同的Bridge与Polkadot连接在一起进行跨链交互。</li></ol><p>四种参与方：</p><ol><li>验证者(Validator): 验证者负责Polkadot的网络出块，会运行一个中继链的客户端，在每一轮区块产生中会对其提名的平行链出的块进行核验。当平行链的跨都被他们的子验证者集合确定好之后，验证者们会将所有平行链区块头组装到中继链的区块并进行共识。</li><li>核验人(Collator): 帮助验证者收集、验证和提交备选平行链区块，维护了一个平行链的全节点。</li><li>钓鱼人(Fisherman):钓鱼人主要靠检举非法交易或者区块以获取收益；</li><li>提名人(Nominator): 拥有stake的相关方，维护和负责验证者的安全性。</li></ol><p>Polkadot的特性包括两个，一个是共享安全性，一个是不需信任的跨链交互。这里的不需信任的跨链交互其实是和第一个特点共享安全性密切相关的，而且Polkadot的不需信任的跨链交互也主要是只其内部的平行链之间。</p><p>在Polkadot中如果parachain A 需要发送一笔交易到parachain B的过程如下：</p><ol><li>A链将跨链交易放到自己的engress(每个平行链有一个消息输出队列engress 和一个消息输入队列ingress);</li><li>A链的Collator收集A链的普通交易以及跨链交易并提交给A链的验证者集合；</li><li>A链的验证者集合验证成功，将本次A链的区块头信息以及A链的engress内信息提交到中继链上；</li><li>中继链运行共识算法进行区块确认以及跨链交易路由，中继链上的验证者会将A链的相应交易从A链的engress queue中移动到B链的ingress queue中。</li><li>B链执行区块，将ingress queue中相应交易执行并修改自身账本。</li></ol><p>以上便是Polkadot跨链交易的主要步骤，由于所有平行链的共识同步发生（中继链区块示意图如下），因此跨链交易不会有诸如双花等安全性问题。</p><p><img src="https://img.learnblockchain.cn/2019/15533147383944.jpg!wl" alt=""></p><p>Polkadot 的平行链之间的跨链交换的安全性保障主要来自共享安全性这个特点，共享安全性使得跨链交易和普通交易同步发生也就不存在其他跨链场景中的双花等跨链数据不一致问题。其次Polkadot中的引入的特殊状态验证方法方便中继链进行跨链等消息的有效性验证。</p><p>值得一提的是Polkadot项目目前还处在项目初期，对于parachain的设计、Collator的协作以及Validator的共识、工作效率等都未完善。这种共享安全性的方式是否也限制了平行链自身的性能都还有待考证。</p><h2 id="关于跨链技术的几点思考"><a href="#关于跨链技术的几点思考" class="headerlink" title="关于跨链技术的几点思考"></a>关于跨链技术的几点思考</h2><p>综合以上的一些主流跨链场景和方案的分析，从跨链的概念以及需求上看跨链的本质其实就是 <code>如何将A链上的消息M安全可信地转移到B链并在B链上产生预期效果</code>。那么一个成功的跨链交互到底需要解决哪些问题呢？笔者认为主要有以下四个问题：</p><ol><li>消息M的真实性证明，也就是说M是否确实是存在A链上的，也确实是A链发给B链的；</li><li>消息M的路由，如何让跨链消息安全跨系统路由；</li><li>消息M的有效性证明，这里的有效性是指来自A链的消息M如何让B链认可其抵达B链时状态仍然有效，比如转移的资产是否是冻结的，没有双花的，如果是状态那么是否在此期间未发生改变等；</li><li>消息M的执行结果证明，这个是指A链需要确认跨链操作是否成功，以及成功操作的相应回执。</li></ol><p>那么针对这些关键本质问题，如何去处理呢？笔者设想未来的区块链应该在底层平台的设计之初就需要遵循统一的跨链协议标准，就像现在的操作系统对TCP/IP协议的支持一样。需要进行通用跨链的区块链至少要支持一下功能：</p><ol><li>提供跨链消息的输入和输出口径，例如Cosmos和Polkadot的跨链队列；</li><li>提供跨链消息的真实性证明，区块链需要提供类似SPV的证明手段；</li><li>消息的有效路由需要构建跨链消息的统一格式，定义好消息的来源和去处以及消息内容，如Cosmos的IBC协议；</li><li><p>消息的有效性证明，区块链可能需要设计新的类似UTXO的可验证存储结构，方便做类SPV类验证，否则目前的基于KV的数据存储方式做有效性证明几乎不可能；</p></li><li><p>跨链执行结果证明，和有效性证明类似，需要全新的数据结构和运行算法支持。</p></li></ol><p>除此之外，跨链系统的设计还需要考虑系统稳定性、可扩展性以及易升级性、容错等等，总而言之，真正的可信互联网建设艰辛蛮长，诸君共勉！</p><p>本文经作者授权转自<a href="http://bitking.wang/2019/03/21/blockchain-interoperability.html" target="_blank" rel="noopener">BITKING</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当前的区块链底层技术平台百花齐放，不同的业务、不同的技术底层的区块链之间缺乏统一的互联互通的机制，这极大限制了区块链技术和应用生态的健康发展。跨链的需求由此而来，本文通过分析几种主流的跨链方案探讨跨链技术的本质及相应的解决思路。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="跨链" scheme="https://learnblockchain.cn/categories/cross-chain/"/>
    
    
      <category term="侧链" scheme="https://learnblockchain.cn/tags/%E4%BE%A7%E9%93%BE/"/>
    
      <category term="中继链" scheme="https://learnblockchain.cn/tags/%E4%B8%AD%E7%BB%A7%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>寻找一种易于理解的一致性算法（扩展版）</title>
    <link href="https://learnblockchain.cn/2019/03/22/easy_raft/"/>
    <id>https://learnblockchain.cn/2019/03/22/easy_raft/</id>
    <published>2019-03-22T13:27:59.000Z</published>
    <updated>2019-04-05T10:29:30.991Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong></p><p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。</p><a id="more"></a><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的 10 年里，Paxos  算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。同时 Paxos 也成为了教学领域里讲解一致性问题时的示例。</p><p>但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是 Paxos 算法依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。这些都导致了工业界和学术界都对 Paxos 算法感到十分头疼。</p><p>和 Paxos 算法进行过努力之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。我们的做法是不寻常的，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且能够比 Paxos 算法以一种更加容易的方式来学习。此外，我们希望该算法方便系统构建者的直觉的发展。不仅一个算法能够工作很重要，而且能够显而易见的知道为什么能工作也很重要。</p><p>Raft 一致性算法就是这些工作的结果。在设计 Raft 算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。一份针对两所大学 43 个学生的研究表明 Raft 明显比 Paxos 算法更加容易理解。在这些学生同时学习了这两种算法之后，和 Paxos 比起来，其中 33 个学生能够回答有关于 Raft 的问题。</p><p>Raft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：</p><ul><li><strong>强领导者</strong>：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。</li><li><strong>领导选举</strong>：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。</li><li><strong>成员关系调整</strong>：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li></ul><p>我们相信，Raft 算法不论出于教学目的还是作为实践项目的基础都是要比 Paxos 或者其他一致性算法要优异的。它比其他算法更加简单，更加容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全性已经被证明；它的效率和其他算法比起来也不相上下。</p><p>接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论 Paxos 的优点和缺点（第 3 节），讨论我们为了可理解性而采取的方法（第 4 节），阐述 Raft 一致性算法（第 5-8 节），评价 Raft 算法（第 9 节），以及一些相关的工作（第 10 节）。</p><h2 id="2-复制状态机"><a href="#2-复制状态机" class="headerlink" title="2 复制状态机"></a>2 复制状态机</h2><p>一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导者，像 GFS、HDFS 和 RAMCloud，典型应用就是一个独立的的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。</p><p><img src="https://img.learnblockchain.cn/2019/raft-1.png!wl" alt="图 1 "></p><blockquote><p>图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</p></blockquote><p>复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p><p>保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。</p><p>实际系统中使用的一致性算法通常含有以下特性：</p><ul><li>安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。</li><li>可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。</li><li>不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li><li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</li></ul><h2 id="3-Paxos-算法的问题"><a href="#3-Paxos-算法的问题" class="headerlink" title="3 Paxos 算法的问题"></a>3 Paxos 算法的问题</h2><p>在过去的 10 年里，Leslie Lamport 的 Paxos 算法几乎已经成为一致性的代名词：Paxos 是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进一系列决策的达成。Paxos 保证安全性和活性，同时也支持集群成员关系的变更。Paxos 的正确性已经被证明，在通常情况下也很高效。</p><p>不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释 Paxos 的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在 2012 年 NSDI 的会议中的一次调查显示，很少有人对 Paxos 算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解 Paxos；我们一直没能理解 Paxos 直到我们读了很多对 Paxos 的简化解释并且设计了我们自己的算法之后，这一过程花了近一年时间。</p><p>我们假设 Paxos 的不透明性来自它选择单决策问题作为它的基础。单决策 Paxos 是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策 Paxos 算法能够工作。构成多决策 Paxos 增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。</p><p>Paxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛认同的多决策问题的算法。Lamport 的描述基本上都是关于单决策 Paxos 的；他简要描述了实施多决策 Paxos 的方法，但是缺乏很多细节。当然也有很多具体化 Paxos 的尝试，但是他们都互相不一样，和 Paxos 的概述也不同。例如 Chubby 这样的系统实现了一个类似于 Paxos 的算法，但是大多数的细节并没有被公开。</p><p>而且，Paxos 算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立的选择一组日志条目然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志条目以严格限制的顺序增添到日志中去。另一个问题是，Paxos 使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。</p><p>因此，实际的系统中很少有和 Paxos 相似的实践。每一种实现都是从 Paxos 开始研究，然后发现很多实现上的难题，再然后开发了一种和 Paxos 明显不一样的结构。这样是非常费时和容易出错的，并且理解 Paxos 的难度使得这个问题更加糟糕。Paxos 算法在理论上被证明是正确可行的，但是现实的系统和 Paxos 差别是如此的大，以至于这些证明没有什么太大的价值。下面来自 Chubby 实现非常典型：</p><blockquote><p>在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。</p></blockquote><p>由于以上问题，我们认为 Paxos 算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代 Paxos 的一致性算法。Raft算法就是这次实验的结果。</p><h2 id="4-为了可理解性的设计"><a href="#4-为了可理解性的设计" class="headerlink" title="4 为了可理解性的设计"></a>4 为了可理解性的设计</h2><p>设计 Raft 算法我们有几个初衷：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。</p><p>在设计 Raft 算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft 的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？</p><p>我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的问题分解：只要有可能，我们就将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成领导人选举，日志复制，安全性和角色改变几个部分。</p><p>我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了日志之间变成不一致状态的可能。尽管在大多数情况下我们都试图去消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化去简化 Raft 中领导人选举算法。</p><h2 id="5-Raft-一致性算法"><a href="#5-Raft-一致性算法" class="headerlink" title="5 Raft 一致性算法"></a>5 Raft 一致性算法</h2><p>Raft 是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考之用，总结这个算法的简略版本，图 3 列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。</p><p>Raft 通过选举一个高贵的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可以宕机，可以和其他服务器失去连接，这时一个新的领导人会被选举出来。</p><p>通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：</p><ul><li><strong>领导选举</strong>：一个新的领导人需要被选举出来，当现存的领导人宕机的时候（章节 5.2）</li><li><strong>日志复制</strong>：领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。</li><li><strong>安全性</strong>：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到一个额外的选举机制（5.2 节）上的限制。</li></ul><p>在展示一致性算法之后，这一章节会讨论可用性的一些问题和计时在系统的作用。</p><p><strong>状态</strong>：</p><table><thead><tr><th>状态</th><th>所有服务器上持久存在的</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器最后一次知道的任期号（初始化为 0，持续递增）</td></tr><tr><td>votedFor</td><td>在当前获得选票的候选人的 Id</td></tr><tr><td>log[]</td><td>日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号</td></tr></tbody></table><table><thead><tr><th>状态</th><th>所有服务器上经常变的</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知的最大的已经被提交的日志条目的索引值</td></tr><tr><td>lastApplied</td><td>最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）</td></tr></tbody></table><table><thead><tr><th>状态</th><th>在领导人里经常改变的 （选举后重新初始化）</th></tr></thead><tbody><tr><td>nextIndex[]</td><td>对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一）</td></tr><tr><td>matchIndex[]</td><td>对于每一个服务器，已经复制给他的日志的最高索引值</td></tr></tbody></table><p><strong>附加日志 RPC</strong>：</p><p>由领导人负责调用来复制日志指令；也会用作heartbeat</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的 Id，以便于跟随者重定向请求</td></tr><tr><td>prevLogIndex</td><td>新的日志条目紧随之前的索引值</td></tr><tr><td>prevLogTerm</td><td>prevLogIndex 条目的任期号</td></tr><tr><td>entries[]</td><td>准备存储的日志条目（表示心跳时为空；一次性发送多个是为了提高效率）</td></tr><tr><td>leaderCommit</td><td>领导人已经提交的日志的索引值</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前的任期号，用于领导人去更新自己</td></tr><tr><td>success</td><td>跟随者包含了匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</td></tr></tbody></table><p>接收者实现：</p><ol><li>如果 <code>term &lt; currentTerm</code> 就返回 false （5.1 节）</li><li>如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配，则返回 false （5.3 节）</li><li>如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一条和之后所有的 （5.3 节）</li><li>附加日志中尚未存在的任何新条目</li><li>如果 <code>leaderCommit &gt; commitIndex</code>，令 commitIndex 等于 leaderCommit 和 新日志条目索引值中较小的一个</li></ol><p><strong>请求投票 RPC</strong>：</p><p>由候选人负责调用用来征集选票（5.2 节）</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>候选人的任期号</td></tr><tr><td>candidateId</td><td>请求选票的候选人的 Id</td></tr><tr><td>lastLogIndex</td><td>候选人的最后日志条目的索引值</td></tr><tr><td>lastLogTerm</td><td>候选人最后日志条目的任期号</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号，以便于候选人去更新自己的任期号</td></tr><tr><td>voteGranted</td><td>候选人赢得了此张选票时为真</td></tr></tbody></table><p>接收者实现：</p><ol><li>如果<code>term &lt; currentTerm</code>返回 false （5.2 节）</li><li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节）</li></ol><p><strong>所有服务器需遵守的规则</strong>：</p><p>所有服务器：</p><ul><li>如果<code>commitIndex &gt; lastApplied</code>，那么就 lastApplied 加一，并把<code>log[lastApplied]</code>应用到状态机中（5.3 节）</li><li>如果接收到的 RPC 请求或响应中，任期号<code>T &gt; currentTerm</code>，那么就令 currentTerm 等于 T，并切换状态为跟随者（5.1 节）</li></ul><p>跟随者（5.2 节）：</p><ul><li>响应来自候选人和领导者的请求</li><li>如果在超过选举超时时间的情况之前都没有收到领导人的心跳，或者是候选人请求投票的，就自己变成候选人</li></ul><p>候选人（5.2 节）：</p><ul><li>在转变成候选人后就立即开始选举过程<ul><li>自增当前的任期号（currentTerm）</li><li>给自己投票</li><li>重置选举超时计时器</li><li>发送请求投票的 RPC 给其他所有服务器</li></ul></li><li>如果接收到大多数服务器的选票，那么就变成领导人</li><li>如果接收到来自新的领导人的附加日志 RPC，转变成跟随者</li><li>如果选举过程超时，再次发起一轮选举</li></ul><p>领导人：</p><ul><li>一旦成为领导人：发送空的附加日志 RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以阻止跟随者超时（5.2 节）</li><li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）</li><li>如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex，那么：发送从 nextIndex 开始的所有日志条目：<ul><li>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</li><li>如果因为日志不一致而失败，减少 nextIndex 重试</li></ul></li><li>如果存在一个满足<code>N &gt; commitIndex</code>的 N，并且大多数的<code>matchIndex[i] ≥ N</code>成立，并且<code>log[N].term == currentTerm</code>成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）</li></ul><p><img src="https://img.learnblockchain.cn/2019/raft-2.png!wl" alt="图 2 "></p><blockquote><p>图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。</p></blockquote><table><thead><tr><th>特性</th><th>解释</th></tr></thead><tbody><tr><td>选举安全特性</td><td>对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）</td></tr><tr><td>领导人只附加原则</td><td>领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）</td></tr><tr><td>日志匹配原则</td><td>如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同（5.3 节）</td></tr><tr><td>领导人完全特性</td><td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</td></tr><tr><td>状态机安全特性</td><td>如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志（5.4.3 节）</td></tr></tbody></table><p><img src="https://img.learnblockchain.cn/2019/raft-3.png!wl" alt="图 3 "></p><blockquote><p>图 3：Raft 在任何时候都保证以上的各个特性。</p></blockquote><h3 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h3><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导者或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。</p><p><img src="https://img.learnblockchain.cn/2019/raft-4.png!wl" alt="图 4 "></p><blockquote><p>图 4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导者。在一个任期内，领导人一直都会是领导人直到自己宕机了。</p></blockquote><p><img src="https://img.learnblockchain.cn/2019/raft-5.png!wl" alt="图 5"></p><blockquote><p>图 5：时间被划分成一个个的任期，每个任期开始都是一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。</p></blockquote><p>Raft 把时间分割成任意长度的<strong>任期</strong>，如图 5。任期用连续的整数标记。每一段任期从一次<strong>选举</strong>开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导者。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。</p><p>不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者。每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</p><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节  5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。</p><h3 id="5-2-领导人选举"><a href="#5-2-领导人选举" class="headerlink" title="5.2 领导人选举"></a>5.2 领导人选举</h3><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。一个服务器节点继续保持着跟随者状态只要他从领导人或者候选者处接收到有效的 RPCs。领导者周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加日志项 RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是<strong>选举超时</strong>，那么他就会认为系统中没有可用的领导者,并且发起选举以选出新的领导者。</p><p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导者，(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。</p><p>当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。</p><p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项 RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。</p><p>第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p><p>Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。</p><p>领导人选举这个例子，体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。</p><h3 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3 日志复制"></a>5.3 日志复制</h3><p>一旦一个领导人被选举出来，他就开始为客户端提供服务。客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全的复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。</p><p><img src="https://img.learnblockchain.cn/2019/raft-6.png!wl" alt="图 6"></p><blockquote><p>图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。</p></blockquote><p>日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。</p><p>领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为<strong>已提交</strong>。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。</p><p>我们设计了 Raft 的日志机制来维护一个不同服务器的日志之间的高层次的一致性。这么做不仅简化了系统的行为也使得更加可预计，同时他也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些同时也组成了图 3 中的日志匹配特性：</p><ul><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。</li></ul><p>第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查保护了日志匹配特性当日志扩展的时候。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。</p><p>在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同的方式。跟随者可能会丢失一些在新的领导人中有的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。</p><p><img src="https://img.learnblockchain.cn/2019/raft-7.png!wl" alt="图 7"></p><blockquote><p>图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p></blockquote><p>在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。</p><p>要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 <strong>nextIndex</strong>，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的index加1（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。</p><p>如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息，领导人可以减小 nextIndex 越过所有那个任期冲突的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。</p><p>通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。</p><p>日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的跟随者不会影响整体的性能。</p><h3 id="5-4-安全性"><a href="#5-4-安全性" class="headerlink" title="5.4 安全性"></a>5.4 安全性</h3><p>前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p><p>这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于领导人完整特性的简要证明，并且说明领导人是如何领导复制状态机的做出正确行为的。</p><h4 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h4><p>在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导者。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的领导人中，不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。</p><p>Raft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。</p><p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p><h4 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h4><p>如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p><p><img src="https://img.learnblockchain.cn/2019/raft-8.png!wl" alt="图 8"></p><blockquote><p>图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</p></blockquote><p>为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。</p><p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。</p><h4 id="5-4-3-安全性论证"><a href="#5-4-3-安全性论证" class="headerlink" title="5.4.3 安全性论证"></a>5.4.3 安全性论证</h4><p>在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p><p><img src="https://img.learnblockchain.cn/2019/raft-9.png!wl" alt="图 9"></p><blockquote><p>图 9：如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p></blockquote><ol><li>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</li><li>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，如图 9。这个投票者是产生这个矛盾的关键。</li><li>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</li><li>投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。</li><li>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</li><li>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</li><li>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。</li><li>这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。</li><li>日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (d) 中的索引 2。</li></ol><p>通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，即如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p><p>最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。</p><h3 id="5-5-跟随者和候选人崩溃"><a href="#5-5-跟随者和候选人崩溃" class="headerlink" title="5.5 跟随者和候选人崩溃"></a>5.5 跟随者和候选人崩溃</h3><p>到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单的通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。</p><h3 id="5-6-时间和可用性"><a href="#5-6-时间和可用性" class="headerlink" title="5.6 时间和可用性"></a>5.6 时间和可用性</h3><p>Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。</p><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p><blockquote><p>广播时间（broadcastTime）  &lt;&lt;  选举超时时间（electionTimeout） &lt;&lt;  平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。</p><h2 id="6-集群成员变化"><a href="#6-集群成员变化" class="headerlink" title="6 集群成员变化"></a>6 集群成员变化</h2><p>到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定自动化配置改变并且将其纳入到 Raft 一致性算法中来。</p><p>为了让配置修改机制能够安全，那么在转换的过程中不能够存在任何时间点使得两个领导人同时被选举成功在同一个任期里。不幸的是，任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性自动的转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性（见图 10）。</p><p><img src="https://img.learnblockchain.cn/2019/raft-10.png!wl" alt="图 10"></p><blockquote><p>图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</p></blockquote><p>为了保证安全性，配置更改必须使用两阶段方法。目前有很多种两阶段的实现。例如，有些系统在第一阶段停掉旧的配置所以集群就不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合：</p><ul><li>日志条目被复制给集群中新、老配置的所有服务器。</li><li>新、旧配置的服务器都可以成为领导人。</li><li>达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。</li></ul><p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程人依然响应客户端的请求。</p><p>集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置转换的过程。当一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论他是否已经被提交）。这意味着领导人要使用  C-old,new 的规则来决定日志条目 C-old,new 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C-old 配置也可能是 C-old,new 配置，这取决于赢得选举的候选人是否已经接收到了 C-old,new 配置。在任何情况下， C-new 配置在这一时期都不会单方面的做出决定。</p><p>一旦 C-old,new 被提交，那么无论是 C-old 还是 C-new，在没有经过他人批准的情况下都不可能做出决定，并且领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C-new 配置的日志条目并复制给集群就是安全的了。再者，每个服务器在见到新的配置的时候就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新的配置的服务器就可以被关闭了。如图 11，C-old 和 C-new 没有任何机会同时做出单方面的决定；这保证了安全性。</p><p><img src="https://img.learnblockchain.cn/2019/raft-11.png!wl" alt="图 11"></p><blockquote><p>图 11：一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的条目，实线表示最后被提交的日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old 的大多数和  C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在  C-new 和 C-old 可以同时做出决定的时间点。</p></blockquote><p>在关于重新配置还有三个问题需要提出。第一个问题是，新的服务器可能初始化没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，那么他们需要一段时间来更新追赶，这时还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新的时候使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来（领导人复制日志给他们，但是不考虑他们是大多数）。一旦新的服务器追赶上了集群中的其他机器，重新配置可以像上面描述的一样处理。</p><p>第二个问题是，集群的领导人可能不是新配置的一员。在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括他自己；他复制日志但是不把他自己算作是大多数之一。当 C-new 被提交时，会发生领导人过渡，因为这时是最早新的配置可以独立工作的时间点（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。</p><p>第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，他们就会进行新的选举过程。他们会发送拥有新的任期号的请求投票 RPCs，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。</p><p>为了避免这个问题，当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。特别的，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么他就不会被更大的任期号废黜。</p><h2 id="7-日志压缩"><a href="#7-日志压缩" class="headerlink" title="7 日志压缩"></a>7 日志压缩</h2><p>Raft 的日志在正常操作中不断的增长，但是在实际的系统中，日志不能无限制的增长。随着日志不断增长，他会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。</p><p>快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。</p><p>增量压缩的方法，例如日志清理或者日志结构合并树，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。和简单操作整个数据集合的快照相比，需要增加复杂的机制来实现。状态机可以实现 LSM tree 使用和快照相同的接口，但是日志清除方法就需要修改 Raft 了。</p><p><img src="https://img.learnblockchain.cn/2019/raft-12.png!wl" alt="图 12"></p><blockquote><p>图 12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。</p></blockquote><p>图 12 展示了 Raft 中快照的基础思想。每个服务器独立的创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：<strong>最后被包含索引</strong>指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），<strong>最后被包含的任期</strong>指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。</p><p>尽管通常服务器都是独立的创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。</p><p><strong>安装快照 RPC</strong>：</p><p>由领导人调用以将快照的分块发送给跟随者。领导者总是按顺序发送分块。</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的 Id，以便于跟随者重定向请求</td></tr><tr><td>lastIncludedIndex</td><td>快照中包含的最后日志条目的索引值</td></tr><tr><td>lastIncludedTerm</td><td>快照中包含的最后日志条目的任期号</td></tr><tr><td>offset</td><td>分块在快照中的字节偏移量</td></tr><tr><td>data[]</td><td>原始数据</td></tr><tr><td>done</td><td>如果这是最后一个分块则为 true</td></tr></tbody></table><table><thead><tr><th>结果</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号（currentTerm），便于领导人更新自己</td></tr></tbody></table><p><strong>接收者实现</strong>：</p><ol><li>如果<code>term &lt; currentTerm</code>就立即回复</li><li>如果是第一个分块（offset 为 0）就创建一个新的快照</li><li>在指定偏移量写入数据</li><li>如果 done 是 false，则继续等待更多的数据</li><li>保存快照文件，丢弃具有较小索引的任何现有或部分快照</li><li>如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复</li><li>丢弃整个日志</li><li>使用快照重置状态机（并加载快照的集群配置）</li></ol><p><img src="https://img.learnblockchain.cn/2019/raft-13.png!wl" alt="图 13 "></p><blockquote><p>图 13：一个关于安装快照的简要概述。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生命的迹象，所以跟随者可以重置选举超时计时器。</p></blockquote><p>在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种  RPC 接收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者丢弃其整个日志；它全部被快照取代，并且可能包含与快照冲突的未提交条目。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照后面的条目仍然有效，必须保留。</p><p>这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。</p><p>我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。</p><p>还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。</p><p>第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。</p><h2 id="8-客户端交互"><a href="#8-客户端交互" class="headerlink" title="8 客户端交互"></a>8 客户端交互</h2><p>这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p><p>Raft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。</p><p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可以执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p><p>只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为领导人响应客户端请求时可能已经被新的领导人作废了，但是他还不知道。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道那些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。</p><h2 id="9-算法实现和评估"><a href="#9-算法实现和评估" class="headerlink" title="9 算法实现和评估"></a>9 算法实现和评估</h2><p>我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。</p><p>这一节会从三个方面来评估 Raft 算法：可理解性、正确性和性能。</p><h3 id="9-1-可理解性"><a href="#9-1-可理解性" class="headerlink" title="9.1 可理解性"></a>9.1 可理解性</h3><p>为了和 Paxos 比较 Raft 算法的可理解能力，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文的所有内容除了日志压缩；Paxos 讲课包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如领导人选举）。小测验测试一些对算法的基本理解和解释一些边角的示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者从第一部分的算法学习中获得的表现和经验的差异。我们计算参加人员的每一个小测验的得分来看参与者是否在 Raft 算法上更加容易理解。</p><p>我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些  Paxos 的经验，并且 Paxos 的视频要长 14%。如表格 1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。</p><table><thead><tr><th>关心</th><th>缓和偏见采取的手段</th><th>可供查看的材料</th></tr></thead><tbody><tr><td>相同的讲课质量</td><td>两者使用同一个讲师。Paxos 使用的是现在很多大学里经常使用的。Paxos 会长 14%。</td><td>视频</td></tr><tr><td>相同的测验难度</td><td>问题以难度分组，在两个测验里成对出现。</td><td>小测验</td></tr><tr><td>公平评分</td><td>使用评价量规。随机顺序打分，两个测验交替进行。</td><td>评价量规（rubric）</td></tr></tbody></table><blockquote><p>表 1：考虑到可能会存在的偏见，对于每种情况的解决方法，和相应的材料。</p></blockquote><p>参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图 14 展示了每个参与者的得分。配置t-检验（又称student‘s t-test）表明，在 95% 的可信度下，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。</p><p><img src="https://img.learnblockchain.cn/2019/raft-14.png!wl" alt="图 14"></p><blockquote><p>图 14：一个散点图表示了 43 个学生在 Paxos 和 Raft 的小测验中的成绩。在对角线之上的点表示在 Raft 获得了更高分数的学生。</p></blockquote><p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型预测，对小测验的选择会产生 12.5 分的差别。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft的得分低了6.3分; 虽然我们不知道为什么，这似乎在统计上是有意义的。</p><p>我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图 15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。</p><p><img src="https://img.learnblockchain.cn/2019/raft-15.png!wl" alt="图 15"></p><blockquote><p>图 15：通过一个 5 分制的问题，参与者（左边）被问哪个算法他们觉得在一个高效正确的系统里更容易实现，右边被问哪个更容易向学生解释。</p></blockquote><p>关于 Raft 用户学习有一个更加详细的讨论。</p><h3 id="9-2-正确性"><a href="#9-2-正确性" class="headerlink" title="9.2 正确性"></a>9.2 正确性</h3><p>在第 5 节，我们已经制定了正式的规范，和对一致性机制的安全性证明。这个正式规范使用 TLA+ 规范语言使图 2 中总结的信息非常清晰。它长约400行，并作为证明的主题。同时对于任何想实现 Raft 的人也是十分有用的。我们通过 TLA 证明系统非常机械的证明了日志完全特性。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范的类型安全）。而且，我们已经写了一个非正式的证明关于状态机安全性是完备的，并且是相当清晰的（大约 3500 个词）。</p><h3 id="9-3-性能"><a href="#9-3-性能" class="headerlink" title="9.3 性能"></a>9.3 性能</h3><p>Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当领导人被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从领导人到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。</p><p>我们使用我们自己的 Raft 实现来衡量 Raft 领导人选举的性能并且回答两个问题。首先，领导人选举的过程收敛是否快速？第二，在领导人宕机之后，最小的系统宕机时间是多久？</p><p><img src="https://img.learnblockchain.cn/2019/raft-16.png!wl" alt="图 16"></p><blockquote><p>图 16：发现并替换一个已经崩溃的领导人的时间。上面的图考察了在选举超时时间上的随机化程度，下面的图考察了最小选举超时时间。每条线代表了 1000 次实验（除了 150-150 毫秒只试了 100 次），和相应的确定的选举超时时间。例如，150-155 毫秒意思是，选举超时时间从这个区间范围内随机选择并确定下来。这个实验在一个拥有 5 个节点的集群上进行，其广播时延大约是 15 毫秒。对于 9 个节点的集群，结果也差不多。</p></blockquote><p>为了衡量领导人选举，我们反复的使一个拥有五个节点的服务器集群的领导人宕机，并计算需要多久才能发现领导人已经宕机并选出一个新的领导人（见图 16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些候选人是没有成为领导人的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止领导人之前同步的发送了一次心跳广播（这大约和领导人在崩溃前复制一个新的日志给其他机器很像）。领导人均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。</p><p>图 16 中上面的图表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程往往都需要花费超过 10 秒钟由于太多的选票瓜分的情况。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。</p><p>图 16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性。</p><h2 id="10-相关工作"><a href="#10-相关工作" class="headerlink" title="10 相关工作"></a>10 相关工作</h2><p>已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：</p><ul><li>Lamport 关于 Paxos 的原始描述，和尝试描述的更清晰。</li><li>关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。</li><li>实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 着实有着很大的差别。</li><li>Paxos 可以应用的性能优化。</li><li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于领导人的方法，和 Raft 有很多相似之处。</li></ul><p>Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft 就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。</p><p>像 Raft 一样，VR 和 ZooKeeper 也是基于领导人的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。</p><p>和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 中不同的消息类型，相对的，Raft 只有 4 中消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。</p><p>Raft 的强领导人模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。</p><p>一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致的方法因为他对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Lamport 的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有领导人的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较的，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。Raft 的方法同时也需要更少的额外机制来实现，和 VR、SMART 比较而言。</p><h2 id="11-结论"><a href="#11-结论" class="headerlink" title="11 结论"></a>11 结论</h2><p>算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。</p><p>在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；随着设计的进展，我们发现自己重复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。</p><h2 id="12-感谢"><a href="#12-感谢" class="headerlink" title="12 感谢"></a>12 感谢</h2><p>这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie`res，和伯克利 CS 294-91 课程、斯坦福 CS 240 课程的学生。Scott Klemmer 帮我们设计了用户调查，Nelson Ray 建议我们进行统计学的分析。在用户调查时使用的关于 Paxos 的幻灯片很大一部分是从 Lorenzo Alvisi 的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 Ezra Hoch，他们找到了 Raft 中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括 Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，Arjun Gopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，Aleksandar Kracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，David Ramos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，Deian Stefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，Matei Zaharia 以及 24 位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 Eddie Kohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft 带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale 系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由 STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA 支持，在国家科学基金会的 0963859 号批准，并且获得了来自 Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。Diego Ongaro 由 Junglee 公司，斯坦福的毕业团体支持。</p><p>本文经TopJohn授权转自<a href="https://www.xuanzhangjiong.top" target="_blank" rel="noopener">TopJohn’s Blog</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。&lt;/p&gt;
    
    </summary>
    
      <category term="共识" scheme="https://learnblockchain.cn/categories/%E5%85%B1%E8%AF%86/"/>
    
    
      <category term="一致性算法" scheme="https://learnblockchain.cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>理解去中心化 稳定币 DAI</title>
    <link href="https://learnblockchain.cn/2019/03/19/understand_dai/"/>
    <id>https://learnblockchain.cn/2019/03/19/understand_dai/</id>
    <published>2019-03-19T12:44:58.000Z</published>
    <updated>2019-04-05T10:29:31.022Z</updated>
    
    <content type="html"><![CDATA[<p>随着摩根大通推出JPM Coin 稳定币，可以预见稳定币将成为区块链落地的一大助推器。<br>坦白来讲，对于一个程序员的我来讲（不懂一点专业经济和金融），理解DAI的机制，真的有一点复杂。耐心看完，必有收获。</p><a id="more"></a><h2 id="为什么需要稳定币"><a href="#为什么需要稳定币" class="headerlink" title="为什么需要稳定币"></a>为什么需要稳定币</h2><p>如果一个货币其价值时刻在剧烈波动，就无法作为一个日常支付和交易的货币，谁也无法承担今天发的工资，第二天就跌掉了三分之一。</p><p>在币价高度不稳定时，在不退出加密货币市场的情况下，稳定币就可以提供价值保值。</p><p>通常发行稳定币的方式是通过资产担保来发行，像USDT、TUSD等就是通过美元资产来担保发行等额稳定币，如银行存款1亿美元就发行1亿USDT， 既通过锚定法币来实行稳定性。</p><blockquote><p>USDT 因审计不公开，经常被质疑超发，如1亿美元担保发行1.5亿USDT，就会导致0.5亿USDT无法兑换美元。这也是为什么在监管下发行的稳定币，如TUSD、GUSD有逐步取代USDT的趋势。</p></blockquote><p>本文的主角 DAI 同样是通过<strong>资产抵押</strong>发行， DAI 是通过<strong>抵押数字资产</strong>发行，<strong>去中心化</strong>发行。</p><p>注意加粗的两个关键字<strong>抵押数字资产</strong>和<strong>去中心化</strong>，它是用一套称之为Maker的智能合约发行的，其背后的团队为MakerDAO。</p><blockquote><p>Maker目前只支持抵押ETH，后面可能会加入其它代币。<br>DAO (Decentralized Autonomous Organization): 去中心化的自治组织</p></blockquote><p>我们都知道数字资产的价值是有很大波动的， 那么Maker怎么来确保 1 DAI = 1 USD的呢？</p><h2 id="稳定币-DAI的发行"><a href="#稳定币-DAI的发行" class="headerlink" title="稳定币 DAI的发行"></a>稳定币 DAI的发行</h2><p>Maker体系中有一个实现了抵押贷款逻辑的智能合约（CDP）， 当我们抵押（发送）ETH到智能合约，合约根据当时ETH的价值，计算一个<strong>折扣</strong>后，发行对应的DAI（符合ERC20标准的代币）。</p><blockquote><p>以太价格获取Maker采用的是中心化方案，从各大交易所获取再加权平均。</p></blockquote><p>为了方便理解，类比抵押屋产贷款，我们把房子作为抵押品向银行贷款，ETH就相当于房子，智能合约相当于银行，DAI 相当于贷款拿到的钱。银行给我们贷款时，银行也会对房子的价值打一个折扣。</p><p>这个折扣在Maker系统中称之为<strong>抵押率</strong>，这是一个很重要的概念，大家务必理解。</p><p>我们给他一个数学定义： <code>抵押率 = 抵押物的价值 / 放贷的价值</code>。</p><p>如果房子价值200万，抵押率为200%， 银行就只能给我们贷款100万，这个大家应该能够理解。<br>同样，假设以太币现在价值200美元，抵押率为200％，那么把1个以太币（200美元）发送到CDP智能合约，就可以获得发行的100个DAI。</p><p>在抵押ETH生成DAI的同时，合约会为我们生成一张<strong>CDP借贷凭证</strong>，它记录着借贷关系及金额，并且抵押ETH会一直锁定在合约里，在还清100个DAI时，ETH将归还我们。 就像银行扣押房子直到我们还清贷款一样。</p><p>到这里，DAI的发行应该明白了。</p><h3 id="套现保值"><a href="#套现保值" class="headerlink" title="套现保值"></a>套现保值</h3><p>DAI的这种抵押贷款逻辑非常有意思 ，它生成的CDP借贷凭证提供给我们一个<strong>套现保值</strong>的手段。假如你有一大笔以太在手里， 而你又急需一笔资金怎么办？ 那么抵押生成DAI是获得资金的一个绝佳选择。如果在交易所把币卖掉换成稳定币，会失去以太的所有权，币价上涨时就无法换回对应的以太。</p><p>例如：目前 ETH 价格约为 130 美元， 按200%的抵押率， 1000个以太可以抵押生成6.5万个DAI，即可以获得6.5万美元资金，假设一年之后，ETH价格涨到到500 美元，只需要偿还6.5万个DAI（美元）及一点利息就可以赎回1000个以太（价值50万美元）。</p><h2 id="DAI是如何保持稳定的？"><a href="#DAI是如何保持稳定的？" class="headerlink" title="DAI是如何保持稳定的？"></a>DAI是如何保持稳定的？</h2><p>依靠抵押美元发行的USDT、TUSD，能保持价值相对稳定很容易理解，靠抵押ETH的DAI如何保持稳定呢？</p><p>分两种情况：如果 ETH 升值， 意味着 DAI 有更足够的抵押（更高的抵押率，担保更充足），这不会有太大影响。如果DAI的交易价格超过1美元，Maker也会激励用户创造更多的DAI（目标利率反馈机制）。</p><blockquote><p>目标利率反馈机制（TRFM）：不过最重要的是以下几点：当DAI的交易价格超过1美元时，智能合约会激励人们生成DAI。当DAI的交易价格不到1美元时，智能合约会激励人们赎返DAI。</p></blockquote><p>如果 ETH 价值下降则复杂一些，回到抵押屋产贷款的类比，如果我们的房子价值下降，银行会要求我们追加抵押物或及时还款，Maker也是一样，始终要求DAI是超额抵押的。</p><p>如果资产下跌到一定值（如抵押率150%），并且原抵押人没有追加抵押物或偿还（部分）DAI，合约会自动启动<strong>清算（liquidated）</strong>，之前抵押的以太币被拍卖，直到从CDP合约借出的DAI被还清。</p><p>还是前面的类比，价值200万房子，抵押率200%，贷款了100万，在房子下跌到150万时，银行就会拍卖房子，清除这笔贷款。 Maker也是使用这种方式从市面上回购DAI用来偿还给CDP。</p><p>简单总结：<br><strong>Maker始终要求DAI是超额抵押的</strong>，当系统发现有部分资产存在风险时，就会对风险过高的资产进行清算，它会首先清算抵押率低于 150% 的CDP借贷凭证，而为了防止清算持有人必须往CDP借贷凭证存入更多ETH或偿还DAI来提高抵押率。</p><p>现在我们来看 <a href="https://cdp.makerdao.com/" target="_blank" rel="noopener">MakerDao抵押借款的界面</a>就清晰了，以下截图是抵押1 ETH 生成60个DAI：</p><p><img src="https://img.learnblockchain.cn/2019/15530688001807.jpg!wl" alt=""></p><p>Collateralization ratio 抵押率为 228%， Liquidation price 清算价格为90 美金。</p><h3 id="清算"><a href="#清算" class="headerlink" title="清算"></a>清算</h3><p>关于清算也许还有几点需要了解：</p><ol><li>在发生清算后， 就再也无法通过偿还DAI来取回之前抵押的ETH了（CDP借贷凭证会关闭）。</li><li>清算发生时，会扣除一部分的罚金（13%的罚金）和手续费。</li><li>拍卖ETH得到的DAI  会被销毁， 就像用户偿还DAI 被销毁一样。</li><li>拍卖偿还DAI后， 剩余的资产用户可以拿回。</li><li>Maker系统中有一个专门负责清算的合约。</li></ol><h2 id="MKR-应对暴跌"><a href="#MKR-应对暴跌" class="headerlink" title="MKR 应对暴跌"></a>MKR 应对暴跌</h2><p>上面一有一个前提，不管如果 DAI 都是超额抵押， 如果以太价格急剧下跌，抵押品的价值达不到借出的DAI的价值时，这时启动清算，将由Mkr持有者负责回购。</p><p>Mkr 是Maker系统中的权益代币， Mkr持有者是系统的收益者，获取借款利息及罚金等。</p><p>还是前面的类比，如果价值200万房子， 突然跌倒100万以下， 这时候在公开市场拍卖，市场是没有买家出100万以上购买房子的，那么银行将启用自有资金回购。</p><p>相当于损失的价值转嫁到Mkr持有者，价格波动是没发消灭的，它只能转移，DAI的价格波动性实际由CDP 借贷凭证持有者和Mkr持有者共同承担。</p><h2 id="一点拓展"><a href="#一点拓展" class="headerlink" title="一点拓展"></a>一点拓展</h2><p>DAI 由于它的超额抵押借款机制，是一个很好的杠杆做多工具。</p><p>如果我们预期以太币会上涨，我们可以把前面1000个以太抵押生成6.5万个DAI，再此购买以太进行抵押，多次操作之后，可能获得数倍的增值。</p><p>为了写这边文章，拓展我不少金融领域知识，以前一直不理解做多做空（因为我不炒股、不炒币），现在把我的理解做一个记录，供参考：</p><h3 id="做多"><a href="#做多" class="headerlink" title="做多"></a>做多</h3><p>做多就是看好其上涨而买入，杠杆做多则是借钱买入。<br>上面就是借DAI（美元）买入以太，借来的6.5万个DAI（美元），按130美元一个以太，可以购买到500个以太，如果一个月后以太涨到200美元， 500个以太就是10万美元，还掉6.5万美元后，相当于<strong>凭空</strong>赚了3.5万美元。</p><h3 id="做空"><a href="#做空" class="headerlink" title="做空"></a>做空</h3><p>做空就是认为其下跌而卖出，同样也可以借别人的卖出。<br>现在130美元一个以太，我认为以太会下跌到100美元，于是我向交易所借了1000个币卖掉获得13万美元，如果真下跌到100美元，就用10万美元换1000个币还给交易所，这样我<strong>凭空</strong>赚了3万美元。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://makerdao.com/zh-CN/whitepaper" target="_blank" rel="noopener">DAI 白皮书</a><br><a href="https://www.chainnews.com/articles/858804412113.htm" target="_blank" rel="noopener">DAI 稳定币的通俗解释</a></p><p>如果你对稳定币感兴趣，我们可以一起交流，我的微信：xlbxiong 备注：稳定币。</p><p>加入<a href="https://learnblockchain.cn/images/zsxq.png">知识星球</a>，和一群优秀的区块链从业者一起学习。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着摩根大通推出JPM Coin 稳定币，可以预见稳定币将成为区块链落地的一大助推器。&lt;br&gt;坦白来讲，对于一个程序员的我来讲（不懂一点专业经济和金融），理解DAI的机制，真的有一点复杂。耐心看完，必有收获。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="稳定币" scheme="https://learnblockchain.cn/tags/%E7%A8%B3%E5%AE%9A%E5%B8%81/"/>
    
      <category term="DAI" scheme="https://learnblockchain.cn/tags/DAI/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一款以太坊（安卓）钱包系列2 - 导入账号及账号管理</title>
    <link href="https://learnblockchain.cn/2019/03/18/eth-wallet-dev-2/"/>
    <id>https://learnblockchain.cn/2019/03/18/eth-wallet-dev-2/</id>
    <published>2019-03-18T03:27:50.000Z</published>
    <updated>2019-04-05T10:29:31.010Z</updated>
    
    <content type="html"><![CDATA[<p>这是如何开发一款以太坊（安卓）钱包系列第2篇，如何导入账号。有时用户可能已经有一个账号，这篇文章接来介绍下，如何实现导入用户已经存在的账号。</p><a id="more"></a><h2 id="导入账号预备知识"><a href="#导入账号预备知识" class="headerlink" title="导入账号预备知识"></a>导入账号预备知识</h2><p>从用户需求上来讲，导入用户已经存在的账号是有必要的。 不过从安全性考虑，当你之前使用的是一个非官方、非开源的钱包产品时（尤其是小众钱包），或者之前没有对私钥、助记词、Keysotre文件小心保存时。<br>正确的做法是提示用户：</p><ol><li>在新的钱包重新创建一个钱包账号、并安全备份（因为之前的可能已经不安全）；</li><li>然后在老钱包里把所有的币转移到新账号。</li></ol><p>导入账号有3种方式：</p><ol><li>通过私钥导入</li><li>通过KeyStore 导入</li><li>通过助记词导入</li></ol><h2 id="通过私钥导入账号"><a href="#通过私钥导入账号" class="headerlink" title="通过私钥导入账号"></a>通过私钥导入账号</h2><p>关键是用用户输入的私钥创建一个椭圆曲线秘钥对，然后用这个秘钥对创建钱包，代码如下：<br>（代码在<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">代码库</a>中的<code>app/src/pro/upchain/wallet/utils/ETHWalletUtils.java</code>文件中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ETHWallet <span class="title">loadWalletByPrivateKey</span><span class="params">(String privateKey, String pwd)</span> </span>&#123;</span><br><span class="line">    Credentials credentials = <span class="keyword">null</span>;</span><br><span class="line">    ECKeyPair ecKeyPair = ECKeyPair.create(Numeric.toBigInt(privateKey));</span><br><span class="line">    <span class="keyword">return</span> generateWallet(generateNewWalletName(), pwd, ecKeyPair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回语句中的 generateWallet()，在<a href="https://learnblockchain.cn/2019/03/13/eth_wallet_dev_1/">系列1-通过助记词创建账号</a> 已经介绍过，通过椭圆曲线秘钥对创建钱包。</p><p>loadWalletByPrivateKey()中第2个参数密码pwd，在私钥生成账号这个过程并不需要pwd，它是用来加密保存私钥，即为了生成keystore文件。</p><h2 id="通过KeyStore文件导入账号"><a href="#通过KeyStore文件导入账号" class="headerlink" title="通过KeyStore文件导入账号"></a>通过KeyStore文件导入账号</h2><p>关于KeyStore文件，不了解的可以阅读下<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_2/">账号Keystore文件导入导出</a>。</p><p>关键步骤：</p><ol><li>KeyStore 文本内容解析WalletFile实例；</li><li>使用密码 解码 WalletFile 生成椭圆曲线秘钥对创建钱包。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keystore 原json文件内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pwd      keystore解密密码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ETHWallet <span class="title">loadWalletByKeystore</span><span class="params">(String keystore, String pwd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WalletFile walletFile = <span class="keyword">null</span>;</span><br><span class="line">        walletFile = objectMapper.readValue(keystore, WalletFile.class);</span><br><span class="line">        <span class="keyword">return</span> generateWallet(generateNewWalletName(), pwd, Wallet.decrypt(pwd, walletFile));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CipherException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过助记词导入账号"><a href="#通过助记词导入账号" class="headerlink" title="通过助记词导入账号"></a>通过助记词导入账号</h2><p>导入和<a href="https://learnblockchain.cn/2019/03/13/eth_wallet_dev_1/">上一篇</a>中，创建非常相似，不同的是，种子由用户提供的助记词生成。</p><p>使用助记词导入账号时，还需要用户选择（或输入）一个推倒路径(参考<a href="https://learnblockchain.cn/2018/09/28/hdwallet/">BIP44</a>)，关键步骤是：</p><ol><li>通过助记词创建随机数种子；</li><li>通过 种子 + 路径 派生生成私钥 创建钱包 ；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过导入助记词，导入钱包</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path bip44路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 助记词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pwd  密码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ETHWallet <span class="title">importMnemonic</span><span class="params">(String path, String mnemonic, String pwd)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt;  list =  Arrays.asList(mnemonic.split(<span class="string">" "</span>))；</span><br><span class="line">    <span class="keyword">if</span> (!path.startsWith(<span class="string">"m"</span>) &amp;&amp; !path.startsWith(<span class="string">"M"</span>)) &#123;</span><br><span class="line">        <span class="comment">//参数非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] pathArray = path.split(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pathArray.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//内容不对</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String passphrase = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">long</span> creationTimeSeconds = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    DeterministicSeed ds = <span class="keyword">new</span> DeterministicSeed(list, <span class="keyword">null</span>, passphrase, creationTimeSeconds);</span><br><span class="line">    <span class="keyword">return</span> generateWalletByMnemonic(generateNewWalletName(), ds, pathArray, pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generateWalletByMnemonic在<a href="https://learnblockchain.cn/2019/03/13/eth_wallet_dev_1/">上一篇</a>中已经介绍过，</p><h2 id="账号存储（保存到数据库）"><a href="#账号存储（保存到数据库）" class="headerlink" title="账号存储（保存到数据库）"></a>账号存储（保存到数据库）</h2><p>很多同学肯定已经注意到， 不管通过什么方式构造的账号，都会最终构造为一个ETHWallet 钱包对象，他的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ETHWallet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;   <span class="comment">// 经过加密后的pwd</span></span><br><span class="line">    <span class="keyword">private</span> String keystorePath;  </span><br><span class="line">    <span class="keyword">private</span> String mnemonic;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isCurrent;   <span class="comment">// 是否是当前选中的钱包</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isBackup;    <span class="comment">// 是否备份过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面构造的ETHWallet是只存在于内容之中， 在应用程序退出之后，这个数据将丢失， 因此我们需要把它序列化到<br>序列化数据库中存储起来，在下一次进入应用的时候加载数据库还原出账号。</p><h3 id="greenDAO"><a href="#greenDAO" class="headerlink" title="greenDAO"></a>greenDAO</h3><p>greenDAO 是一个将<strong>对象映射到 SQLite 数据库</strong>中的轻量且快速的 ORM 解决方案，以下是一个greenDAO的作用示意图：</p><p><img src="https://img.learnblockchain.cn/2019/15529003884556.jpg!wl" alt=""></p><p>这里我们也使用了 greenDAO 来把ETHWallet对象映射到 SQLite 数据库， greenDAO的用法这里只简单说明，不详细阐述，大家可以跟随官方提供的<a href="http://greenrobot.org/greendao/documentation/introduction/" target="_blank" rel="noopener">introduction</a> 和 <a href="http://greenrobot.org/greendao/documentation/how-to-get-started/" target="_blank" rel="noopener">how-to-get-started</a>。</p><h3 id="对象映射保存"><a href="#对象映射保存" class="headerlink" title="对象映射保存"></a>对象映射保存</h3><p>把ETHWallet映射的到数据库，需要给类加上@Entity注解，这样greenDAO会生成几个类：<code>DaoMaster</code>、<code>DaoSession</code>及 <code>ETHWalletDao</code> 帮我们完成构建数据库表等操作。</p><p>在使用ETHWalletDao插入到数据库之前需要先进行一个初始化，通常初始化放在应用程序入口中进行，如：pro.upchain.wallet.UpChainWalletApp的onCreate()中执行，初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DaoMaster.DevOpenHelper mHelper = <span class="keyword">new</span> DaoMaster.DevOpenHelper(<span class="keyword">this</span>, <span class="string">"wallet"</span>, <span class="keyword">null</span>);</span><br><span class="line">    SQLiteDatabase db = mHelper.getWritableDatabase();</span><br><span class="line">    DaoSession daoSession = <span class="keyword">new</span> DaoMaster(db).newSession();</span><br><span class="line">    ETHWalletDao ethWalletDao = daoSession.getETHWalletDao();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了greenDAO为我们生成的辅助类，插入到数据库就很简单了，一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethWalletDao.insert(ethWallet);  //</span><br></pre></td></tr></table></figure><p>ethWallet为ETHWallet实例， 前面不管是新创建还是导入的账号都会构造这样一个实例。</p><h2 id="多账号管理"><a href="#多账号管理" class="headerlink" title="多账号管理"></a>多账号管理</h2><p>考虑到用户可能会创建多个账号，因此需要确定一个当前选定的账号，一般情况下，用户新创建的账号应该作为当前选中的的账号，同时其他账号应该取消选中， 我们完善下账号存储逻辑， 如下：<br>（代码在<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">代码库</a>中的<code>app/src/pro/upchain/wallet/utils/WalletDaoUtils.java</code>文件中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入新创建钱包</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ethWallet 钱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertNewWallet</span><span class="params">(ETHWallet ethWallet)</span> </span>&#123;</span><br><span class="line">    updateCurrent(-<span class="number">1</span>);  <span class="comment">// 取消其他站账号选中状态</span></span><br><span class="line">    ethWallet.setCurrent(<span class="keyword">true</span>);</span><br><span class="line">    ethWalletDao.insert(ethWallet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新选中钱包</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 钱包ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ETHWallet <span class="title">updateCurrent</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 加载所有钱包账号</span></span><br><span class="line">    List&lt;ETHWallet&gt; ethWallets = ethWalletDao.loadAll();</span><br><span class="line">    ETHWallet currentWallet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (ETHWallet ethwallet : ethWallets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id != -<span class="number">1</span> &amp;&amp; ethwallet.getId() == id) &#123;</span><br><span class="line">            ethwallet.setCurrent(<span class="keyword">true</span>);</span><br><span class="line">            currentWallet = ethwallet;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ethwallet.setCurrent(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ethWalletDao.update(ethwallet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentWallet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打通账号创建与保存"><a href="#打通账号创建与保存" class="headerlink" title="打通账号创建与保存"></a>打通账号创建与保存</h2><p>以通过私钥导入账号进行保存为例，把创建账号和保存账号打通，这里我们使用响应式编程 ReactiveX，<br>这部分作为订阅者福利，发表在我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>，趁还未涨价，赶紧订阅吧，超值的！</p><p><a href="https://learnblockchain.cn/2019/03/24/eth_wallet_dev_3/">下一篇</a> 将继续介绍资产的显示。</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ol><li><a href="https://github.com/ReactiveX/RxAndroid/" target="_blank" rel="noopener">RxAndroid</a> 了解更多响应式编程</li><li><a href="http://greenrobot.org/greendao/documentation/introduction/" target="_blank" rel="noopener">introduction</a> 和 <a href="http://greenrobot.org/greendao/documentation/how-to-get-started/" target="_blank" rel="noopener">how-to-get-started</a> 了解greenDAO。</li></ol><p>我创建了一个专门讨论钱包开发的微信群，加微信：xlbxiong 备注：钱包。</p><p>加入<a href="https://learnblockchain.cn/images/zsxq.png">知识星球</a>，和一群优秀的区块链从业者一起学习。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><!--（代码在[代码库](https://github.com/xilibi2003/Upchain-wallet)中的`app/src/pro/upchain/wallet/interact/CreateWalletInteract.java`中）java    public Single<ETHWallet> loadWalletByPrivateKey(final String privateKey, final String pwd) {        return Single.fromCallable(() -> {                    ETHWallet ethWallet = ETHWalletUtils.loadWalletByPrivateKey(privateKey, pwd);                    if (ethWallet != null) {                        WalletDaoUtils.insertNewWallet(ethWallet);                    }                    return ethWallet;                }        ).subscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread());    }这个方法使用响应式编程方法，返回了一个可订阅的Single<ETHWallet> 对象。响应式编程 ReactiveX 提供了一个清晰、准确处理异步问题和事件的方法。RxJava是一个ReactiveX在JVM上的实现，在Android应用开发中使用RxJava 为[RxAndroid](https://github.com/ReactiveX/RxAndroid/)。补充下为什么要用响应式编程方法，因为加解密及数据库（磁盘IO）操作都是耗时操作，不能放在主线程中执行（会造成UI卡顿）， 传统的做法是用`AsyncTask`在`doInBackground`执行耗时操作，而使用ReactiveX代码将简洁很多。代码中使用`subscribeOn`指定被观察者在单独 的**io 子线程**运行（Schedulers.io()） ，`observeOn` 指定观察者运行在AndroidSchedulers.mainThread() 主线程（UI）线程，这样观察者在订阅收到ETHWallet对象后，就可以UI 展示等操作。提示大家阅读本文时，最好把[代码库](https://github.com/xilibi2003/Upchain-wallet)克隆到本地对照阅读。 -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是如何开发一款以太坊（安卓）钱包系列第2篇，如何导入账号。有时用户可能已经有一个账号，这篇文章接来介绍下，如何实现导入用户已经存在的账号。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>技术工坊 第11期</title>
    <link href="https://learnblockchain.cn/2019/03/16/dev_meeting_11/"/>
    <id>https://learnblockchain.cn/2019/03/16/dev_meeting_11/</id>
    <published>2019-03-16T10:47:23.000Z</published>
    <updated>2019-04-05T11:37:02.812Z</updated>
    
    <content type="html"><![CDATA[<p><strong>分享嘉宾：杨尉 先河系统CTO</strong></p><p>话题简介：Filecoin 基础及开发网络实战</p><p>话题大纲：</p><ol><li>Filecoin的定义及设计目的</li><li>Filecoin与IPFS的关系</li><li>Filecoin网络中的角色</li><li>Filecoin核心概念理解</li><li>Filecoin开发网络实战</li></ol><p><a href="https://img.learnblockchain.cn/pdf/filecoin_11.pdf" target="_blank" rel="noopener">点击下载PPT</a> 或<a href="https://m.qlchat.com/live/channel/channelPage/2000003954872128.htm" target="_blank" rel="noopener">收听音频</a></p><p><strong>分享嘉宾：温国兵 SuperONE COO</strong></p><p>话题简介：EOS 钱包，DApp 超级入口</p><p>话题大纲：</p><ol><li>EOS 公链简介</li><li>EOS 钱包概览</li><li>EOS 钱包技术架构</li><li>DApp 如何接入 EOS 钱包</li><li>EOS DApp 生态</li></ol><p><a href="https://img.learnblockchain.cn/pdf/EOS-DApp_11.pdf" target="_blank" rel="noopener">点击下载PPT</a>或<a href="https://m.qlchat.com/live/channel/channelPage/2000003954872128.htm" target="_blank" rel="noopener">收听音频</a></p><p><strong>分享嘉宾：谭长生 DLB数链产品经理</strong></p><p>话题简介：大数据+区块链项目遇到的那些事儿<br>话题大纲：</p><ol><li>大数据+区块链的业态进化</li><li>目前大数据产业面临的挑战</li><li>DLB如何建立一个普惠新生态</li></ol><p><a href="https://img.learnblockchain.cn/pdf/dlb_11.pdf" target="_blank" rel="noopener">点击下载PPT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;分享嘉宾：杨尉 先河系统CTO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;话题简介：Filecoin 基础及开发网络实战&lt;/p&gt;
&lt;p&gt;话题大纲：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Filecoin的定义及设计目的&lt;/li&gt;
&lt;li&gt;Filecoin与IPFS的关系&lt;/li&gt;
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>如何开发一款以太坊（安卓）钱包系列1 - 通过助记词创建账号</title>
    <link href="https://learnblockchain.cn/2019/03/13/eth_wallet_dev_1/"/>
    <id>https://learnblockchain.cn/2019/03/13/eth_wallet_dev_1/</id>
    <published>2019-03-13T08:56:50.000Z</published>
    <updated>2019-04-05T10:29:31.051Z</updated>
    
    <content type="html"><![CDATA[<p>上周我开源了一款<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">钱包</a>，反映很好，一周时间不到已经快到100 Star。接下来我会几篇系列文章把开发以太坊钱包的核心要点写出来，也算是对代码的一个解读。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本钱包是基于Android安卓平台开发，使用的是原生语言 Java 编写， 是基于Java 1.8 版本，其中使用了Java 1.8 中一些较新的语言特性，如 Lambda表达式等；另外还较多使用了<a href="https://github.com/ReactiveX/RxAndroid/" target="_blank" rel="noopener">ReactiveX/RxAndroid</a>响应式编程用法。</p><p>在本系列文章中，重点是介绍以太坊钱包账号、交易等逻辑，有时可能会假定读者已经了解<a href="https://wiki.learnblockchain.cn/ethereum/readme.html" target="_blank" rel="noopener">以太坊</a>及Android开发等相关知识，因为这些内容不是文章的重点，因此不会过多介绍，请海涵。</p><h2 id="钱包包含的功能"><a href="#钱包包含的功能" class="headerlink" title="钱包包含的功能"></a>钱包包含的功能</h2><p>通常一个钱包会包含以下功能：</p><ul><li style="list-style: none"><input type="checkbox" checked> 支持通过生成助记词、Keystore文件、私钥 创建钱包账号。</li><li style="list-style: none"><input type="checkbox" checked> 支持导出钱包账号助记词、私钥、Keystore文件。</li><li style="list-style: none"><input type="checkbox" checked> 支持多个钱包账号管理</li><li style="list-style: none"><input type="checkbox" checked> 账户余额查询及转账功能（二维码扫描支持）。</li><li style="list-style: none"><input type="checkbox" checked> 支持ERC20 代币（余额显示、转账、代币币价显示）</li><li style="list-style: none"><input type="checkbox" checked> 支持用法币（美元和人民币）实时显示币价。</li><li style="list-style: none"><input type="checkbox" checked> 历史交易列表显示</li></ul><h2 id="创建账号预备知识"><a href="#创建账号预备知识" class="headerlink" title="创建账号预备知识"></a>创建账号预备知识</h2><p>我们先来介绍第一个功能：通过生成助记词、Keystore文件、私钥创建钱包账号。<br>本系列中，钱包都是指分层确定性钱包，（HD钱包 Hierarchical Deterministic Wallets）， 之前博客有一篇文章<a href="https://learnblockchain.cn/2018/09/28/hdwallet/">分层钱包</a>进行了详细的介绍，还不熟悉的可以读一下。<br>为了保持本文的完整，这里做一个总结性回顾：以太坊及比特币的<strong>地址是由随机生成的私钥经过椭圆曲线等算法单向推倒而来</strong> ，BIP32及BIP44是为方便管理私钥提出的分层推倒方案，BIP39 定义助记词让分层种子的备份更方便。<br>而KeyStore文件是用来解密以太坊保存私钥的一种方式，大家可以阅读下<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_2/">这篇文章: 账号Keystore文件导入导出</a>了解更多。</p><p>实现完成的，界面如下图：</p><p><img src="https://img.learnblockchain.cn/2019/1551843006.png!wl" alt=""></p><p>这是一张导入钱包账号的截图（导入和创建，其实原理一样），界面仿照ImToken，不过本文将不会介绍UI部分的编写。</p><h3 id="Web3j-amp-bitcoinj"><a href="#Web3j-amp-bitcoinj" class="headerlink" title="Web3j &amp; bitcoinj"></a>Web3j &amp; bitcoinj</h3><p>为了完成创建账号功能，我们需要使用到两个库：<a href="https://github.com/web3j/web3j/" target="_blank" rel="noopener">Web3j</a> 和 <a href="https://github.com/bitcoinj/bitcoinj" target="_blank" rel="noopener">bitcoinj</a></p><p>Web3是一套和以太坊通信的封装库，Web3j是Java版本的实现，例如发起交易和智能合约进行交互，下图很好的表达了其作用。<br><img src="https://img.learnblockchain.cn/2019/15525530768209.jpg!wl" alt=""></p><p>不过本文中的功能，主要是使用了web3j中椭圆曲线加密及KeyStore文件的生成与解密。</p><p>bitcoinj 的功能和web3类似，它是比特币协议的Java实现，他实现了 BIP32、BIP44及BIP39 相关协议。</p><p>Android使用Gradle来构建，直接在<code>app/build.gradle</code>文件中加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.web3j:core:4.1.0-android&apos;</span><br><span class="line">implementation &apos;org.bitcoinj:bitcoinj-core:0.14.7&apos;</span><br></pre></td></tr></table></figure></p><blockquote><p>提示： 实践中遇到的一个问题，由于bitcoinj 中引入了 <code>com.lambdaworks:scrypt</code>加密库， 它包含的<code>lib/x86_64/darwin/libscrypt.dylib</code>文件，会导致在进行Android App Bundle 编译时会出现错误（好像也会导致某些机型没法安装），解决办法是在 build.gradle 加入一下语句，把这个文件在打包时排除掉。<br>packagingOptions {<br>    exclude ‘lib/x86_64/darwin/libscrypt.dylib’<br>}</p></blockquote><h2 id="创建账号实现"><a href="#创建账号实现" class="headerlink" title="创建账号实现"></a>创建账号实现</h2><h3 id="通过助记词常见钱包账号"><a href="#通过助记词常见钱包账号" class="headerlink" title="通过助记词常见钱包账号"></a>通过助记词常见钱包账号</h3><p>这是目前钱包客户端，最常见的一种为用户常见账号的方式，这里会包含一下几个核心步骤：</p><ol><li>生成一个随机数种子；</li><li>通过随机数种子得到助记词；</li><li>通过 种子 + 路径 派生生成私钥；</li><li>使用KeyStore保存私钥；</li><li>私钥推倒出账号地址。</li></ol><p>大家可以在再次阅读<a href="https://learnblockchain.cn/2018/09/28/hdwallet/">分层钱包</a>，理解为何这么做的原因。</p><p>理解了上面几点，那么代码就容易明白了，代码在<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">代码库</a>中的<code>app/src/pro/upchain/wallet/utils/ETHWalletUtils.java</code>中，关键代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建钱包对象入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ETHWallet <span class="title">generateMnemonic</span><span class="params">(String walletName, String pwd)</span> </span>&#123;</span><br><span class="line">    String[] pathArray = <span class="string">"m/44'/60'/0'/0/0"</span>.split(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> creationTimeSeconds = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    SecureRandom secureRandom = SecureRandomUtils.secureRandom();</span><br><span class="line">    DeterministicSeed ds = <span class="keyword">new</span> DeterministicSeed(secureRandom, <span class="number">128</span>, <span class="string">""</span>, creationTimeSeconds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> generateWalletByMnemonic(walletName, ds, pathArray, pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> walletName 钱包名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ds         助记词加密种子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pathArray  助记词标准</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pwd        密码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ETHWallet <span class="title">generateWalletByMnemonic</span><span class="params">(String walletName, DeterministicSeed ds,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String[] pathArray, String pwd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//种子</span></span><br><span class="line">    <span class="keyword">byte</span>[] seedBytes = ds.getSeedBytes();</span><br><span class="line">    <span class="comment">//助记词</span></span><br><span class="line">    List&lt;String&gt; mnemonic = ds.getMnemonicCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seedBytes == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  衍生推倒key</span></span><br><span class="line">    DeterministicKey dkKey = HDKeyDerivation.createMasterPrivateKey(seedBytes);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pathArray.length; i++) &#123;</span><br><span class="line">        ChildNumber childNumber;</span><br><span class="line">        <span class="keyword">if</span> (pathArray[i].endsWith(<span class="string">"'"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> number = Integer.parseInt(pathArray[i].substring(<span class="number">0</span>,</span><br><span class="line">                    pathArray[i].length() - <span class="number">1</span>));</span><br><span class="line">            childNumber = <span class="keyword">new</span> ChildNumber(number, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> number = Integer.parseInt(pathArray[i]);</span><br><span class="line">            childNumber = <span class="keyword">new</span> ChildNumber(number, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dkKey = HDKeyDerivation.deriveChildKey(dkKey, childNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ECKeyPair keyPair = ECKeyPair.create(dkKey.getPrivKeyBytes());</span><br><span class="line">    ETHWallet ethWallet = generateWallet(walletName, pwd, keyPair);</span><br><span class="line">    <span class="keyword">if</span> (ethWallet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ethWallet.setMnemonic(convertMnemonicList(mnemonic));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ethWallet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  通过椭圆曲线秘钥对创建钱包</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ETHWallet <span class="title">generateWallet</span><span class="params">(String walletName, String pwd, ECKeyPair ecKeyPair)</span> </span>&#123;</span><br><span class="line">    WalletFile keyStoreFile;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//最后两个参数： n 是 CPU/Memory 开销值，越高的开销值，计算就越困难。r 表示块大小，p 表示并行度</span></span><br><span class="line">        keyStoreFile = Wallet.create(pwd, ecKeyPair, <span class="number">1024</span>, <span class="number">1</span>); <span class="comment">// WalletUtils. .generateNewWalletFile();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger publicKey = ecKeyPair.getPublicKey();</span><br><span class="line">    String s = publicKey.toString();</span><br><span class="line"></span><br><span class="line">    String wallet_dir = AppFilePath.Wallet_DIR;</span><br><span class="line"></span><br><span class="line">    String keystorePath = <span class="string">"keystore_"</span> + walletName + <span class="string">".json"</span>;</span><br><span class="line">    File destination = <span class="keyword">new</span> File(wallet_dir, <span class="string">"keystore_"</span> + walletName + <span class="string">".json"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目录不存在则创建目录，创建不了则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!createParentDir(destination)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        objectMapper.writeValue(destination, keyStoreFile);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ETHWallet ethWallet = <span class="keyword">new</span> ETHWallet();</span><br><span class="line">    ethWallet.setName(walletName);</span><br><span class="line">    ethWallet.setAddress(Keys.toChecksumAddress(keyStoreFile.getAddress()));</span><br><span class="line">    ethWallet.setKeystorePath(destination.getAbsolutePath());</span><br><span class="line">    ethWallet.setPassword(Md5Utils.md5(pwd));</span><br><span class="line">    <span class="keyword">return</span> ethWallet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>generateMnemonic()</code>是入口函数，最终返回的是一个ETHWallet 自定义的钱包实体类，一个实例就对应一个钱包，ETHWallet保存了钱包相关的属性，后面会详细介绍，如果对它序列化保存钱包账号及多个钱包账号管理。</p><h2 id="几个注意事项"><a href="#几个注意事项" class="headerlink" title="几个注意事项"></a>几个注意事项</h2><p>关于助记词及私钥的保存，有几点要<strong>特别注意</strong>，否则有可能和其他钱包无法兼容或导致私钥泄漏。</p><p>这部分作为订阅者福利，发表在我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>，趁还未涨价，赶紧订阅吧，超值的！</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.web3j.io/" target="_blank" rel="noopener">web3j API 文档</a></li><li><a href="https://github.com/web3j" target="_blank" rel="noopener">web3j GitHub</a></li><li><a href="https://bitcoinj.github.io/" target="_blank" rel="noopener">bitcoinj 介绍及文档 </a></li></ul><p>我创建了一个专门讨论钱包开发的微信群，加微信：xlbxiong 备注：钱包。</p><p>加入最专业的<a href="https://learnblockchain.cn/images/zsxq.png">区块链问答社区</a>，和一群优秀的区块链从业者一起学习。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><!--## 几个注意事项1. 创建钱包输入的密码，并不是用于生成种子，而是用来做keystore 加密的密码，这是业内的一个常规做法，尽管这个做法会降低一些安全性，但是不遵循行规，会导致和其他的钱包不兼容，及在其他钱包的助记词不能导入到我们钱包，或反之。2. keystore 文件应该存储在内部存储沙盒类，即应用程序自身目录内，保证其他程序无法读取内容，万万不可存取在外部存储中，如SD卡。3. 商业产品，应该检查手机时候root，如果root，则第2点的安全性无法保证。 -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周我开源了一款&lt;a href=&quot;https://github.com/xilibi2003/Upchain-wallet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;钱包&lt;/a&gt;，反映很好，一周时间不到已经快到100 Star。接下来我会几篇系列文章把开发以太坊钱包的核心要点写出来，也算是对代码的一个解读。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="助记词" scheme="https://learnblockchain.cn/tags/%E5%8A%A9%E8%AE%B0%E8%AF%8D/"/>
    
      <category term="web3j" scheme="https://learnblockchain.cn/tags/web3j/"/>
    
  </entry>
  
  <entry>
    <title>filecoin技术架构分析系列文章 - 目录</title>
    <link href="https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/"/>
    <id>https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/</id>
    <published>2019-03-11T07:35:33.000Z</published>
    <updated>2019-04-05T10:29:30.992Z</updated>
    
    <content type="html"><![CDATA[<p>我是杨尉，先河系统CTO，欢迎大加关注的的Github: <a href="https://github.com/waynewyang" target="_blank" rel="noopener">waynewyang</a>，因为工作需要，在<a href="https://github.com/filecoin-project" target="_blank" rel="noopener">FileCoin</a>开源后，从源码层对filecoin的架构进行了一下分析，整理了一些文章，希望对大家有所帮助。</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="https://learnblockchain.cn//2019/02/18/filecoin-code-analysis-1">1 filecoin概念</a></li><li><a href="https://learnblockchain.cn//2019/02/20/filecoin-code-analysis-2">2 filecoin通用语言理解</a></li><li><a href="https://learnblockchain.cn//2019/02/22/filecoin-code-analysis-3">3 filecoin开发网使用</a></li><li><a href="https://learnblockchain.cn//2019/02/28/filecoin-code-analysis-4">4 filecoin源码顶层架构分析</a></li><li><a href="https://learnblockchain.cn//2019/03/04/filecoin-code-analysis-5">5 filecoin源码协议层分析之心跳协议</a></li><li><a href="https://learnblockchain.cn//2019/03/04/filecoin-code-analysis-6">6 filecoin源码协议层分析之hello握手协议</a></li><li><a href="https://learnblockchain.cn//2019/03/05/filecoin-code-analysis-7">7 filecoin源码协议层分析之存储协议</a></li><li><a href="https://learnblockchain.cn//2019/03/05/filecoin-code-analysis-8">8 filecoin源码协议层分析之检索协议</a></li><li><a href="https://learnblockchain.cn//2019/03/06/filecoin-code-analysis-9">9 filecoin源码分析之支撑包分析(1)</a></li><li><a href="https://learnblockchain.cn//2019/03/07/filecoin-code-analysis-10">10 filecoin源码分析之支撑包分析(2/2)</a></li><li><a href="https://learnblockchain.cn//2019/03/07/filecoin-code-analysis-11">11 filecoin源码分析之内部接口层api包分析</a></li><li><a href="https://learnblockchain.cn//2019/03/07/filecoin-code-analysis-12">12 filecoin源码分析之内部接口层plumbing＆porcelain接口</a></li><li><a href="https://learnblockchain.cn//2019/03/08/filecoin-code-analysis-13">13 filecoin源码分析之服务层actor及vm</a></li><li><a href="https://learnblockchain.cn//2019/03/09/filecoin-code-analysis-14">14 filecoin源码分析之服务层链同步、共识协议及挖矿</a></li><li><a href="https://learnblockchain.cn//2019/03/10/filecoin-code-analysis-15">15 filecoin源码分析之节点运行逻辑</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是杨尉，先河系统CTO，欢迎大加关注的的Github: &lt;a href=&quot;https://github.com/waynewyang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;waynewyang&lt;/a&gt;，因为工作需要，在&lt;a href=&quot;https://github.com/filecoin-project&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FileCoin&lt;/a&gt;开源后，从源码层对filecoin的架构进行了一下分析，整理了一些文章，希望对大家有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/categories/FileCoin/"/>
    
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/tags/FileCoin/"/>
    
  </entry>
  
  <entry>
    <title>filecoin技术架构分析之十五：filecoin源码分析之节点运行逻辑</title>
    <link href="https://learnblockchain.cn/2019/03/10/filecoin-code-analysis-15/"/>
    <id>https://learnblockchain.cn/2019/03/10/filecoin-code-analysis-15/</id>
    <published>2019-03-10T08:35:33.000Z</published>
    <updated>2019-04-05T10:29:31.007Z</updated>
    
    <content type="html"><![CDATA[<p>我是先河系统CTO杨尉，欢迎大加关注的的Github: <a href="https://github.com/waynewyang" target="_blank" rel="noopener">waynewyang</a>，本文是<a href="https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/">filecoin技术架构分析系列文章</a>第十五章源码分析之节点运行逻辑。</p><a id="more"></a><blockquote><p>分析基于的源码版本：go-filecoin master a0598a54(2019年3月9日)</p></blockquote><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li><p>我们在前面的章节已经经过了三个阶段的梳理分析</p><ul><li>概念阶段，包括概念、通用语言理解、开发网络使用</li><li>顶层架构与概念的结合理解</li><li>具体源码的简析，包括协议层、支撑包、内部api层、服务层</li></ul></li><li><p>源码部分的command部分比较容易理解，就不单独文章赘述了，基本与内部api层都可以对应起来</p></li><li><p>现在再来看节点的运行逻辑应该会更加清晰了</p></li></ul><h2 id="filecoin节点运行逻辑简析"><a href="#filecoin节点运行逻辑简析" class="headerlink" title="filecoin节点运行逻辑简析"></a>filecoin节点运行逻辑简析</h2><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    node</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   +ErrNoMinerAddress</span><br><span class="line">   -filecoinDHTProtocol : dhtprotocol.ID</span><br><span class="line">   -log</span><br><span class="line"></span><br><span class="line">   // 创建具体的filecoin节点实例</span><br><span class="line">▼+Config : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 设置区块时间</span><br><span class="line">   +BlockTime : time.Duration</span><br><span class="line">    // 配置节点是否转发</span><br><span class="line">   +IsRelay : bool</span><br><span class="line">    // libp2p选项</span><br><span class="line">   +Libp2pOpts : []libp2p.Option</span><br><span class="line">    // 在离线模式下，会关闭libp2p</span><br><span class="line">   +OfflineMode : bool</span><br><span class="line">    // 配置资源</span><br><span class="line">   +Repo : repo.Repo</span><br><span class="line">    // 配置区块奖励方法</span><br><span class="line">   +Rewarder : consensus.BlockRewarder</span><br><span class="line">    // 配置节点时空证明校验函数</span><br><span class="line">   +Verifier : proofs.Verifier</span><br><span class="line">    [methods]</span><br><span class="line">    // 创建node实例</span><br><span class="line">   +Build(ctx context.Context) : *Node, error</span><br><span class="line">   -buildHost(ctx context.Context, makeDHT func(host host.Host) routing.IpfsRouting, error) : host.Host, error</span><br><span class="line"></span><br><span class="line"> +ConfigOpt : func(*Config) error</span><br><span class="line"></span><br><span class="line">▼+Node : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 确认最新区块，本地持久化并广播</span><br><span class="line">   +AddNewlyMinedBlock : newBlockFunc</span><br><span class="line">    // 订阅主题&quot;/fil/blocks&quot;</span><br><span class="line">   +BlockSub : pubsub.Subscription</span><br><span class="line">    // 块服务接口</span><br><span class="line">   +Blockstore : bstore.Blockstore</span><br><span class="line">    // 维持相关节点连接</span><br><span class="line">   +Bootstrapper : *net.Bootstrapper</span><br><span class="line">    // 读取区块信息</span><br><span class="line">   +ChainReader : chain.ReadStore</span><br><span class="line">    // 同时协议</span><br><span class="line">   +Consensus : consensus.Protocol</span><br><span class="line">    // 块交换,节点间的数据交换</span><br><span class="line">   +Exchange : exchange.Interface</span><br><span class="line">    // new-head 主题</span><br><span class="line">   +HeaviestTipSetCh : chan interface&#123;&#125;</span><br><span class="line">    // 新区块处理请求</span><br><span class="line">   +HeaviestTipSetHandled : func()</span><br><span class="line">    // hello服务</span><br><span class="line">   +HelloSvc : *hello.Handler</span><br><span class="line">    // 消息订阅</span><br><span class="line">   +MessageSub : pubsub.Subscription</span><br><span class="line">    // 挖矿调度</span><br><span class="line">   +MiningScheduler : mining.Scheduler</span><br><span class="line">    // 消息池操作</span><br><span class="line">   +MsgPool : *core.MessagePool</span><br><span class="line">    // 离线模式</span><br><span class="line">   +OfflineMode : bool</span><br><span class="line">   +OnlineStore : *hamt.CborIpldStore</span><br><span class="line">    // 对应libp2p中的host</span><br><span class="line">   +PeerHost : host.Host</span><br><span class="line">    // libp2p中的ping service</span><br><span class="line">   +Ping : *ping.PingService</span><br><span class="line">    // 高层api</span><br><span class="line">   +PorcelainAPI : *porcelain.API</span><br><span class="line">    // 功率表</span><br><span class="line">   +PowerTable : consensus.PowerTableView</span><br><span class="line">    // 配置资源</span><br><span class="line">   +Repo : repo.Repo</span><br><span class="line">    // 检索客户端</span><br><span class="line">   +RetrievalClient : *retrieval.Client</span><br><span class="line">    // 检索矿工</span><br><span class="line">   +RetrievalMiner : *retrieval.Miner</span><br><span class="line">    // 路由,libp2p</span><br><span class="line">   +Router : routing.IpfsRouting</span><br><span class="line">    // 存储矿工</span><br><span class="line">   +StorageMiner : *storage.Miner</span><br><span class="line">    // 存储客户</span><br><span class="line">   +StorageMinerClient : *storage.Client</span><br><span class="line">    // 链同步</span><br><span class="line">   +Syncer : chain.Syncer</span><br><span class="line">    // 钱包管理</span><br><span class="line">   +Wallet : *wallet.Wallet</span><br><span class="line">   -blockTime : time.Duration</span><br><span class="line">   -blockservice : bserv.BlockService</span><br><span class="line">   -cancelMining : context.CancelFunc</span><br><span class="line">   -cancelSubscriptionsCtx : context.CancelFunc</span><br><span class="line">   -cborStore : *hamt.CborIpldStore</span><br><span class="line">   -host : host.Host</span><br><span class="line">   -lookup : lookup.PeerLookupService</span><br><span class="line">   -mining</span><br><span class="line">   -miningCtx : context.Context</span><br><span class="line">   -miningDoneWg : *sync.WaitGroup</span><br><span class="line">   -sectorBuilder : sectorbuilder.SectorBuilder</span><br><span class="line"></span><br><span class="line">    [methods]</span><br><span class="line">   +BlockHeight() : *types.BlockHeight, error</span><br><span class="line">   +BlockService() : bserv.BlockService</span><br><span class="line">   +CborStore() : *hamt.CborIpldStore</span><br><span class="line">   +ChainReadStore() : chain.ReadStore</span><br><span class="line">    // 创建矿工方法</span><br><span class="line">   +CreateMiner(ctx context.Context, accountAddr address.Address, gasPrice types.AttoFIL, gasLimit types.GasUnits, pledge uint64, pid libp2ppeer.ID, collateral *types.AttoFIL) : *address.Address, error</span><br><span class="line">   +GetBlockTime() : time.Duration</span><br><span class="line">   +Host() : host.Host</span><br><span class="line">    // 节点查找方法</span><br><span class="line">   +Lookup() : lookup.PeerLookupService</span><br><span class="line">   +MiningSignerAddress() : address.Address</span><br><span class="line">   +MiningTimes() : time.Duration, time.Duration</span><br><span class="line">    // 创建新的account地址，钱包地址</span><br><span class="line">   +NewAddress() : address.Address, error</span><br><span class="line">   +SectorBuilder() : sectorbuilder.SectorBuilder</span><br><span class="line">   +SetBlockTime(blockTime time.Duration)</span><br><span class="line">    // 启动节点</span><br><span class="line">   +Start(ctx context.Context) : error</span><br><span class="line">    // 启动挖矿</span><br><span class="line">   +StartMining(ctx context.Context) : error</span><br><span class="line">    // 停止节点</span><br><span class="line">   +Stop(ctx context.Context)</span><br><span class="line">    // 停止挖矿</span><br><span class="line">   +StopMining(ctx context.Context)</span><br><span class="line">   -addNewlyMinedBlock(ctx context.Context, b *types.Block)</span><br><span class="line">   -cancelSubscriptions()</span><br><span class="line">   -getLastUsedSectorID(ctx context.Context, minerAddr address.Address) : uint64, error</span><br><span class="line">   -getMinerActorPubKey() : []byte, error</span><br><span class="line">   -handleNewHeaviestTipSet(ctx context.Context, head types.TipSet)</span><br><span class="line">   -handleNewMiningOutput(miningOutCh chan mining.Output)</span><br><span class="line">   -handleSubscription(ctx context.Context, f pubSubProcessorFunc, fname string, s pubsub.Subscription, sname string)</span><br><span class="line">   -isMining() : bool</span><br><span class="line">   -miningAddress() : address.Address, error</span><br><span class="line">   -miningOwnerAddress(ctx context.Context, miningAddr address.Address) : address.Address, error</span><br><span class="line">   -saveMinerConfig(minerAddr address.Address, signerAddr address.Address) : error</span><br><span class="line">   -setIsMining(isMining bool)</span><br><span class="line">   -setupHeartbeatServices(ctx context.Context) : error</span><br><span class="line">   -setupMining(ctx context.Context) : error</span><br><span class="line">    [functions]</span><br><span class="line">    // 调用Build创建node实例</span><br><span class="line">   +New(ctx context.Context, opts ...ConfigOpt) : *Node, error</span><br><span class="line"></span><br><span class="line">▼-blankValidator : struct</span><br><span class="line">    [methods]</span><br><span class="line">   +Select(_ string, _ [][]byte) : int, error</span><br><span class="line">   +Validate(_ string, _ []byte) : error</span><br><span class="line"></span><br><span class="line"> -newBlockFunc : func(context.Context, *types.Block)</span><br><span class="line"></span><br><span class="line"> -pubSubProcessorFunc : func(ctx context.Context, msg pubsub.Message) error</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   +BlockTime(blockTime time.Duration) : ConfigOpt</span><br><span class="line">   +IsRelay() : ConfigOpt</span><br><span class="line">   +Libp2pOptions(opts ...libp2p.Option) : ConfigOpt</span><br><span class="line">   +OfflineMode(offlineMode bool) : ConfigOpt</span><br><span class="line">   +RewarderConfigOption(rewarder consensus.BlockRewarder) : ConfigOpt</span><br><span class="line">   +StartMining(ctx context.Context, node *Node) : error</span><br><span class="line">   +VerifierConfigOption(verifier proofs.Verifier) : ConfigOpt</span><br><span class="line">   -initSectorBuilderForNode(ctx context.Context, node *Node, sectorStoreType proofs.SectorStoreType) : sectorbuilder.SectorBuilder, error</span><br><span class="line">   -initStorageMinerForNode(ctx context.Context, node *Node) : *storage.Miner, error</span><br><span class="line">   -readGenesisCid(ds datastore.Datastore) : cid.Cid, error</span><br></pre></td></tr></table></figure><h3 id="创建filecoin节点实例"><a href="#创建filecoin节点实例" class="headerlink" title="创建filecoin节点实例"></a>创建filecoin节点实例</h3><ul><li>实例化filecoin节点,简析见如下添加的注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">// Build instantiates a filecoin Node from the settings specified in the config.</span><br><span class="line">func (nc *Config) Build(ctx context.Context) (*Node, error) &#123;</span><br><span class="line">// 创建内存资源实例</span><br><span class="line">if nc.Repo == nil &#123;</span><br><span class="line">nc.Repo = repo.NewInMemoryRepo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建块服务实例</span><br><span class="line">bs := bstore.NewBlockstore(nc.Repo.Datastore())</span><br><span class="line"></span><br><span class="line">validator := blankValidator&#123;&#125;</span><br><span class="line"></span><br><span class="line">var peerHost host.Host</span><br><span class="line">var router routing.IpfsRouting</span><br><span class="line"></span><br><span class="line">// 带宽统计实例,加入libp2popts</span><br><span class="line">bandwidthTracker := p2pmetrics.NewBandwidthCounter()</span><br><span class="line">nc.Libp2pOpts = append(nc.Libp2pOpts, libp2p.BandwidthReporter(bandwidthTracker))</span><br><span class="line"></span><br><span class="line">// 非离线模式才启用libp2p</span><br><span class="line">if !nc.OfflineMode &#123;</span><br><span class="line">makeDHT := func(h host.Host) (routing.IpfsRouting, error) &#123;</span><br><span class="line">r, err := dht.New(</span><br><span class="line">ctx,</span><br><span class="line">h,</span><br><span class="line">dhtopts.Datastore(nc.Repo.Datastore()),</span><br><span class="line">dhtopts.NamespacedValidator(&quot;v&quot;, validator),</span><br><span class="line">dhtopts.Protocols(filecoinDHTProtocol),</span><br><span class="line">)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, errors.Wrap(err, &quot;failed to setup routing&quot;)</span><br><span class="line">&#125;</span><br><span class="line">router = r</span><br><span class="line">return r, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var err error</span><br><span class="line">// 实例化非离线模式libp2p host</span><br><span class="line">peerHost, err = nc.buildHost(ctx, makeDHT)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 离线模式处理</span><br><span class="line">router = offroute.NewOfflineRouter(nc.Repo.Datastore(), validator)</span><br><span class="line">peerHost = rhost.Wrap(noopLibP2PHost&#123;&#125;, router)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ping服务实例</span><br><span class="line">// set up pinger</span><br><span class="line">pinger := ping.NewPingService(peerHost)</span><br><span class="line"></span><br><span class="line">// bitswap实例</span><br><span class="line">// set up bitswap</span><br><span class="line">nwork := bsnet.NewFromIpfsHost(peerHost, router)</span><br><span class="line">//nwork := bsnet.NewFromIpfsHost(innerHost, router)</span><br><span class="line">bswap := bitswap.New(ctx, nwork, bs)</span><br><span class="line">bservice := bserv.New(bs, bswap)</span><br><span class="line"></span><br><span class="line">cstOnline := hamt.CborIpldStore&#123;Blocks: bservice&#125;</span><br><span class="line">cstOffline := hamt.CborIpldStore&#123;Blocks: bserv.New(bs, offline.Exchange(bs))&#125;</span><br><span class="line">// 获取创世块cid</span><br><span class="line">genCid, err := readGenesisCid(nc.Repo.Datastore())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// chain.Store实例以及功率表</span><br><span class="line">var chainStore chain.Store = chain.NewDefaultStore(nc.Repo.ChainDatastore(), &amp;cstOffline, genCid)</span><br><span class="line">powerTable := &amp;consensus.MarketView&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 共识协议processor实例</span><br><span class="line">var processor consensus.Processor</span><br><span class="line">if nc.Rewarder == nil &#123;</span><br><span class="line">processor = consensus.NewDefaultProcessor()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">processor = consensus.NewConfiguredProcessor(consensus.NewDefaultMessageValidator(), nc.Rewarder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 共识协议实例</span><br><span class="line">var nodeConsensus consensus.Protocol</span><br><span class="line">if nc.Verifier == nil &#123;</span><br><span class="line">nodeConsensus = consensus.NewExpected(&amp;cstOffline, bs, processor, powerTable, genCid, &amp;proofs.RustVerifier&#123;&#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">nodeConsensus = consensus.NewExpected(&amp;cstOffline, bs, processor, powerTable, genCid, nc.Verifier)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 链同步，链读取，消息池实例</span><br><span class="line">// only the syncer gets the storage which is online connected</span><br><span class="line">chainSyncer := chain.NewDefaultSyncer(&amp;cstOnline, &amp;cstOffline, nodeConsensus, chainStore)</span><br><span class="line">chainReader, ok := chainStore.(chain.ReadStore)</span><br><span class="line">if !ok &#123;</span><br><span class="line">return nil, errors.New(&quot;failed to cast chain.Store to chain.ReadStore&quot;)</span><br><span class="line">&#125;</span><br><span class="line">msgPool := core.NewMessagePool()</span><br><span class="line"></span><br><span class="line">// Set up libp2p pubsub</span><br><span class="line">fsub, err := libp2pps.NewFloodSub(ctx, peerHost)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, errors.Wrap(err, &quot;failed to set up pubsub&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 钱包服务实例</span><br><span class="line">backend, err := wallet.NewDSBackend(nc.Repo.WalletDatastore())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, errors.Wrap(err, &quot;failed to set up wallet backend&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fcWallet := wallet.New(backend)</span><br><span class="line"></span><br><span class="line">// 实例化高层api</span><br><span class="line">PorcelainAPI := porcelain.New(plumbing.New(&amp;plumbing.APIDeps&#123;</span><br><span class="line">Chain:        chainReader,</span><br><span class="line">Config:       cfg.NewConfig(nc.Repo),</span><br><span class="line">Deals:        strgdls.New(nc.Repo.DealsDatastore()),</span><br><span class="line">MsgPool:      msgPool,</span><br><span class="line">MsgPreviewer: msg.NewPreviewer(fcWallet, chainReader, &amp;cstOffline, bs),</span><br><span class="line">MsgQueryer:   msg.NewQueryer(nc.Repo, fcWallet, chainReader, &amp;cstOffline, bs),</span><br><span class="line">MsgSender:    msg.NewSender(fcWallet, chainReader, msgPool, consensus.NewOutboundMessageValidator(), fsub.Publish),</span><br><span class="line">MsgWaiter:    msg.NewWaiter(chainReader, bs, &amp;cstOffline),</span><br><span class="line">Network:      net.New(peerHost, pubsub.NewPublisher(fsub), pubsub.NewSubscriber(fsub), net.NewRouter(router), bandwidthTracker),</span><br><span class="line">SigGetter:    mthdsig.NewGetter(chainReader),</span><br><span class="line">Wallet:       fcWallet,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">// 实例化node</span><br><span class="line">nd := &amp;Node&#123;</span><br><span class="line">blockservice: bservice,</span><br><span class="line">Blockstore:   bs,</span><br><span class="line">cborStore:    &amp;cstOffline,</span><br><span class="line">OnlineStore:  &amp;cstOnline,</span><br><span class="line">Consensus:    nodeConsensus,</span><br><span class="line">ChainReader:  chainReader,</span><br><span class="line">Syncer:       chainSyncer,</span><br><span class="line">PowerTable:   powerTable,</span><br><span class="line">PorcelainAPI: PorcelainAPI,</span><br><span class="line">Exchange:     bswap,</span><br><span class="line">host:         peerHost,</span><br><span class="line">MsgPool:      msgPool,</span><br><span class="line">OfflineMode:  nc.OfflineMode,</span><br><span class="line">PeerHost:     peerHost,</span><br><span class="line">Ping:         pinger,</span><br><span class="line">Repo:         nc.Repo,</span><br><span class="line">Wallet:       fcWallet,</span><br><span class="line">blockTime:    nc.BlockTime,</span><br><span class="line">Router:       router,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Bootstrapping network peers.</span><br><span class="line">periodStr := nd.Repo.Config().Bootstrap.Period</span><br><span class="line">period, err := time.ParseDuration(periodStr)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, errors.Wrapf(err, &quot;couldn&apos;t parse bootstrap period %s&quot;, periodStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化Bootstrapper,指定node的该方法</span><br><span class="line">// Bootstrapper maintains connections to some subset of addresses</span><br><span class="line">ba := nd.Repo.Config().Bootstrap.Addresses</span><br><span class="line">bpi, err := net.PeerAddrsToPeerInfos(ba)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, errors.Wrapf(err, &quot;couldn&apos;t parse bootstrap addresses [%s]&quot;, ba)</span><br><span class="line">&#125;</span><br><span class="line">minPeerThreshold := nd.Repo.Config().Bootstrap.MinPeerThreshold</span><br><span class="line">nd.Bootstrapper = net.NewBootstrapper(bpi, nd.Host(), nd.Host().Network(), nd.Router, minPeerThreshold, period)</span><br><span class="line"></span><br><span class="line">// 实例化链查找服务，指定node的该方法</span><br><span class="line">// On-chain lookup service</span><br><span class="line">defaultAddressGetter := func() (address.Address, error) &#123;</span><br><span class="line">return nd.PorcelainAPI.GetAndMaybeSetDefaultSenderAddress()</span><br><span class="line">&#125;</span><br><span class="line">nd.lookup = lookup.NewChainLookupService(nd.ChainReader, defaultAddressGetter, bs)</span><br><span class="line"></span><br><span class="line">return nd, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动及停止filecoin节点"><a href="#启动及停止filecoin节点" class="headerlink" title="启动及停止filecoin节点"></a>启动及停止filecoin节点</h3><ul><li>启动filecoin节点的流程概览</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// Start boots up the node.</span><br><span class="line">func (node *Node) Start(ctx context.Context) error &#123;</span><br><span class="line">// 加载本地chain信息</span><br><span class="line">if err := node.ChainReader.Load(ctx); err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果存在存储矿工，配置挖矿功能</span><br><span class="line">// Only set these up if there is a miner configured.</span><br><span class="line">if _, err := node.miningAddress(); err == nil &#123;</span><br><span class="line">if err := node.setupMining(ctx); err != nil &#123;</span><br><span class="line">log.Errorf(&quot;setup mining failed: %v&quot;, err)</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置链同步回调函数</span><br><span class="line">// Start up &apos;hello&apos; handshake service</span><br><span class="line">syncCallBack := func(pid libp2ppeer.ID, cids []cid.Cid, height uint64) &#123;</span><br><span class="line">// TODO it is possible the syncer interface should be modified to</span><br><span class="line">// make use of the additional context not used here (from addr + height).</span><br><span class="line">// To keep things simple for now this info is not used.</span><br><span class="line">err := node.Syncer.HandleNewBlocks(context.Background(), cids)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Infof(&quot;error handling blocks: %s&quot;, types.NewSortedCidSet(cids...).String())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例化hello握手协议</span><br><span class="line">node.HelloSvc = hello.New(node.Host(), node.ChainReader.GenesisCid(), syncCallBack, node.ChainReader.Head)</span><br><span class="line"></span><br><span class="line">// 实例化存储矿工协议</span><br><span class="line">cni := storage.NewClientNodeImpl(dag.NewDAGService(node.BlockService()), node.Host(), node.GetBlockTime())</span><br><span class="line">var err error</span><br><span class="line">node.StorageMinerClient, err = storage.NewClient(cni, node.PorcelainAPI)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return errors.Wrap(err, &quot;Could not make new storage client&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化检索客户及检索矿工协议</span><br><span class="line">node.RetrievalClient = retrieval.NewClient(node)</span><br><span class="line">node.RetrievalMiner = retrieval.NewMiner(node)</span><br><span class="line"></span><br><span class="line">// 订阅区块通知</span><br><span class="line">// subscribe to block notifications</span><br><span class="line">blkSub, err := node.PorcelainAPI.PubSubSubscribe(BlockTopic)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return errors.Wrap(err, &quot;failed to subscribe to blocks topic&quot;)</span><br><span class="line">&#125;</span><br><span class="line">node.BlockSub = blkSub</span><br><span class="line"></span><br><span class="line">// 订阅消息通知</span><br><span class="line">// subscribe to message notifications</span><br><span class="line">msgSub, err := node.PorcelainAPI.PubSubSubscribe(msg.Topic)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return errors.Wrap(err, &quot;failed to subscribe to message topic&quot;)</span><br><span class="line">&#125;</span><br><span class="line">node.MessageSub = msgSub</span><br><span class="line"></span><br><span class="line">cctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">node.cancelSubscriptionsCtx = cancel</span><br><span class="line"></span><br><span class="line">// 启用新线程订阅区块及消息主题,设置handle回调</span><br><span class="line">go node.handleSubscription(cctx, node.processBlock, &quot;processBlock&quot;, node.BlockSub, &quot;BlockSub&quot;)</span><br><span class="line">go node.handleSubscription(cctx, node.processMessage, &quot;processMessage&quot;, node.MessageSub, &quot;MessageSub&quot;)</span><br><span class="line"></span><br><span class="line">// 启用新线程处理新的tipset事件</span><br><span class="line">node.HeaviestTipSetHandled = func() &#123;&#125;</span><br><span class="line">node.HeaviestTipSetCh = node.ChainReader.HeadEvents().Sub(chain.NewHeadTopic)</span><br><span class="line">go node.handleNewHeaviestTipSet(cctx, node.ChainReader.Head())</span><br><span class="line"></span><br><span class="line">// 非离线模式启动bootstapper服务</span><br><span class="line">if !node.OfflineMode &#123;</span><br><span class="line">node.Bootstrapper.Start(context.Background())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 启动心跳服务</span><br><span class="line">if err := node.setupHeartbeatServices(ctx); err != nil &#123;</span><br><span class="line">return errors.Wrap(err, &quot;failed to start heartbeat services&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>停止filecoin节点的流程概览 </li></ul><blockquote><p>释放资源，停止相关服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Stop initiates the shutdown of the node.</span><br><span class="line">func (node *Node) Stop(ctx context.Context) &#123;</span><br><span class="line">node.ChainReader.HeadEvents().Unsub(node.HeaviestTipSetCh)</span><br><span class="line">// 停止挖矿</span><br><span class="line">node.StopMining(ctx)</span><br><span class="line"></span><br><span class="line">// 取消订阅</span><br><span class="line">node.cancelSubscriptions()</span><br><span class="line">// 停止链读取服务</span><br><span class="line">node.ChainReader.Stop()</span><br><span class="line"></span><br><span class="line">// 停止密封服务</span><br><span class="line">if node.SectorBuilder() != nil &#123;</span><br><span class="line">if err := node.SectorBuilder().Close(); err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;error closing sector builder: %s\n&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">node.sectorBuilder = nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭host实例</span><br><span class="line">if err := node.Host().Close(); err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;error closing host: %s\n&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭资源实例</span><br><span class="line">if err := node.Repo.Close(); err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;error closing repo: %s\n&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭bootstqpper实例</span><br><span class="line">node.Bootstrapper.Stop()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;stopping filecoin :(&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动及停止挖矿"><a href="#启动及停止挖矿" class="headerlink" title="启动及停止挖矿"></a>启动及停止挖矿</h3><ul><li>启动挖矿</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">// StartMining causes the node to start feeding blocks to the mining worker and initializes</span><br><span class="line">// the SectorBuilder for the mining address.</span><br><span class="line">func (node *Node) StartMining(ctx context.Context) error &#123;</span><br><span class="line">// 如果在挖矿中，退出</span><br><span class="line">if node.isMining() &#123;</span><br><span class="line">return errors.New(&quot;Node is already mining&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 获取矿工地址</span><br><span class="line">minerAddr, err := node.miningAddress()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return errors.Wrap(err, &quot;failed to get mining address&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 确保密封服务实例存在</span><br><span class="line">// ensure we have a sector builder</span><br><span class="line">if node.SectorBuilder() == nil &#123;</span><br><span class="line">if err := node.setupMining(ctx); err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取地址</span><br><span class="line">minerOwnerAddr, err := node.miningOwnerAddress(ctx, minerAddr)</span><br><span class="line">minerSigningAddress := node.MiningSignerAddress()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return errors.Wrapf(err, &quot;failed to get mining owner address for miner %s&quot;, minerAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blockTime, mineDelay := node.MiningTimes()</span><br><span class="line"></span><br><span class="line">// 实例化挖矿调度服务</span><br><span class="line">if node.MiningScheduler == nil &#123;</span><br><span class="line">getStateFromKey := func(ctx context.Context, tsKey string) (state.Tree, error) &#123;</span><br><span class="line">tsas, err := node.ChainReader.GetTipSetAndState(ctx, tsKey)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return state.LoadStateTree(ctx, node.CborStore(), tsas.TipSetStateRoot, builtin.Actors)</span><br><span class="line">&#125;</span><br><span class="line">getState := func(ctx context.Context, ts types.TipSet) (state.Tree, error) &#123;</span><br><span class="line">return getStateFromKey(ctx, ts.String())</span><br><span class="line">&#125;</span><br><span class="line">getWeight := func(ctx context.Context, ts types.TipSet) (uint64, error) &#123;</span><br><span class="line">parent, err := ts.Parents()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return uint64(0), err</span><br><span class="line">&#125;</span><br><span class="line">// TODO handle genesis cid more gracefully</span><br><span class="line">if parent.Len() == 0 &#123;</span><br><span class="line">return node.Consensus.Weight(ctx, ts, nil)</span><br><span class="line">&#125;</span><br><span class="line">pSt, err := getStateFromKey(ctx, parent.String())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return uint64(0), err</span><br><span class="line">&#125;</span><br><span class="line">return node.Consensus.Weight(ctx, ts, pSt)</span><br><span class="line">&#125;</span><br><span class="line">getAncestors := func(ctx context.Context, ts types.TipSet, newBlockHeight *types.BlockHeight) ([]types.TipSet, error) &#123;</span><br><span class="line">return chain.GetRecentAncestors(ctx, ts, node.ChainReader, newBlockHeight, consensus.AncestorRoundsNeeded, consensus.LookBackParameter)</span><br><span class="line">&#125;</span><br><span class="line">processor := consensus.NewDefaultProcessor()</span><br><span class="line">worker := mining.NewDefaultWorker(node.MsgPool, getState, getWeight, getAncestors, processor, node.PowerTable,</span><br><span class="line">node.Blockstore, node.CborStore(), minerAddr, minerOwnerAddr, minerSigningAddress, node.Wallet, blockTime)</span><br><span class="line">node.MiningScheduler = mining.NewScheduler(worker, mineDelay, node.ChainReader.Head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// paranoid check</span><br><span class="line">// 启动挖矿服务</span><br><span class="line">if !node.MiningScheduler.IsStarted() &#123;</span><br><span class="line">node.miningCtx, node.cancelMining = context.WithCancel(context.Background())</span><br><span class="line">outCh, doneWg := node.MiningScheduler.Start(node.miningCtx)</span><br><span class="line"></span><br><span class="line">node.miningDoneWg = doneWg</span><br><span class="line">node.AddNewlyMinedBlock = node.addNewlyMinedBlock</span><br><span class="line">node.miningDoneWg.Add(1)</span><br><span class="line">go node.handleNewMiningOutput(outCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// initialize a storage miner</span><br><span class="line">// 初始化存储矿工</span><br><span class="line">storageMiner, err := initStorageMinerForNode(ctx, node)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return errors.Wrap(err, &quot;failed to initialize storage miner&quot;)</span><br><span class="line">&#125;</span><br><span class="line">node.StorageMiner = storageMiner</span><br><span class="line"></span><br><span class="line">// loop, turning sealing-results into commitSector messages to be included</span><br><span class="line">// in the chain</span><br><span class="line">// 新开线程处理，1 密封完成处理；2 接受停止挖矿消息</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">// 密封完成处理</span><br><span class="line">case result := &lt;-node.SectorBuilder().SectorSealResults():</span><br><span class="line">if result.SealingErr != nil &#123;</span><br><span class="line">log.Errorf(&quot;failed to seal sector with id %d: %s&quot;, result.SectorID, result.SealingErr.Error())</span><br><span class="line">&#125; else if result.SealingResult != nil &#123;</span><br><span class="line"></span><br><span class="line">// TODO: determine these algorithmically by simulating call and querying historical prices</span><br><span class="line">gasPrice := types.NewGasPrice(0)</span><br><span class="line">gasUnits := types.NewGasUnits(300)</span><br><span class="line"></span><br><span class="line">val := result.SealingResult</span><br><span class="line">// This call can fail due to, e.g. nonce collisions. Our miners existence depends on this.</span><br><span class="line">// We should deal with this, but MessageSendWithRetry is problematic.</span><br><span class="line">_, err := node.PorcelainAPI.MessageSend(</span><br><span class="line">node.miningCtx,</span><br><span class="line">minerOwnerAddr,</span><br><span class="line">minerAddr,</span><br><span class="line">nil,</span><br><span class="line">gasPrice,</span><br><span class="line">gasUnits,</span><br><span class="line">&quot;commitSector&quot;,</span><br><span class="line">val.SectorID,</span><br><span class="line">val.CommD[:],</span><br><span class="line">val.CommR[:],</span><br><span class="line">val.CommRStar[:],</span><br><span class="line">val.Proof[:],</span><br><span class="line">)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorf(&quot;failed to send commitSector message from %s to %s for sector with id %d: %s&quot;, minerOwnerAddr, minerAddr, val.SectorID, err)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node.StorageMiner.OnCommitmentAddedToChain(val, nil)</span><br><span class="line">&#125;</span><br><span class="line">// 挖矿取消</span><br><span class="line">case &lt;-node.miningCtx.Done():</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">// schedules sealing of staged piece-data</span><br><span class="line">// 定时密封阶段性的碎片数据</span><br><span class="line">if node.Repo.Config().Mining.AutoSealIntervalSeconds &gt; 0 &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">// 取消</span><br><span class="line">case &lt;-node.miningCtx.Done():</span><br><span class="line">return</span><br><span class="line">// 定时密封</span><br><span class="line">case &lt;-time.After(time.Duration(node.Repo.Config().Mining.AutoSealIntervalSeconds) * time.Second):</span><br><span class="line">log.Info(&quot;auto-seal has been triggered&quot;)</span><br><span class="line">if err := node.SectorBuilder().SealAllStagedSectors(node.miningCtx); err != nil &#123;</span><br><span class="line">log.Errorf(&quot;scheduler received error from node.SectorBuilder.SealAllStagedSectors (%s) - exiting&quot;, err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.Debug(&quot;auto-seal is disabled&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 设置微挖矿状态</span><br><span class="line">node.setIsMining(true)</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>停止挖矿</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// StopMining stops mining on new blocks.</span><br><span class="line">func (node *Node) StopMining(ctx context.Context) &#123;</span><br><span class="line">node.setIsMining(false)</span><br><span class="line"></span><br><span class="line">// 取消挖矿</span><br><span class="line">if node.cancelMining != nil &#123;</span><br><span class="line">node.cancelMining()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等待执行中的挖矿任务完成后结束</span><br><span class="line">if node.miningDoneWg != nil &#123;</span><br><span class="line">node.miningDoneWg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO: stop node.StorageMiner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阶段性分析结束说明"><a href="#阶段性分析结束说明" class="headerlink" title="阶段性分析结束说明"></a>阶段性分析结束说明</h2><blockquote><p>至此笔者针对go-filecoin部分的分析快告一个小的段落了</p><p>文章因为时间的关系，书面出来只是将关键部分书面表达出来，更多的像是笔者的一个分析笔记,但是我相信对于想分析源码的朋友有一定帮助</p><p>后面会抽空补充一章总结，笔者在第4章中有提到过，薄读-&gt;厚读-&gt;再薄读,我们还需要一次薄读，来加深我们对filecoin的认识。</p></blockquote><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是先河系统CTO杨尉，欢迎大加关注的的Github: &lt;a href=&quot;https://github.com/waynewyang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;waynewyang&lt;/a&gt;，本文是&lt;a href=&quot;https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/&quot;&gt;filecoin技术架构分析系列文章&lt;/a&gt;第十五章源码分析之节点运行逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/categories/FileCoin/"/>
    
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/tags/FileCoin/"/>
    
  </entry>
  
  <entry>
    <title>filecoin技术架构分析十四：filecoin源码分析之服务层链同步、共识协议及挖矿</title>
    <link href="https://learnblockchain.cn/2019/03/09/filecoin-code-analysis-14/"/>
    <id>https://learnblockchain.cn/2019/03/09/filecoin-code-analysis-14/</id>
    <published>2019-03-09T08:35:33.000Z</published>
    <updated>2019-04-05T10:29:31.017Z</updated>
    
    <content type="html"><![CDATA[<p>我是先河系统CTO杨尉，欢迎大加关注的的Github: <a href="https://github.com/waynewyang" target="_blank" rel="noopener">waynewyang</a>，本文是<a href="https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/">filecoin技术架构分析系列文章</a>第十四章源码分析之服务层链同步、共识协议及挖矿。</p><a id="more"></a><blockquote><p>分析基于的源码版本：go-filecoin master a0598a54(2019年3月9日)</p></blockquote><h2 id="chain同步"><a href="#chain同步" class="headerlink" title="chain同步"></a>chain同步</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><ul><li>TipIndex 定义定义了tipset的基础结构及方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    chain</span><br><span class="line"></span><br><span class="line">▼+TipIndex : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -mu : sync.Mutex</span><br><span class="line">    // 根据id来获取tipset及其状态根</span><br><span class="line">   -tsasByID : tsasByTipSetID</span><br><span class="line">    // 根据父块来获取tipset及其状态根</span><br><span class="line">   -tsasByParentsAndHeight : map[string]tsasByTipSetID</span><br><span class="line"></span><br><span class="line">    [methods]</span><br><span class="line">    // 根据id来获取tipset及其状态根</span><br><span class="line">   +Get(tsKey string) : *TipSetAndState, error</span><br><span class="line">    // 根据父块来获取tipset及其状态根</span><br><span class="line">   +GetByParentsAndHeight(pKey string, h uint64) : []*TipSetAndState, error</span><br><span class="line">    // 根据Id判断是否有此tipset</span><br><span class="line">   +Has(tsKey string) : bool</span><br><span class="line">    // 根据父块判断是否有此tipset</span><br><span class="line">   +HasByParentsAndHeight(pKey string, h uint64) : bool</span><br><span class="line">    // 设置tipset和状态根</span><br><span class="line">   +Put(tsas *TipSetAndState) : error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewTipIndex() : *TipIndex</span><br><span class="line"></span><br><span class="line">▼+TipSetAndState : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // tipset</span><br><span class="line">   +TipSet : types.TipSet</span><br><span class="line">    // 相当于区块的root cid</span><br><span class="line">   +TipSetStateRoot : cid.Cid</span><br></pre></td></tr></table></figure><h3 id="链同步"><a href="#链同步" class="headerlink" title="链同步"></a>链同步</h3><ul><li>chain同步的接口定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location: chain/syncer.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    chain</span><br><span class="line"></span><br><span class="line">▼+Syncer : interface</span><br><span class="line">    [methods]</span><br><span class="line">    // 处理新区块的接口定义</span><br><span class="line">   +HandleNewBlocks(ctx context.Context, blkCids []cid.Cid) : error</span><br><span class="line"></span><br><span class="line">   具体接口实现在location: chain/defalut_syncer.go中</span><br></pre></td></tr></table></figure><ul><li>特殊情况的错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location: chain/reorg.go</span><br><span class="line"></span><br><span class="line">    // 如果当前区块头不包含在最新的区块头之上时候，会报此错误</span><br><span class="line">▼ functions</span><br><span class="line">   +IsReorg(curHead types.TipSet, newChain []types.TipSet) : bool</span><br></pre></td></tr></table></figure><h3 id="链存储"><a href="#链存储" class="headerlink" title="链存储"></a>链存储</h3><ul><li>其中<ul><li>Readstore是一个通用接口</li><li>Store的设计基本是给ChainSync使用的</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">location: chain/store.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    chain</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">    // 用于发布新的区块头的主题&quot;new-head&quot;</span><br><span class="line">   +NewHeadTopic</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">    // 创世块的key</span><br><span class="line">   +GenesisKey</span><br><span class="line"></span><br><span class="line">▼+ReadStore : interface</span><br><span class="line">    [methods]</span><br><span class="line">    // 获取历史区块，通过channel实现</span><br><span class="line">   +BlockHistory(ctx context.Context, tips types.TipSet) : chan interface&#123;&#125;</span><br><span class="line">    // 获取创世区块cid</span><br><span class="line">   +GenesisCid() : cid.Cid</span><br><span class="line">    // 通过cid获取具体的block</span><br><span class="line">   +GetBlock(ctx context.Context, id cid.Cid) : *types.Block, error</span><br><span class="line">    // 通过cid获取具体的block</span><br><span class="line">   +GetTipSetAndState(ctx context.Context, tsKey string) : *TipSetAndState, error</span><br><span class="line">    // 获取最新区块</span><br><span class="line">   +Head() : types.TipSet</span><br><span class="line">    // 最新区块变更事件</span><br><span class="line">   +HeadEvents() : *pubsub.PubSub</span><br><span class="line">    // 最新合约状态</span><br><span class="line">   +LatestState(ctx context.Context) : state.Tree, error</span><br><span class="line">    // 加载chain</span><br><span class="line">   +Load(ctx context.Context) : error</span><br><span class="line">    // 停止</span><br><span class="line">   +Stop()</span><br><span class="line"></span><br><span class="line">    // 这个接口只是chain同步使用</span><br><span class="line">▼+Store : interface</span><br><span class="line">    [embedded]</span><br><span class="line">   +ReadStore</span><br><span class="line">    [methods]</span><br><span class="line">   +GetBlocks(ctx context.Context, ids types.SortedCidSet) : []*types.Block, error</span><br><span class="line">   +GetTipSetAndStatesByParentsAndHeight(ctx context.Context, pTsKey string, h uint64) : []*TipSetAndState, error</span><br><span class="line">   +HasAllBlocks(ctx context.Context, cs []cid.Cid) : bool</span><br><span class="line">   +HasBlock(ctx context.Context, c cid.Cid) : bool</span><br><span class="line">   +HasTipSetAndState(ctx context.Context, tsKey string) : bool</span><br><span class="line">   +HasTipSetAndStatesWithParentsAndHeight(ctx context.Context, pTsKey string, h uint64) : bool</span><br><span class="line">    // 存储并更新最新区块信息</span><br><span class="line">   +PutTipSetAndState(ctx context.Context, tsas *TipSetAndState) : error</span><br><span class="line">   +SetHead(ctx context.Context, s types.TipSet) : error</span><br></pre></td></tr></table></figure><h2 id="consensus"><a href="#consensus" class="headerlink" title="consensus"></a>consensus</h2><ul><li>主要功能<ul><li>提供创建选票方法，验证中奖选票方法,确定最终的tipset</li><li>将合法的tipset消息取出，生效actor状态</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    consensus</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">   +ECPrM : uint64</span><br><span class="line">   +ECV : uint64</span><br><span class="line">   +LookBackParameter</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   +AncestorRoundsNeeded</span><br><span class="line">   +ErrInvalidBase</span><br><span class="line">   +ErrStateRootMismatch</span><br><span class="line">   +ErrUnorderedTipSets</span><br><span class="line">   -log</span><br><span class="line">   -ticketDomain : *big.Int</span><br><span class="line"></span><br><span class="line">    // Expected实现EC共识</span><br><span class="line">▼+Expected : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 全局功率表</span><br><span class="line">   +PwrTableView : PowerTableView</span><br><span class="line">   -bstore : blockstore.Blockstore</span><br><span class="line">   -cstore : *hamt.CborIpldStore</span><br><span class="line">   -genesisCid : cid.Cid</span><br><span class="line">   -processor : Processor</span><br><span class="line">   -verifier : proofs.Verifier</span><br><span class="line">    [methods]</span><br><span class="line">    // 比较两个tipset的权重</span><br><span class="line">   +IsHeavier(ctx context.Context, a, b types.TipSet, aSt, bSt state.Tree) : bool, error</span><br><span class="line">    // 建立新的tipset</span><br><span class="line">   +NewValidTipSet(ctx context.Context, blks []*types.Block) : types.TipSet, error</span><br><span class="line">    // 运行状态转换</span><br><span class="line">    // 1 新区块到来的时候出发状态转换(chain sync逻辑)</span><br><span class="line">    // 2 进入后判断tipset的有效性，包括验证选票是否中奖</span><br><span class="line">    // 3 逐一执行消息，切换状态</span><br><span class="line">   +RunStateTransition(ctx context.Context, ts types.TipSet, ancestors []types.TipSet, pSt state.Tree) : state.Tree, error</span><br><span class="line">    // 计算tipset权重</span><br><span class="line">   +Weight(ctx context.Context, ts types.TipSet, pSt state.Tree) : uint64, error</span><br><span class="line">   -runMessages(ctx context.Context, st state.Tree, vms vm.StorageMap, ts types.TipSet, ancestors []types.TipSet) : state.Tree, error</span><br><span class="line">   -validateBlockStructure(ctx context.Context, b *types.Block) : error</span><br><span class="line">   -validateMining(ctx context.Context, st state.Tree, ts types.TipSet, parentTs types.TipSet) : error</span><br><span class="line"></span><br><span class="line">▼+Processor : interface</span><br><span class="line">    // 会被RunStateTransition间接掉用,进行状态切换(生效挖矿成功的tipset消息)</span><br><span class="line">    [methods]</span><br><span class="line">    // 从tipset中逐一取出block处理</span><br><span class="line">   +ProcessBlock(ctx context.Context, st state.Tree, vms vm.StorageMap, blk *types.Block, ancestors []types.TipSet) : []*ApplicationResult, error</span><br><span class="line">   +ProcessTipSet(ctx context.Context, st state.Tree, vms vm.StorageMap, ts types.TipSet, ancestors []types.TipSet) : *ProcessTipSetResponse, error</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 与白皮书描述一致，按照存储功率出块，用以判断是否中奖</span><br><span class="line">   +CompareTicketPower(ticket types.Signature, minerPower uint64, totalPower uint64) : bool</span><br><span class="line">    // 产生随机挑战种子,针对时空证明</span><br><span class="line">   +CreateChallengeSeed(parents types.TipSet, nullBlkCount uint64) : proofs.PoStChallengeSeed, error</span><br><span class="line">    // 生成选票</span><br><span class="line">    // 用上一个区块的时空证明+矿工地址（目前直接用的矿工地址,issue1054讨论中） 生成２５６bit哈希</span><br><span class="line">   +CreateTicket(proof proofs.PoStProof, minerAddr address.Address) : []byte</span><br><span class="line">    // 判断是否中奖,调用CompareTicketPower</span><br><span class="line">   +IsWinningTicket(ctx context.Context, bs blockstore.Blockstore, ptv PowerTableView, st state.Tree, ticket types.Signature, miner address.Address) : bool, error</span><br><span class="line">    // 实例化Expected</span><br><span class="line">   +NewExpected(cs *hamt.CborIpldStore, bs blockstore.Blockstore, processor Processor, pt PowerTableView, gCid cid.Cid, verifier proofs.Verifier) : Protocol</span><br><span class="line">   -init()</span><br></pre></td></tr></table></figure><h2 id="mining"><a href="#mining" class="headerlink" title="mining"></a>mining</h2><h3 id="挖矿的主要逻辑"><a href="#挖矿的主要逻辑" class="headerlink" title="挖矿的主要逻辑"></a>挖矿的主要逻辑</h3><ul><li>1 不能将空块最为基准块</li><li>2 基于上一个Tipset信息（如果上一个为空块，必须找到空块之前高度最高的Tipset，并记录中间空块数据）和空块数母生成合法的时空证明挑战参数</li><li>3 生成时空证明</li><li>4 时空证明成功，调用共识协议创建奖票</li><li>5 如果奖票中奖，将未打包的消息打包区块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">location: mining/working</span><br><span class="line"></span><br><span class="line">//这里是挖矿逻辑的真正入口</span><br><span class="line"></span><br><span class="line">// Mine implements the DefaultWorkers main mining function..</span><br><span class="line">// The returned bool indicates if this miner created a new block or not.</span><br><span class="line">func (w *DefaultWorker) Mine(ctx context.Context, base types.TipSet, nullBlkCount int, outCh chan&lt;- Output) bool &#123;</span><br><span class="line">log.Info(&quot;Worker.Mine&quot;)</span><br><span class="line">ctx = log.Start(ctx, &quot;Worker.Mine&quot;)</span><br><span class="line">defer log.Finish(ctx)</span><br><span class="line">    // 不能将空块作为基准块挖矿</span><br><span class="line">if len(base) == 0 &#123;</span><br><span class="line">log.Warning(&quot;Worker.Mine returning because it can&apos;t mine on an empty tipset&quot;)</span><br><span class="line">outCh &lt;- Output&#123;Err: errors.New(&quot;bad input tipset with no blocks sent to Mine()&quot;)&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st, err := w.getStateTree(ctx, base)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorf(&quot;Worker.Mine couldn&apos;t get state tree for tipset: %s&quot;, err.Error())</span><br><span class="line">outCh &lt;- Output&#123;Err: err&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Debugf(&quot;Mining on tipset: %s, with %d null blocks.&quot;, base.String(), nullBlkCount)</span><br><span class="line">if ctx.Err() != nil &#123;</span><br><span class="line">log.Warningf(&quot;Worker.Mine returning with ctx error %s&quot;, ctx.Err().Error())</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 基于上一个基准Tipset以及空块数目生成Post随机挑战参数</span><br><span class="line">challenge, err := consensus.CreateChallengeSeed(base, uint64(nullBlkCount))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">outCh &lt;- Output&#123;Err: err&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 生成时空证明</span><br><span class="line">prCh := createProof(challenge, w.createPoSTFunc)</span><br><span class="line"></span><br><span class="line">var proof proofs.PoStProof</span><br><span class="line">var ticket []byte</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">log.Infof(&quot;Mining run on base %s with %d null blocks canceled.&quot;, base.String(), nullBlkCount)</span><br><span class="line">return false</span><br><span class="line">case prChRead, more := &lt;-prCh:</span><br><span class="line">if !more &#123;</span><br><span class="line">log.Errorf(&quot;Worker.Mine got zero value from channel prChRead&quot;)</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">copy(proof[:], prChRead[:])</span><br><span class="line">        // 时空证明成功，调用共识协议创建奖票</span><br><span class="line">ticket = consensus.CreateTicket(proof, w.minerAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO: Test the interplay of isWinningTicket() and createPoSTFunc()</span><br><span class="line">// https://github.com/filecoin-project/go-filecoin/issues/1791</span><br><span class="line">    // 调用共识协议确认是否中奖</span><br><span class="line">weHaveAWinner, err := consensus.IsWinningTicket(ctx, w.blockstore, w.powerTable, st, ticket, w.minerAddr)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorf(&quot;Worker.Mine couldn&apos;t compute ticket: %s&quot;, err.Error())</span><br><span class="line">outCh &lt;- Output&#123;Err: err&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if weHaveAWinner &#123;</span><br><span class="line">        // 如果中奖将打包消息，生成区块</span><br><span class="line">next, err := w.Generate(ctx, base, ticket, proof, uint64(nullBlkCount))</span><br><span class="line">if err == nil &#123;</span><br><span class="line">log.SetTag(ctx, &quot;block&quot;, next)</span><br><span class="line">log.Debugf(&quot;Worker.Mine generates new winning block! %s&quot;, next.Cid().String())</span><br><span class="line">&#125;</span><br><span class="line">outCh &lt;- NewOutput(next, err)</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他细节源码简析"><a href="#其他细节源码简析" class="headerlink" title="其他细节源码简析"></a>其他细节源码简析</h3><ul><li>消息队列（交易消息集）的处理 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">location: mining/mqueue.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    mining</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+MessageQueue : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -senderQueues : queueHeap</span><br><span class="line">    [methods]</span><br><span class="line">    // 取出消息切片，即多条消息</span><br><span class="line">   +Drain() : []*types.SignedMessage</span><br><span class="line">   +Empty() : bool</span><br><span class="line">    // 从队列取出一条消息</span><br><span class="line">   +Pop() : *types.SignedMessage, bool</span><br><span class="line">    [functions]</span><br><span class="line">    // 实例化消息队列</span><br><span class="line">   +NewMessageQueue(msgs []*types.SignedMessage) : MessageQueue</span><br><span class="line"></span><br><span class="line"> -nonceQueue : []*types.SignedMessage</span><br><span class="line"></span><br><span class="line">    // 一些队列的基本操作</span><br><span class="line">    // 1 长度、push、pop功能</span><br><span class="line">    // 2 Less主要是比较两条交易中的Gas价格，大家可以回头看看type中的消息定义,这里不赘述了</span><br><span class="line">    // 3 为什么要提供Less接口，留给大家思索一下，熟悉以太坊的可能一眼就看出了</span><br><span class="line">▼-queueHeap : []nonceQueue</span><br><span class="line">    [methods]</span><br><span class="line">   +Len() : int</span><br><span class="line">   +Less(i, j int) : bool</span><br><span class="line">   +Pop() : interface&#123;&#125;</span><br><span class="line">   +Push(x interface&#123;&#125;)</span><br><span class="line">   +Swap(i, j int)</span><br></pre></td></tr></table></figure><ul><li>调度器<ul><li>入口</li><li>node实例会调用NewScheduler创建相关实例并启动挖矿</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    mining</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">   +MineDelayConversionFactor</span><br><span class="line"></span><br><span class="line">▼-timingScheduler : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -isStarted : bool</span><br><span class="line">   -mineDelay : time.Duration</span><br><span class="line">    // 查找权重最高的Tipset</span><br><span class="line">   -pollHeadFunc : func() types.TipSet</span><br><span class="line">    // 底层的挖矿逻辑，在下面会分析Worker</span><br><span class="line">   -worker : Worker</span><br><span class="line">    [methods]</span><br><span class="line">    // 判断是否启动挖矿</span><br><span class="line">   +IsStarted() : bool</span><br><span class="line">    // 启动挖矿</span><br><span class="line">   +Start(miningCtx context.Context) : chan Output, *sync.WaitGroup</span><br><span class="line"></span><br><span class="line">▼+Scheduler : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +IsStarted() : bool</span><br><span class="line">   +Start(miningCtx context.Context) : chan Output, *sync.WaitGroup</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   +MineOnce(ctx context.Context, w Worker, md time.Duration, ts types.TipSet) : Output, error</span><br><span class="line">    // 实例化timingScheduler </span><br><span class="line">   +NewScheduler(w Worker, md time.Duration, f func() types.TipSet) : Scheduler</span><br><span class="line">   -nextNullBlkCount(prevNullBlkCount int, prevBase, currBase types.TipSet) : int</span><br></pre></td></tr></table></figure><ul><li>打包区块<ul><li>具体见如下注释，可对应此查阅源码。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location: mining/block_generate.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    mining</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ DefaultWorker* : ctype</span><br><span class="line">    [methods]</span><br><span class="line">    // 1 如果节点没有产生过有效存储，无法参与挖矿</span><br><span class="line">    // 2 计算区块高度= 基准Tipset高度+空块数目</span><br><span class="line">    // 3 取出未打包消息，调用vm执行,生成收据，并更新状态</span><br><span class="line">    // 4 打包区块信息,返回</span><br><span class="line">   +Generate(ctx context.Context, baseTipSet types.TipSet, ticket types.Signature, proof proofs.PoStProof, nullBlockCount uint64) : *types.Block, error</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是先河系统CTO杨尉，欢迎大加关注的的Github: &lt;a href=&quot;https://github.com/waynewyang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;waynewyang&lt;/a&gt;，本文是&lt;a href=&quot;https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/&quot;&gt;filecoin技术架构分析系列文章&lt;/a&gt;第十四章源码分析之服务层链同步、共识协议及挖矿。&lt;/p&gt;
    
    </summary>
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/categories/FileCoin/"/>
    
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/tags/FileCoin/"/>
    
  </entry>
  
  <entry>
    <title>filecoin技术架构分析十三：filecoin源码分析之服务层actor及vm</title>
    <link href="https://learnblockchain.cn/2019/03/08/filecoin-code-analysis-13/"/>
    <id>https://learnblockchain.cn/2019/03/08/filecoin-code-analysis-13/</id>
    <published>2019-03-08T08:35:33.000Z</published>
    <updated>2019-04-05T10:29:31.035Z</updated>
    
    <content type="html"><![CDATA[<p>我是先河系统CTO杨尉，欢迎大加关注的的Github: <a href="https://github.com/waynewyang" target="_blank" rel="noopener">waynewyang</a>，本文是<a href="https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/">filecoin技术架构分析系列文章</a>第十三章源码分析之服务层actor及vm。</p><a id="more"></a><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>分析源代码版本：master 2c87fd59（2019.3.7）</p><p>回头看第三章开发网使用中创建矿工，提交订单，支付等操作实际上都是actor的新增及状态改变</p><p>当前的实现vm还不具备通用abi数据的解释执行能力，未达到真正智能合约水平</p></blockquote><h2 id="exec-actor及vm的接口定义"><a href="#exec-actor及vm的接口定义" class="headerlink" title="exec(actor及vm的接口定义)"></a>exec(actor及vm的接口定义)</h2><ul><li><p>说明</p><ul><li>提供可执行actor的最小接口要求 ExecutableActor (由actor及具体actor包实现)</li><li>提供actor键值存取接口定义 Lookup (由actor包实现)</li><li>提供状态临时存储的接口定义　Storage (由vm.Storage实现)</li><li>actor的执行环境接口定义 VMContext (由vm.context实现)</li></ul></li><li><p>具体源码注释如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    exec</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">   +ErrDanglingPointer</span><br><span class="line">   +ErrDecode</span><br><span class="line">   +ErrInsufficientGas</span><br><span class="line">   +ErrStaleHead</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   +Errors</span><br><span class="line"></span><br><span class="line">▼+Error : string</span><br><span class="line">    [methods]</span><br><span class="line">   +Error() : string</span><br><span class="line"></span><br><span class="line"> +ExportedFunc : func(ctx VMContext) []byte, uint8, error</span><br><span class="line"></span><br><span class="line">    // actor符号集合</span><br><span class="line">▼+Exports : map[string]*FunctionSignature</span><br><span class="line">    [methods]</span><br><span class="line">    // 判断是否存在特定方法</span><br><span class="line">   +Has(method string) : bool</span><br><span class="line">    </span><br><span class="line">    // 对于单个函数的符号表</span><br><span class="line">    // todo中的事情：需要转换为非go类型</span><br><span class="line">▼+FunctionSignature : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Params : []abi.Type</span><br><span class="line">   +Return : []abi.Type</span><br><span class="line"></span><br><span class="line">    // 可执行合约接口，这是每一类型的合约必须实现的最小接口</span><br><span class="line">    // 包括account,miner,storagemarket,paymentbroker</span><br><span class="line">▼+ExecutableActor : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Exports() : Exports</span><br><span class="line">   +InitializeState(storage Storage, initializerData interface&#123;&#125;) : error</span><br><span class="line"></span><br><span class="line">   // 由actor.lookup实现键值存储　（actor/storage.go）</span><br><span class="line">▼+Lookup : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Commit(ctx context.Context) : cid.Cid, error</span><br><span class="line">   +Delete(ctx context.Context, k string) : error</span><br><span class="line">   +Find(ctx context.Context, k string) : interface&#123;&#125;, error</span><br><span class="line">   +IsEmpty() : bool</span><br><span class="line">   +Set(ctx context.Context, k string, v interface&#123;&#125;) : error</span><br><span class="line">   +Values(ctx context.Context) : []*hamt.KV, error</span><br><span class="line"></span><br><span class="line">   // 由vm.Storage实现</span><br><span class="line">   // 解决持久化的问题，有副本防止回滚机制</span><br><span class="line">   // 具体实现还有Flush持久化到datastore功能</span><br><span class="line">▼+Storage : interface</span><br><span class="line">    [methods]</span><br><span class="line">    // 提交最新actor　Head</span><br><span class="line">   +Commit(cid.Cid, cid.Cid) : error</span><br><span class="line">    // 如下都为内存中操作</span><br><span class="line">   +Get(cid.Cid) : []byte, error</span><br><span class="line">   +Head() : cid.Cid</span><br><span class="line">   +Put(interface&#123;&#125;) : cid.Cid, error</span><br><span class="line"></span><br><span class="line">    // actor的abi执行环境接口,由vm.context实现</span><br><span class="line">▼+VMContext : interface</span><br><span class="line">    [methods]</span><br><span class="line">    // 创建新的合约地址</span><br><span class="line">   +AddressForNewActor() : address.Address, error</span><br><span class="line">    // 查询区块高度</span><br><span class="line">   +BlockHeight() : *types.BlockHeight</span><br><span class="line">    // Gas收费</span><br><span class="line">   +Charge(cost types.GasUnits) : error</span><br><span class="line">    //　创建合约</span><br><span class="line">   +CreateNewActor(addr address.Address, code cid.Cid, initalizationParams interface&#123;&#125;) : error</span><br><span class="line">    // 判断是否为account类型的Actor</span><br><span class="line">   +IsFromAccountActor() : bool</span><br><span class="line">    // 合约中交易信息</span><br><span class="line">   +Message() : *types.Message</span><br><span class="line">    // 执行合约函数</span><br><span class="line">   +Send(to address.Address, method string, value *types.AttoFIL, params []interface&#123;&#125;) : [][]byte, uint8, error</span><br><span class="line">   +Storage() : Storage</span><br><span class="line">    // 当Storage接口完成会删除如下两项</span><br><span class="line">   +ReadStorage() : []byte, error</span><br><span class="line">   +WriteStorage(interface&#123;&#125;) : error</span><br></pre></td></tr></table></figure><h2 id="actor的类型及源码分析"><a href="#actor的类型及源码分析" class="headerlink" title="actor的类型及源码分析"></a>actor的类型及源码分析</h2><ul><li>actor包定义及实现了基础actor,此外filecoin还定义了四种内置的actor类型<ul><li>存储市场actor,此类actor整个网络只有一个实例，用于创建存储矿工、更新功率表、获取总存储容量</li><li>Miner actor,此类actor整个网络只有多个实例（随用户数增加而增加），用于执行矿工相关的操作</li><li>paymentbroker actor,此类actor整个网络只有一个实例，用于创建支付通道以及支付相关信息</li><li>account actor,账户actor,此类actor整个网络只有多个实例（随用户数增加而增加），只能用于基本的转账操作</li></ul></li></ul><p>###　基础actor包</p><ul><li>说明<ul><li>定义了actor的基础结构,其中code如果使用内置的如上四种actor，他们的值都是固定的</li><li>提供了actor的基础操作方法</li><li>见笔者在代码中的注释</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">location: actor/actor.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    actor</span><br><span class="line"></span><br><span class="line">    // Actor可以理解为合约或者账户，转账操作要检查code cid合法性</span><br><span class="line">▼+Actor : struct</span><br><span class="line">    [fields]</span><br><span class="line">    //余额</span><br><span class="line">   +Balance : *types.AttoFIL</span><br><span class="line"></span><br><span class="line">    // 合约代码的cid，vm具体执行其对应的代码</span><br><span class="line">    // 1 具体代码的cid</span><br><span class="line">    // 2 在go语言实现的四种特定合约，这个字段是常量，比如account,miner,storagemarket,paymentbroker</span><br><span class="line">   +Code : cid.Cid</span><br><span class="line"></span><br><span class="line">    //　合约状态的最新状态</span><br><span class="line">   +Head : cid.Cid</span><br><span class="line"></span><br><span class="line">    // 防止重放攻击而设置的参数</span><br><span class="line">   +Nonce : types.Uint64</span><br><span class="line"></span><br><span class="line">    [methods]</span><br><span class="line">    // 计算actor的cid</span><br><span class="line">   +Cid() : cid.Cid, error</span><br><span class="line"></span><br><span class="line">    // 打印合约信息</span><br><span class="line">   +Format(f fmt.State, c rune)</span><br><span class="line"></span><br><span class="line">    // 增加Nonce+1方法</span><br><span class="line">   +IncNonce()</span><br><span class="line"></span><br><span class="line">    // 编码</span><br><span class="line">   +Marshal() : []byte, error</span><br><span class="line"></span><br><span class="line">    // 解码</span><br><span class="line">   +Unmarshal(b []byte) : error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewActor(code cid.Cid, balance *types.AttoFIL) : *Actor</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 只有account类型的actor使用</span><br><span class="line">   +NextNonce(actor *Actor) : uint64, error</span><br><span class="line">   -init()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location: actor/export.go</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 返回某个actor的方法执行函数</span><br><span class="line">   +MakeTypedExport(actor exec.ExecutableActor, method string) : exec.ExportedFunc</span><br><span class="line"></span><br><span class="line">   //　序列化成字节切片</span><br><span class="line">   +MarshalValue(val interface&#123;&#125;) : []byte, error</span><br></pre></td></tr></table></figure><h3 id="storagemarket-actor"><a href="#storagemarket-actor" class="headerlink" title="storagemarket actor"></a>storagemarket actor</h3><ul><li>主要功能<ul><li>创建存储矿工</li><li>获取总存储量</li><li>更新功率</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    storagemarket</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">   +ErrInsufficientCollateral</span><br><span class="line">   +ErrPledgeTooLow</span><br><span class="line">   +ErrUnknownMiner</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   +Errors</span><br><span class="line">   +MinimumCollateralPerSector</span><br><span class="line">   +MinimumPledge</span><br><span class="line">   -storageMarketExports</span><br><span class="line"></span><br><span class="line">▼+Actor : struct</span><br><span class="line">    [methods]</span><br><span class="line">    // 创建存储矿工</span><br><span class="line">    // 会调用到miner actor的创建</span><br><span class="line">   +CreateMiner(vmctx exec.VMContext, pledge *big.Int, publicKey []byte, pid peer.ID) : address.Address, uint8, error</span><br><span class="line">   +Exports() : exec.Exports</span><br><span class="line">    // 获取总存储</span><br><span class="line">   +GetTotalStorage(vmctx exec.VMContext) : *big.Int, uint8, error</span><br><span class="line">   +InitializeState(storage exec.Storage, _ interface&#123;&#125;) : error</span><br><span class="line">    // 更新功率</span><br><span class="line">   +UpdatePower(vmctx exec.VMContext, delta *big.Int) : uint8, error</span><br><span class="line"></span><br><span class="line">▼+State : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // miners合集的cid</span><br><span class="line">   +Miners : cid.Cid</span><br><span class="line">   +TotalCommittedStorage : *big.Int</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   +MinimumCollateral(sectors *big.Int) : *types.AttoFIL</span><br><span class="line">    // 实例化存储市场</span><br><span class="line">   +NewActor() : *actor.Actor, error</span><br><span class="line">   -init()</span><br></pre></td></tr></table></figure><h3 id="miner-actor"><a href="#miner-actor" class="headerlink" title="miner actor"></a>miner actor</h3><ul><li>提供功能<ul><li>有基本转账功能 </li><li>提供如下功能</li><li>filecoin网络中存在多个Miner Actor</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    miner</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">   +ErrAskNotFound</span><br><span class="line">   +ErrCallerUnauthorized</span><br><span class="line">   +ErrInsufficientPledge</span><br><span class="line">   +ErrInvalidPoSt</span><br><span class="line">   +ErrInvalidSealProof</span><br><span class="line">   +ErrInvalidSector</span><br><span class="line">   +ErrPublicKeyTooBig</span><br><span class="line">   +ErrSectorCommitted</span><br><span class="line">   +ErrStoragemarketCallFailed</span><br><span class="line">   +MaximumPublicKeySize</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   +Errors</span><br><span class="line">   +GracePeriodBlocks</span><br><span class="line">   +ProvingPeriodBlocks</span><br><span class="line">   -minerExports</span><br><span class="line"></span><br><span class="line">▼+Actor : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Bootstrap : bool</span><br><span class="line">    [methods]</span><br><span class="line">    // 增加订单</span><br><span class="line">   +AddAsk(ctx exec.VMContext, price *types.AttoFIL, expiry *big.Int) : *big.Int, uint8, error</span><br><span class="line">    // 抵押承诺</span><br><span class="line">   +CommitSector(ctx exec.VMContext, sectorID uint64, commD, commR, commRStar, proof []byte) : uint8, error</span><br><span class="line">   +Exports() : exec.Exports</span><br><span class="line">    // 获取存储矿工相关信息</span><br><span class="line">   +GetAsk(ctx exec.VMContext, askid *big.Int) : []byte, uint8, error</span><br><span class="line">   +GetAsks(ctx exec.VMContext) : []uint64, uint8, error</span><br><span class="line">   +GetKey(ctx exec.VMContext) : []byte, uint8, error</span><br><span class="line">   +GetLastUsedSectorID(ctx exec.VMContext) : uint64, uint8, error</span><br><span class="line">   +GetOwner(ctx exec.VMContext) : address.Address, uint8, error</span><br><span class="line">   +GetPeerID(ctx exec.VMContext) : peer.ID, uint8, error</span><br><span class="line">   +GetPledge(ctx exec.VMContext) : *big.Int, uint8, error</span><br><span class="line">   +GetPower(ctx exec.VMContext) : *big.Int, uint8, error</span><br><span class="line">   +GetProvingPeriodStart(ctx exec.VMContext) : *types.BlockHeight, uint8, error</span><br><span class="line">   +GetSectorCommitments(ctx exec.VMContext) : map[string]types.Commitments, uint8, error</span><br><span class="line">   +InitializeState(storage exec.Storage, initializerData interface&#123;&#125;) : error</span><br><span class="line">    // 提交时空证明</span><br><span class="line">   +SubmitPoSt(ctx exec.VMContext, postProofs []proofs.PoStProof) : uint8, error</span><br><span class="line">    // 更新节点Id</span><br><span class="line">   +UpdatePeerID(ctx exec.VMContext, pid peer.ID) : uint8, error</span><br><span class="line"></span><br><span class="line">    // 报价单：价格，时长，序号</span><br><span class="line">▼+Ask : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Expiry : *types.BlockHeight</span><br><span class="line">   +ID : *big.Int</span><br><span class="line">   +Price : *types.AttoFIL</span><br><span class="line"></span><br><span class="line">    // 矿工Actor状态</span><br><span class="line">▼+State : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Asks : []*Ask</span><br><span class="line">   +Collateral : *types.AttoFIL</span><br><span class="line">   +LastPoSt : *types.BlockHeight</span><br><span class="line">   +LastUsedSectorID : uint64</span><br><span class="line">   +NextAskID : *big.Int</span><br><span class="line">   +Owner : address.Address</span><br><span class="line">   +PeerID : peer.ID</span><br><span class="line">   +PledgeSectors : *big.Int</span><br><span class="line">   +Power : *big.Int</span><br><span class="line">   +ProvingPeriodStart : *types.BlockHeight</span><br><span class="line">   +PublicKey : []byte</span><br><span class="line">   +SectorCommitments : map[string]types.Commitments</span><br><span class="line">    [functions]</span><br><span class="line">   +NewState(owner address.Address, key []byte, pledge *big.Int, pid peer.ID, collateral *types.AttoFIL) : *State</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   +NewActor() : *actor.Actor</span><br><span class="line">   -init()</span><br></pre></td></tr></table></figure><h3 id="paymentbroker-actor"><a href="#paymentbroker-actor" class="headerlink" title="paymentbroker actor"></a>paymentbroker actor</h3><ul><li>说明<ul><li>全网只有一个paymentbroker</li><li>几个概念的关系简图</li></ul></li></ul><p><img src="https://img.learnblockchain.cn/2019/payment.png!wl" alt=""></p><ul><li>源码分析注释<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    paymentbroker</span><br><span class="line"></span><br><span class="line">▼+Actor : struct</span><br><span class="line">    [methods]</span><br><span class="line">    // 关闭支付通道</span><br><span class="line">   +Close(vmctx exec.VMContext, payer address.Address, chid *types.ChannelID, amt *types.AttoFIL, validAt *types.BlockHeight, sig []byte) : uint8, error</span><br><span class="line">    // 创建支付通道</span><br><span class="line">   +CreateChannel(vmctx exec.VMContext, target address.Address, eol *types.BlockHeight) : *types.ChannelID, uint8, error</span><br><span class="line">   +Exports() : exec.Exports</span><br><span class="line">    // 增加资金</span><br><span class="line">   +Extend(vmctx exec.VMContext, chid *types.ChannelID, eol *types.BlockHeight) : uint8, error</span><br><span class="line">   +InitializeState(storage exec.Storage, initializerData interface&#123;&#125;) : error</span><br><span class="line">    // 查询某个支付者的信息</span><br><span class="line">   +Ls(vmctx exec.VMContext, payer address.Address) : []byte, uint8, error</span><br><span class="line">    // 撤回资金</span><br><span class="line">   +Reclaim(vmctx exec.VMContext, chid *types.ChannelID) : uint8, error</span><br><span class="line">    // 赎回(或者收款)资金</span><br><span class="line">   +Redeem(vmctx exec.VMContext, payer address.Address, chid *types.ChannelID, amt *types.AttoFIL, validAt *types.BlockHeight, sig []byte) : uint8, error</span><br><span class="line">    // 收据，指明在特定区块高度之前都是有效的</span><br><span class="line">   +Voucher(vmctx exec.VMContext, chid *types.ChannelID, amount *types.AttoFIL, validAt *types.BlockHeight) : []byte, uint8, error</span><br><span class="line"></span><br><span class="line">▼+PaymentChannel : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 支付通道内金额</span><br><span class="line">   +Amount : *types.AttoFIL</span><br><span class="line">    // 已被赎回金额</span><br><span class="line">   +AmountRedeemed : *types.AttoFIL</span><br><span class="line">   +Eol : *types.BlockHeight</span><br><span class="line">    // 收款人地址</span><br><span class="line">   +Target : address.Address</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 收据的签名及校验</span><br><span class="line">   +SignVoucher(channelID *types.ChannelID, amount *types.AttoFIL, validAt *types.BlockHeight, addr address.Address, signer types.Signer) : types.Signature, error</span><br><span class="line">   +VerifyVoucherSignature(payer address.Address, chid *types.ChannelID, amt *types.AttoFIL, validAt *types.BlockHeight, sig []byte) : bool</span><br><span class="line">   -createVoucherSignatureData(channelID *types.ChannelID, amount *types.AttoFIL, validAt *types.BlockHeight) : []byte</span><br><span class="line">   -findByChannelLookup(ctx context.Context, storage exec.Storage, byPayer exec.Lookup, payer address.Address) : exec.Lookup, error</span><br><span class="line">   -init()</span><br><span class="line">   -reclaim(ctx context.Context, vmctx exec.VMContext, byChannelID exec.Lookup, payer address.Address, chid *types.ChannelID, channel *PaymentChannel) : error</span><br><span class="line">   -updateChannel(ctx exec.VMContext, target address.Address, channel *PaymentChannel, amt *types.AttoFIL, validAt *types.BlockHeight) : error</span><br><span class="line">   -withPayerChannels(ctx context.Context, storage exec.Storage, payer address.Address, f func(exec.Lookup) error) : error</span><br><span class="line">   -withPayerChannelsForReading(ctx context.Context, storage exec.Storage, payer address.Address, f func(exec.Lookup) error) : error</span><br></pre></td></tr></table></figure></li></ul><h3 id="account-actor"><a href="#account-actor" class="headerlink" title="account actor"></a>account actor</h3><ul><li>说明<ul><li>纯账户，记录nonce</li><li>只有转帐功能</li><li>filecoin网络中存在多个account Actor</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    account</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   -accountExports</span><br><span class="line"></span><br><span class="line">▼+Actor : struct</span><br><span class="line">    [methods]</span><br><span class="line">   +Exports() : exec.Exports</span><br><span class="line">   +InitializeState(_ exec.Storage, _ interface&#123;&#125;) : error</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 实例化account actor 集成actor包中Actor所实现的所有方法</span><br><span class="line">   +NewActor(balance *types.AttoFIL) : *actor.Actor, error</span><br><span class="line">    // 将其他actor类型转为account，保留余额</span><br><span class="line">   +UpgradeActor(act *actor.Actor) : error</span><br></pre></td></tr></table></figure><h2 id="vm-虚拟机运行环境"><a href="#vm-虚拟机运行环境" class="headerlink" title="vm(虚拟机运行环境)"></a>vm(虚拟机运行环境)</h2><ul><li>虚拟机执行函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    vm</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼-sendDeps : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -transfer : func(*actor.Actor, *actor.Actor, *types.AttoFIL) error</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 执行合约</span><br><span class="line">   +Send(ctx context.Context, vmCtx *Context) : [][]byte, uint8, error</span><br><span class="line">    // 转账</span><br><span class="line">   +Transfer(fromActor, toActor *actor.Actor, value *types.AttoFIL) : error</span><br><span class="line">   -send(ctx context.Context, deps sendDeps, vmCtx *Context) : [][]byte, uint8, error</span><br></pre></td></tr></table></figure><ul><li>vm环境实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">▼+Context : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -ancestors : []types.TipSet</span><br><span class="line">   -blockHeight : *types.BlockHeight</span><br><span class="line">   -deps : *deps</span><br><span class="line">   -from : *actor.Actor</span><br><span class="line">   -gasTracker : *GasTracker</span><br><span class="line">   -lookBack : int</span><br><span class="line">   -message : *types.Message</span><br><span class="line">   -state : *state.CachedTree</span><br><span class="line">   -storageMap : StorageMap</span><br><span class="line">   -to : *actor.Actor</span><br><span class="line">    [methods]</span><br><span class="line">    // 实现上述VMContext 接口，注释见上</span><br><span class="line">   +AddressForNewActor() : address.Address, error</span><br><span class="line">   +BlockHeight() : *types.BlockHeight</span><br><span class="line">   +Charge(cost types.GasUnits) : error</span><br><span class="line">   +CreateNewActor(addr address.Address, code cid.Cid, initializerData interface&#123;&#125;) : error</span><br><span class="line">   +GasUnits() : types.GasUnits</span><br><span class="line">   +IsFromAccountActor() : bool</span><br><span class="line">   +Message() : *types.Message</span><br><span class="line">   +Rand(sampleHeight *types.BlockHeight) : []byte, error</span><br><span class="line">   +ReadStorage() : []byte, error</span><br><span class="line">   +Send(to address.Address, method string, value *types.AttoFIL, params []interface&#123;&#125;) : [][]byte, uint8, error</span><br><span class="line">   +Storage() : exec.Storage</span><br><span class="line">   +WriteStorage(memory interface&#123;&#125;) : error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewVMContext(params NewContextParams) : *Context</span><br><span class="line"></span><br><span class="line">▼+NewContextParams : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Ancestors : []types.TipSet</span><br><span class="line">   +BlockHeight : *types.BlockHeight</span><br><span class="line">   +From : *actor.Actor</span><br><span class="line">   +GasTracker : *GasTracker</span><br><span class="line">   +LookBack : int</span><br><span class="line">   +Message : *types.Message</span><br><span class="line">   +State : *state.CachedTree</span><br><span class="line">   +StorageMap : StorageMap</span><br><span class="line">   +To : *actor.Actor</span><br><span class="line"></span><br><span class="line">▼-deps : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +EncodeValues : func([]*abi.Value) []byte, error</span><br><span class="line">   +GetOrCreateActor : func(context.Context, address.Address, func() *actor.Actor, error) *actor.Actor, error</span><br><span class="line">   +Send : func(context.Context, *Context) [][]byte, uint8, error</span><br><span class="line">   +ToValues : func([]interface&#123;&#125;) []*abi.Value, error</span><br><span class="line"></span><br><span class="line">▼ deps* : ctype</span><br><span class="line">    [functions]</span><br><span class="line">   -makeDeps(st *state.CachedTree) : *deps</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   -computeActorAddress(creator address.Address, nonce uint64) : address.Address, error</span><br></pre></td></tr></table></figure><ul><li>合约状态存储</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">▼+Storage : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -actor : *actor.Actor</span><br><span class="line">   -blockstore : blockstore.Blockstore</span><br><span class="line">   -chunks : map[cid.Cid]ipld.Node</span><br><span class="line">    [methods]</span><br><span class="line">   +Commit(newCid cid.Cid, oldCid cid.Cid) : error</span><br><span class="line">   +Flush() : error</span><br><span class="line">   +Get(cid cid.Cid) : []byte, error</span><br><span class="line">   +Head() : cid.Cid</span><br><span class="line">   +Prune() : error</span><br><span class="line">   +Put(v interface&#123;&#125;) : cid.Cid, error</span><br><span class="line">   -liveDescendantIds(id cid.Cid) : *cid.Set, error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewStorage(bs blockstore.Blockstore, act *actor.Actor) : Storage</span><br><span class="line"></span><br><span class="line">▼-storageMap : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -blockstore : blockstore.Blockstore</span><br><span class="line">   -storageMap : map[address.Address]Storage</span><br><span class="line">    [methods]</span><br><span class="line">   +Flush() : error</span><br><span class="line">   +NewStorage(addr address.Address, actor *actor.Actor) : Storage</span><br><span class="line"></span><br><span class="line">▼+StorageMap : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Flush() : error</span><br><span class="line">   +NewStorage(addr address.Address, actor *actor.Actor) : Storage</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   +NewStorageMap(bs blockstore.Blockstore) : StorageMap</span><br></pre></td></tr></table></figure><h2 id="state包-actor状态"><a href="#state包-actor状态" class="headerlink" title="state包(actor状态)"></a>state包(actor状态)</h2><ul><li>表征actor的状态</li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是先河系统CTO杨尉，欢迎大加关注的的Github: &lt;a href=&quot;https://github.com/waynewyang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;waynewyang&lt;/a&gt;，本文是&lt;a href=&quot;https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/&quot;&gt;filecoin技术架构分析系列文章&lt;/a&gt;第十三章源码分析之服务层actor及vm。&lt;/p&gt;
    
    </summary>
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/categories/FileCoin/"/>
    
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/tags/FileCoin/"/>
    
  </entry>
  
  <entry>
    <title>filecoin技术架构分析之十二：filecoin源码分析之内部接口层plumbing＆porcelain接口</title>
    <link href="https://learnblockchain.cn/2019/03/07/filecoin-code-analysis-12/"/>
    <id>https://learnblockchain.cn/2019/03/07/filecoin-code-analysis-12/</id>
    <published>2019-03-07T10:35:33.000Z</published>
    <updated>2019-04-05T10:29:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>我是先河系统CTO杨尉，欢迎大加关注的的Github: <a href="https://github.com/waynewyang" target="_blank" rel="noopener">waynewyang</a>，本文是<a href="https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/">filecoin技术架构分析系列文章</a>第十二章源码分析之内部接口层plumbing＆porcelain接口。</p><a id="more"></a><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><p>目前官方正在将api包解耦，往plumbing、porcelain中迁移</p><ul><li>缘由: 原来的api包，依赖于node包，而node包应该属于api之上的，这导致代码耦合性大</li><li>node作为一个上帝对象，被api包依赖，对架构扩展性，其他类型节点扩展开发不利</li><li>就在笔者写这篇文章的同时，官方应该还在继续迁移，后面api包会逐步都迁移完</li></ul></li><li><p>porcelain主要依赖于plumbing接口</p></li><li><p>上一章所述的api包将会被废除</p></li></ul><h2 id="plumbing＆porcelain模式简述"><a href="#plumbing＆porcelain模式简述" class="headerlink" title="plumbing＆porcelain模式简述"></a>plumbing＆porcelain模式简述</h2><ul><li>该模式是借鉴git的思路，提供两种接口，porcelain偏高层面对用户更加友好方便；plumbing偏底层，友好度弱于porcelain</li><li>porcelain是英文瓷器的意思,类似洗手盆之类；plumbing是水管装置的意思，类似下水管,用户当然直接用洗手盆省心，不用管水管的事情</li><li>用户级更偏向用porcelain，协议级更偏向使用plumbing，</li></ul><h2 id="plumbing底层接口"><a href="#plumbing底层接口" class="headerlink" title="plumbing底层接口"></a>plumbing底层接口</h2><ul><li><p>说明</p><ul><li>plumbing底层接口是为实现协议以及面向网络的必须最小实现</li><li>更应用级别的调用更多将会调用到porcelain高层接口</li></ul></li><li><p>提供的具体功能接口</p><ul><li>区块状态读取</li><li>配置信息</li><li>日志</li><li>消息池操作</li><li>消息预览，Gas计算</li><li>消息查询</li><li>消息发送</li><li>消息等待</li><li>网络操作</li><li>Chain状态获取（actor信息）</li><li>钱包底层操作</li></ul></li><li><p>具体的方法如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    plumbing</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+API : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -chain : chain.ReadStore</span><br><span class="line">   -config : *cfg.Config</span><br><span class="line">   -logger : logging.EventLogger</span><br><span class="line">   -msgPool : *core.MessagePool</span><br><span class="line">   -msgPreviewer : *msg.Previewer</span><br><span class="line">   -msgQueryer : *msg.Queryer</span><br><span class="line">   -msgSender : *msg.Sender</span><br><span class="line">   -msgWaiter : *msg.Waiter</span><br><span class="line">   -network : *ntwk.Network</span><br><span class="line">   -sigGetter : *mthdsig.Getter</span><br><span class="line">   -wallet : *wallet.Wallet</span><br><span class="line">    [methods]</span><br><span class="line">   +ActorGet(ctx context.Context, addr address.Address) : *actor.Actor, error</span><br><span class="line">   +ActorGetSignature(ctx context.Context, actorAddr address.Address, method string) : *exec.FunctionSignature, error</span><br><span class="line">   +BlockGet(ctx context.Context, id cid.Cid) : *types.Block, error</span><br><span class="line">   +ChainHead(ctx context.Context) : types.TipSet</span><br><span class="line">   +ChainLs(ctx context.Context) : chan interface&#123;&#125;</span><br><span class="line">   +ConfigGet(dottedPath string) : interface&#123;&#125;, error</span><br><span class="line">   +ConfigSet(dottedPath string, paramJSON string) : error</span><br><span class="line">   +MessagePoolGet(cid cid.Cid) : *types.SignedMessage, bool</span><br><span class="line">   +MessagePoolPending() : []*types.SignedMessage</span><br><span class="line">   +MessagePoolRemove(cid cid.Cid)</span><br><span class="line">   +MessagePreview(ctx context.Context, from, to address.Address, method string, params ...interface&#123;&#125;) : types.GasUnits, error</span><br><span class="line">   +MessageQuery(ctx context.Context, optFrom, to address.Address, method string, params ...interface&#123;&#125;) : [][]byte, *exec.FunctionSignature, error</span><br><span class="line">   +MessageSend(ctx context.Context, from, to address.Address, value *types.AttoFIL, gasPrice types.AttoFIL, gasLimit types.GasUnits, method string, params ...interface&#123;&#125;) : cid.Cid, error</span><br><span class="line">   +MessageWait(ctx context.Context, msgCid cid.Cid, cb func(*types.Block, *types.SignedMessage, *types.MessageReceipt) error) : error</span><br><span class="line">   +NetworkFindProvidersAsync(ctx context.Context, key cid.Cid, count int) : chan pstore.PeerInfo</span><br><span class="line">   +NetworkGetPeerID() : peer.ID</span><br><span class="line">   +PubSubPublish(topic string, data []byte) : error</span><br><span class="line">   +PubSubSubscribe(topic string) : pubsub.Subscription, error</span><br><span class="line">   +SignBytes(data []byte, addr address.Address) : types.Signature, error</span><br><span class="line">   +WalletAddresses() : []address.Address</span><br><span class="line">   +WalletFind(address address.Address) : wallet.Backend, error</span><br><span class="line">   +WalletNewAddress() : address.Address, error</span><br><span class="line">    [functions]</span><br><span class="line">   +New(deps *APIDeps) : *API</span><br></pre></td></tr></table></figure><h2 id="porcelain高层接口"><a href="#porcelain高层接口" class="headerlink" title="porcelain高层接口"></a>porcelain高层接口</h2><ul><li><p>说明</p><ul><li>porcelain主要依赖plumbing实现。</li><li>主要是面向用户级操作</li></ul></li><li><p>提供功能</p><ul><li>获取区块高度</li><li>建立支付通道/多支付通道</li><li>获取默认地址</li><li>消息池等待未被打包进区块的消息</li><li>采用默认地址发送消息</li><li>获取指定矿工报价单</li><li>获取矿工Owner地址</li><li>获取矿工节点ID</li><li>创建矿工，预览Gas消耗</li><li>矿工报价，预览Gas消耗</li><li>矿工报价</li><li>获取签名支付凭证</li><li>钱包余额查询</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    porcelain</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+API : struct</span><br><span class="line">    [embedded]</span><br><span class="line">   +*plumbing.API : *plumbing.API</span><br><span class="line">    [methods]</span><br><span class="line">   +ChainBlockHeight(ctx context.Context) : *types.BlockHeight, error</span><br><span class="line">   +CreatePayments(ctx context.Context, config CreatePaymentsParams) : *CreatePaymentsReturn, error</span><br><span class="line">   +GetAndMaybeSetDefaultSenderAddress() : address.Address, error</span><br><span class="line">   +MessagePoolWait(ctx context.Context, messageCount uint) : []*types.SignedMessage, error</span><br><span class="line">   +MessageSendWithDefaultAddress(ctx context.Context, from, to address.Address, value *types.AttoFIL, gasPrice types.AttoFIL, gasLimit types.GasUnits, method string, params ...interface&#123;&#125;) : cid.Cid, error</span><br><span class="line">   +MinerGetAsk(ctx context.Context, minerAddr address.Address, askID uint64) : minerActor.Ask, error</span><br><span class="line">   +MinerGetOwnerAddress(ctx context.Context, minerAddr address.Address) : address.Address, error</span><br><span class="line">   +MinerGetPeerID(ctx context.Context, minerAddr address.Address) : peer.ID, error</span><br><span class="line">   +MinerPreviewCreate(ctx context.Context, fromAddr address.Address, pledge uint64, pid peer.ID, collateral *types.AttoFIL) : types.GasUnits, error</span><br><span class="line">   +MinerPreviewSetPrice(ctx context.Context, from address.Address, miner address.Address, price *types.AttoFIL, expiry *big.Int) : types.GasUnits, error</span><br><span class="line">   +MinerSetPrice(ctx context.Context, from address.Address, miner address.Address, gasPrice types.AttoFIL, gasLimit types.GasUnits, price *types.AttoFIL, expiry *big.Int) : MinerSetPriceResponse, error</span><br><span class="line">   +PaymentChannelLs(ctx context.Context, fromAddr address.Address, payerAddr address.Address) : map[string]*paymentbroker.PaymentChannel, error</span><br><span class="line">   +PaymentChannelVoucher(ctx context.Context, fromAddr address.Address, channel *types.ChannelID, amount *types.AttoFIL, validAt *types.BlockHeight) : *paymentbroker.PaymentVoucher, error</span><br><span class="line">   +WalletBalance(ctx context.Context, address address.Address) : *types.AttoFIL, error</span><br><span class="line">    [functions]</span><br><span class="line">   +New(plumbing *plumbing.API) : *API</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是先河系统CTO杨尉，欢迎大加关注的的Github: &lt;a href=&quot;https://github.com/waynewyang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;waynewyang&lt;/a&gt;，本文是&lt;a href=&quot;https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/&quot;&gt;filecoin技术架构分析系列文章&lt;/a&gt;第十二章源码分析之内部接口层plumbing＆porcelain接口。&lt;/p&gt;
    
    </summary>
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/categories/FileCoin/"/>
    
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/tags/FileCoin/"/>
    
  </entry>
  
  <entry>
    <title>filecoin技术架构分析十一：filecoin源码分析之内部接口层api包分析</title>
    <link href="https://learnblockchain.cn/2019/03/07/filecoin-code-analysis-11/"/>
    <id>https://learnblockchain.cn/2019/03/07/filecoin-code-analysis-11/</id>
    <published>2019-03-07T09:35:33.000Z</published>
    <updated>2019-04-05T10:29:31.001Z</updated>
    
    <content type="html"><![CDATA[<p>我是先河系统CTO杨尉，欢迎大加关注的的Github: <a href="https://github.com/waynewyang" target="_blank" rel="noopener">waynewyang</a>，本文是<a href="https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/">filecoin技术架构分析系列文章</a>第十一章源码分析之内部接口层api包分析。</p><a id="more"></a><blockquote><p>api包提供内部接口,供协议层、command/REST使用</p><p>较大程度依赖node包</p></blockquote><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="api的接口定义"><a href="#api的接口定义" class="headerlink" title="api的接口定义"></a>api的接口定义</h3><blockquote><p>如下所示，包含了一系列子接口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type API interface &#123;</span><br><span class="line">Actor() Actor</span><br><span class="line">Address() Address</span><br><span class="line">Client() Client</span><br><span class="line">Daemon() Daemon</span><br><span class="line">Dag() Dag</span><br><span class="line">ID() ID</span><br><span class="line">Log() Log</span><br><span class="line">Miner() Miner</span><br><span class="line">Mining() Mining</span><br><span class="line">Paych() Paych</span><br><span class="line">Ping() Ping</span><br><span class="line">RetrievalClient() RetrievalClient</span><br><span class="line">Swarm() Swarm</span><br><span class="line">Version() Version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="api的接口实现"><a href="#api的接口实现" class="headerlink" title="api的接口实现"></a>api的接口实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    impl</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">// nodeAPI来实现其接口定义</span><br><span class="line">▼-nodeAPI : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 合约</span><br><span class="line">   -actor : *nodeActor</span><br><span class="line">    // 地址</span><br><span class="line">   -address : *nodeAddress</span><br><span class="line">    // 客户端</span><br><span class="line">   -client : *nodeClient</span><br><span class="line">    // daemon</span><br><span class="line">   -daemon : *nodeDaemon</span><br><span class="line">    // dag</span><br><span class="line">   -dag : *nodeDag</span><br><span class="line">    // 节点ID</span><br><span class="line">   -id : *nodeID</span><br><span class="line">    // 日志</span><br><span class="line">   -log : *nodeLog</span><br><span class="line">    // 日志</span><br><span class="line">   -logger : logging.EventLogger</span><br><span class="line">    // 矿工</span><br><span class="line">   -miner : *nodeMiner</span><br><span class="line">    // 挖矿</span><br><span class="line">   -mining : *nodeMining</span><br><span class="line">    // 节点</span><br><span class="line">   -node : *node.Node</span><br><span class="line">    // 支付通道</span><br><span class="line">   -paych : *nodePaych</span><br><span class="line">    // ping</span><br><span class="line">   -ping : *nodePing</span><br><span class="line">    // 检索客户端</span><br><span class="line">   -retrievalClient : *nodeRetrievalClient</span><br><span class="line">    // swarm</span><br><span class="line">   -swarm : *nodeSwarm</span><br><span class="line">    // 版本</span><br><span class="line">   -version : *nodeVersion</span><br><span class="line"></span><br><span class="line">    [methods]</span><br><span class="line">    // 如下为实现API接口</span><br><span class="line">   +Actor() : api.Actor</span><br><span class="line">   +Address() : api.Address</span><br><span class="line">   +Client() : api.Client</span><br><span class="line">   +Daemon() : api.Daemon</span><br><span class="line">   +Dag() : api.Dag</span><br><span class="line">   +ID() : api.ID</span><br><span class="line">   +Log() : api.Log</span><br><span class="line">   +Miner() : api.Miner</span><br><span class="line">   +Mining() : api.Mining</span><br><span class="line">   +Paych() : api.Paych</span><br><span class="line">   +Ping() : api.Ping</span><br><span class="line">   +RetrievalClient() : api.RetrievalClient</span><br><span class="line">   +Swarm() : api.Swarm</span><br><span class="line">   +Version() : api.Version</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 实例化API</span><br><span class="line">    // 1 获取高层API porcelainAPI 指针,miner与paych有用到</span><br><span class="line">    // 2 调用各子系统的实例化函数逐一实例化</span><br><span class="line">   +New(node *node.Node) : api.API</span><br></pre></td></tr></table></figure><h2 id="actor"><a href="#actor" class="headerlink" title="actor"></a>actor</h2><h3 id="actor的接口定义"><a href="#actor的接口定义" class="headerlink" title="actor的接口定义"></a>actor的接口定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    api</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+ActorView : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // actor类型</span><br><span class="line">   +ActorType : string</span><br><span class="line">    // actor地址</span><br><span class="line">   +Address : string</span><br><span class="line">    // actor余额</span><br><span class="line">   +Balance : *types.AttoFIL</span><br><span class="line">    // actor代码-CID</span><br><span class="line">   +Code : cid.Cid</span><br><span class="line">    // 导出符号集合</span><br><span class="line">   +Exports : ReadableExports</span><br><span class="line">    // 表征actor实例的状态</span><br><span class="line">   +Head : cid.Cid</span><br><span class="line">    // 消息计数器，仅为account actors与外部发生交互的时候计算</span><br><span class="line">   +Nonce : uint64</span><br><span class="line"></span><br><span class="line">    // 导出符号集合</span><br><span class="line"> +ReadableExports : map[string]*ReadableFunctionSignature</span><br><span class="line"></span><br><span class="line">▼+ReadableFunctionSignature : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 参数</span><br><span class="line">   +Params : []string</span><br><span class="line">    // 返回</span><br><span class="line">   +Return : []string</span><br><span class="line"></span><br><span class="line">▼+Actor : interface</span><br><span class="line">    // 目前接口只有查看功能,返回合约的具体信息</span><br><span class="line">    [methods]</span><br><span class="line">   +Ls(ctx context.Context) : []*ActorView, error</span><br></pre></td></tr></table></figure><h3 id="actor的接口实现"><a href="#actor的接口实现" class="headerlink" title="actor的接口实现"></a>actor的接口实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    impl</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">// 使用nodeActor来实现Actor接口</span><br><span class="line">▼-nodeActor : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -api : *nodeAPI</span><br><span class="line">    [methods]</span><br><span class="line">    // 调用ls方法实现查询功能</span><br><span class="line">   +Ls(ctx context.Context) : []*api.ActorView, error</span><br><span class="line">    [functions]</span><br><span class="line">    // 实例化nodeActor，由api实现代码中调用</span><br><span class="line">   -newNodeActor(api *nodeAPI) : *nodeActor</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 获取合约类型</span><br><span class="line">    // 1 account actor</span><br><span class="line">    // 2 存储市场actor</span><br><span class="line">    // 3 支付通道actor</span><br><span class="line">    // 4 矿工actor</span><br><span class="line">    // 4 BootstrapMiner actor</span><br><span class="line">   -getActorType(actType exec.ExecutableActor) : string</span><br><span class="line">    // 查询合约状态</span><br><span class="line">   -ls(ctx context.Context, fcn *node.Node, actorGetter state.GetAllActorsFunc) : []*api.ActorView, error</span><br><span class="line">   -makeActorView(act *actor.Actor, addr string, actType exec.ExecutableActor) : *api.ActorView</span><br><span class="line">   -makeReadable(f *exec.FunctionSignature) : *api.ReadableFunctionSignature</span><br><span class="line">   -presentExports(e exec.Exports) : api.ReadableExports</span><br></pre></td></tr></table></figure><h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><ul><li>提供功能<ul><li>地址显示方法</li><li>地址查找方法</li><li>创建地址方法</li><li>导出地址方法</li><li>导入地址方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    api</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+Address : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Addrs() : Addrs</span><br><span class="line">   +Export(ctx context.Context, addrs []address.Address) : []*types.KeyInfo, error</span><br><span class="line">   +Import(ctx context.Context, f files.File) : []address.Address, error</span><br><span class="line"></span><br><span class="line">▼+Addrs : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Lookup(ctx context.Context, addr address.Address) : peer.ID, error</span><br><span class="line">   +Ls(ctx context.Context) : []address.Address, error</span><br><span class="line">   +New(ctx context.Context) : address.Address, error</span><br></pre></td></tr></table></figure><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><ul><li>提供如下功能<ul><li>查询piece数据（DAG格式）</li><li>导入数据（相当于ipfs add）</li><li>列出所有订单</li><li>支付</li><li>发起存储交易</li><li>查询存储交易</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">▼+Ask : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Error : error</span><br><span class="line">   +Expiry : *types.BlockHeight</span><br><span class="line">   +ID : uint64</span><br><span class="line">   +Miner : address.Address</span><br><span class="line">   +Price : *types.AttoFIL</span><br><span class="line"></span><br><span class="line">▼+Client : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Cat(ctx context.Context, c cid.Cid) : uio.DagReader, error</span><br><span class="line">   +ImportData(ctx context.Context, data io.Reader) : ipld.Node, error</span><br><span class="line">   +ListAsks(ctx context.Context) : chan Ask, error</span><br><span class="line">   +Payments(ctx context.Context, dealCid cid.Cid) : []*paymentbroker.PaymentVoucher, error</span><br><span class="line">   +ProposeStorageDeal(ctx context.Context, data cid.Cid, miner address.Address, ask uint64, duration uint64, allowDuplicates bool) : *storage.DealResponse, error</span><br><span class="line">   +QueryStorageDeal(ctx context.Context, prop cid.Cid) : *storage.DealResponse, error</span><br></pre></td></tr></table></figure><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><ul><li>提供功能<ul><li>Get配置</li><li>Set配置</li></ul></li></ul><h2 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h2><ul><li>提供功能<ul><li>启动进程相关</li><li>具体的业务启动逻辑会调用到node包</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    api</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+DaemonInitConfig : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 如果配置，定期检查并密封staged扇区</span><br><span class="line">   +AutoSealIntervalSeconds : uint</span><br><span class="line">   +DefaultAddress : address.Address</span><br><span class="line">    // 指定网络</span><br><span class="line">   +DevnetNightly : bool</span><br><span class="line">   +DevnetTest : bool</span><br><span class="line">   +DevnetUser : bool</span><br><span class="line">    // 创世文件</span><br><span class="line">   +GenesisFile : string</span><br><span class="line">   +PeerKeyFile : string</span><br><span class="line">    // repo目录</span><br><span class="line">   +RepoDir : string</span><br><span class="line">    // 指定矿工</span><br><span class="line">   +WithMiner : address.Address</span><br><span class="line"></span><br><span class="line"> +DaemonInitOpt : func(*DaemonInitConfig)</span><br><span class="line"></span><br><span class="line">▼+Daemon : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Init(ctx context.Context, opts ...DaemonInitOpt) : error</span><br><span class="line">   +Start(ctx context.Context) : error</span><br><span class="line">   +Stop(ctx context.Context) : error</span><br></pre></td></tr></table></figure><h2 id="dag"><a href="#dag" class="headerlink" title="dag"></a>dag</h2><ul><li>提供功能<ul><li>dag查询功能</li><li>类似ipfs block get</li></ul></li></ul><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><ul><li>提供功能<ul><li>ID详细信息</li><li>如多地址、协议版本、导出公钥等</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">▼+IDDetails : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Addresses : []ma.Multiaddr</span><br><span class="line">   +AgentVersion : string</span><br><span class="line">   +ID : peer.ID</span><br><span class="line">   +ProtocolVersion : string</span><br><span class="line">   +PublicKey : []byte</span><br><span class="line">    [methods]</span><br><span class="line">   +MarshalJSON() : []byte, error</span><br><span class="line">   +UnmarshalJSON(data []byte) : error</span><br><span class="line"></span><br><span class="line">▼+ID : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Details() : *IDDetails, error</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   -decode(idd map[string]*json.RawMessage, key string, dest interface&#123;&#125;) : error</span><br></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><ul><li>提供日志功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▼+Log : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Tail(ctx context.Context) : io.Reader</span><br></pre></td></tr></table></figure><h2 id="miner"><a href="#miner" class="headerlink" title="miner"></a>miner</h2><ul><li>创建矿工</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▼+Miner : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Create(ctx context.Context, fromAddr address.Address, gasPrice types.AttoFIL, gasLimit types.GasUnits, pledge uint64, pid peer.ID, collateral *types.AttoFIL) : address.Address, error</span><br></pre></td></tr></table></figure><h2 id="mining"><a href="#mining" class="headerlink" title="mining"></a>mining</h2><ul><li>挖矿控制<ul><li>启动</li><li>停止</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">▼+Mining : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Once(ctx context.Context) : *types.Block, error</span><br><span class="line">   +Start(ctx context.Context) : error</span><br><span class="line">   +Stop(ctx context.Context) : error</span><br></pre></td></tr></table></figure><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><ul><li>提供ping接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▼+PingResult : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Success : bool</span><br><span class="line">   +Text : string</span><br><span class="line">   +Time : time.Duration</span><br><span class="line"></span><br><span class="line">▼+Ping : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Ping(ctx context.Context, pid peer.ID, count uint, delay time.Duration) : chan *PingResult, error</span><br></pre></td></tr></table></figure><h2 id="retrieval-client"><a href="#retrieval-client" class="headerlink" title="retrieval_client"></a>retrieval_client</h2><ul><li>提供检索接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▼+RetrievalClient : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +RetrievePiece(ctx context.Context, pieceCID cid.Cid, minerAddr address.Address) : io.ReadCloser, error</span><br></pre></td></tr></table></figure><h2 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h2><ul><li>提供节点连接功能<ul><li>显示连接节点</li><li>连接节点</li><li>查找节点</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">▼+SwarmConnInfo : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Addr : string</span><br><span class="line">   +Latency : string</span><br><span class="line">   +Muxer : string</span><br><span class="line">   +Peer : string</span><br><span class="line">   +Streams : []SwarmStreamInfo</span><br><span class="line">    [methods]</span><br><span class="line">   +Len() : int</span><br><span class="line">   +Less(i, j int) : bool</span><br><span class="line">   +Swap(i, j int)</span><br><span class="line"></span><br><span class="line">▼+SwarmConnInfos : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Peers : []SwarmConnInfo</span><br><span class="line">    [methods]</span><br><span class="line">   +Len() : int</span><br><span class="line">   +Less(i, j int) : bool</span><br><span class="line">   +Swap(i, j int)</span><br><span class="line"></span><br><span class="line">▼+SwarmConnectResult : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Peer : string</span><br><span class="line">   +Success : bool</span><br><span class="line"></span><br><span class="line">▼+SwarmStreamInfo : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Protocol : string</span><br><span class="line"></span><br><span class="line">▼+Swarm : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Connect(ctx context.Context, addrs []string) : []SwarmConnectResult, error</span><br><span class="line">   +FindPeer(ctx context.Context, peerID peer.ID) : peerstore.PeerInfo, error</span><br><span class="line">   +Peers(ctx context.Context, verbose, latency, streams bool) : *SwarmConnInfos, error</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是先河系统CTO杨尉，欢迎大加关注的的Github: &lt;a href=&quot;https://github.com/waynewyang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;waynewyang&lt;/a&gt;，本文是&lt;a href=&quot;https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/&quot;&gt;filecoin技术架构分析系列文章&lt;/a&gt;第十一章源码分析之内部接口层api包分析。&lt;/p&gt;
    
    </summary>
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/categories/FileCoin/"/>
    
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/tags/FileCoin/"/>
    
  </entry>
  
  <entry>
    <title>filecoin技术架构分析十：filecoin源码分析之支撑包分析(2)</title>
    <link href="https://learnblockchain.cn/2019/03/07/filecoin-code-analysis-10/"/>
    <id>https://learnblockchain.cn/2019/03/07/filecoin-code-analysis-10/</id>
    <published>2019-03-07T08:35:33.000Z</published>
    <updated>2019-04-05T10:29:31.028Z</updated>
    
    <content type="html"><![CDATA[<p>我是先河系统CTO杨尉，欢迎大加关注的的Github: <a href="https://github.com/waynewyang" target="_blank" rel="noopener">waynewyang</a>，本文是<a href="https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/">filecoin技术架构分析系列文章</a>第十章源码分析之支撑包分析(2)。</p><a id="more"></a><blockquote><p>本章续上一章的支撑包介绍，主要为便于后面章节的源码理解</p></blockquote><h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><ul><li>提供功能<ul><li>实例化fs资源或者mem资源</li><li>提供读取、设置API地址方法</li><li>提供存储已被校验区块的方法</li><li>提供阶段密封数据存储方法 </li><li>提供密封完成数据存储方法 </li><li>提供读取配置方法</li><li>提供通用数据存储方法 </li><li>提供交易数据存储方法</li><li>提供钱包信息存储方法</li><li>提供存储密钥方法</li><li>提供快照配置存储方法</li><li>提供版本号读取方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    repo</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">    // 当前为１，可以cat ~/.filecoin/version确认</span><br><span class="line">   +Version : uint</span><br><span class="line"></span><br><span class="line">▼+Datastore : interface</span><br><span class="line">    [embedded]</span><br><span class="line">    // 包含datastore的read、write、batch</span><br><span class="line">   +datastore.Batching</span><br><span class="line"></span><br><span class="line">    // Repo接口分别由fsrepo及memrepo实现</span><br><span class="line">▼+Repo : interface</span><br><span class="line">    [methods]</span><br><span class="line">    // 读取API地址</span><br><span class="line">   +APIAddr() : string, error</span><br><span class="line">    // 存储已被校验过的区块数据</span><br><span class="line">   +ChainDatastore() : Datastore</span><br><span class="line">    // 关闭</span><br><span class="line">   +Close() : error</span><br><span class="line">    // 读取配置，对应上一章中的config</span><br><span class="line">   +Config() : *config.Config</span><br><span class="line">    // 存储通用数据</span><br><span class="line">   +Datastore() : Datastore</span><br><span class="line">    // 交易数据存储</span><br><span class="line">   +DealsDatastore() : Datastore</span><br><span class="line">    // 存储密钥相关</span><br><span class="line">   +Keystore() : keystore.Keystore</span><br><span class="line">    // 存储倒数第二个配置</span><br><span class="line">   +ReplaceConfig(cfg *config.Config) : error</span><br><span class="line">    // 存储密封扇区</span><br><span class="line">   +SealedDir() : string</span><br><span class="line">    // 设置API地址</span><br><span class="line">   +SetAPIAddr(string) : error</span><br><span class="line">    // 存储分段密封扇区</span><br><span class="line">   +StagingDir() : string</span><br><span class="line">    // 读取版本号</span><br><span class="line">   +Version() : uint</span><br><span class="line">    // 存储钱包信息</span><br><span class="line">   +WalletDatastore() : Datastore</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">location: repo/fsrepo.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    repo</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">    // api文件</span><br><span class="line">   +APIFile</span><br><span class="line">    // chain目录:chain</span><br><span class="line">   -chainDatastorePrefix</span><br><span class="line">    // 配置文件名称，对应上一章中的config</span><br><span class="line">   -configFilename</span><br><span class="line">    // 交易目录：deals</span><br><span class="line">   -dealsDatastorePrefix</span><br><span class="line">    // 资源目录锁文件：repo.lock</span><br><span class="line">   -lockFile</span><br><span class="line">    // 快照文件前缀名　snapshot</span><br><span class="line">   -snapshotFilenamePrefix</span><br><span class="line">    // 快照目录;配置快照</span><br><span class="line">   -snapshotStorePrefix</span><br><span class="line">    // 临时配置文件名称</span><br><span class="line">   -tempConfigFilename</span><br><span class="line">    // version文件名称</span><br><span class="line">   -versionFilename</span><br><span class="line">    // 钱包目录名称wallet</span><br><span class="line">   -walletDatastorePrefix</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   -log</span><br><span class="line"></span><br><span class="line">▼+FSRepo : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -cfg : *config.Config</span><br><span class="line">   -chainDs : Datastore</span><br><span class="line">   -dealsDs : Datastore</span><br><span class="line">   -ds : Datastore</span><br><span class="line">   -keystore : keystore.Keystore</span><br><span class="line">   -lk : sync.RWMutex</span><br><span class="line">   -lockfile : io.Closer</span><br><span class="line">    // 资源目录路径</span><br><span class="line">   -path : string</span><br><span class="line">    // 资源目录版本</span><br><span class="line">   -version : uint</span><br><span class="line">   -walletDs : Datastore</span><br><span class="line">    [methods]</span><br><span class="line">   +APIAddr() : string, error</span><br><span class="line">   +ChainDatastore() : Datastore</span><br><span class="line">   +Close() : error</span><br><span class="line">   +Config() : *config.Config</span><br><span class="line">   +Datastore() : Datastore</span><br><span class="line">   +DealsDatastore() : Datastore</span><br><span class="line">   +Keystore() : keystore.Keystore</span><br><span class="line">   +ReplaceConfig(cfg *config.Config) : error</span><br><span class="line">   +SealedDir() : string</span><br><span class="line">   +SetAPIAddr(maddr string) : error</span><br><span class="line">    // 快照存储</span><br><span class="line">   +SnapshotConfig(cfg *config.Config) : error</span><br><span class="line">   +StagingDir() : string</span><br><span class="line">   +Version() : uint</span><br><span class="line">   +WalletDatastore() : Datastore</span><br><span class="line">   -loadConfig() : error</span><br><span class="line">   -loadFromDisk() : error</span><br><span class="line">   -loadVersion() : uint, error</span><br><span class="line">   -openChainDatastore() : error</span><br><span class="line">   -openDatastore() : error</span><br><span class="line">   -openDealsDatastore() : error</span><br><span class="line">   -openKeystore() : error</span><br><span class="line">   -openWalletDatastore() : error</span><br><span class="line">   -removeAPIFile() : error</span><br><span class="line">   -removeFile(path string) : error</span><br><span class="line">    [functions]</span><br><span class="line">    // 打开已被初始化过的资源目录</span><br><span class="line">   +OpenFSRepo(p string) : *FSRepo, error</span><br><span class="line"></span><br><span class="line">▼+NoRepoError : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Path : string</span><br><span class="line">    [methods]</span><br><span class="line">   +Error() : string</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 从文件中读取api file</span><br><span class="line">   +APIAddrFromFile(apiFilePath string) : string, error</span><br><span class="line">    // 初始化资源目录</span><br><span class="line">   +InitFSRepo(p string, cfg *config.Config) : error</span><br><span class="line">   -checkWritable(dir string) : error</span><br><span class="line">   -fileExists(file string) : bool</span><br><span class="line">   -genSnapshotFileName() : string</span><br><span class="line">   -initConfig(p string, cfg *config.Config) : error</span><br><span class="line">   -initVersion(p string, version uint) : error</span><br><span class="line">   -isInitialized(p string) : bool, error</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    repo</span><br><span class="line"></span><br><span class="line">▼ imports</span><br><span class="line"></span><br><span class="line">▼+MemRepo : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +C : *config.Config</span><br><span class="line">   +Chain : Datastore</span><br><span class="line">   +D : Datastore</span><br><span class="line">   +DealsDs : Datastore</span><br><span class="line">   +Ks : keystore.Keystore</span><br><span class="line">   +W : Datastore</span><br><span class="line">   -apiAddress : string</span><br><span class="line">   -lk : sync.RWMutex</span><br><span class="line">   -sealedDir : string</span><br><span class="line">   -stagingDir : string</span><br><span class="line">   -version : uint</span><br><span class="line">    [methods]</span><br><span class="line">   +APIAddr() : string, error</span><br><span class="line">   +ChainDatastore() : Datastore</span><br><span class="line">   +CleanupSectorDirs()</span><br><span class="line">   +Close() : error</span><br><span class="line">   +Config() : *config.Config</span><br><span class="line">   +Datastore() : Datastore</span><br><span class="line">   +DealsDatastore() : Datastore</span><br><span class="line">   +Keystore() : keystore.Keystore</span><br><span class="line">   +ReplaceConfig(cfg *config.Config) : error</span><br><span class="line">   +SealedDir() : string</span><br><span class="line">   +SetAPIAddr(addr string) : error</span><br><span class="line">   +StagingDir() : string</span><br><span class="line">   +Version() : uint</span><br><span class="line">   +WalletDatastore() : Datastore</span><br><span class="line">    [functions]</span><br><span class="line">    // 实例化内存资源接口,会调用NewInMemoryRepoWithSectorDirectories</span><br><span class="line">   +NewInMemoryRepo() : *MemRepo</span><br><span class="line">    // 实例化内存资源接口，指定阶段密封和最终密封目录</span><br><span class="line">   +NewInMemoryRepoWithSectorDirectories(staging, sealedDir string) : *MemRepo</span><br></pre></td></tr></table></figure><h2 id="proofs和sectorbuilder"><a href="#proofs和sectorbuilder" class="headerlink" title="proofs和sectorbuilder"></a>proofs和sectorbuilder</h2><ul><li>proofs提供功能<ul><li>校验时空证明的方法</li><li>校验密封证明的方法</li><li>更细节的注释见如下代码笔者增加的注释</li><li>rustverifier实现具体的方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">location: proofs/types.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    proofs</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">    // merkle根长度</span><br><span class="line">   +CommitmentBytesLen : uint</span><br><span class="line">    // 时空证明挑战参数长度:32bytes</span><br><span class="line">   +PoStChallengeSeedBytesLen : uint</span><br><span class="line">    // 密封复制证明长度：384bytes</span><br><span class="line">   +SealBytesLen : uint</span><br><span class="line">    // 时空证明长度：192bytes</span><br><span class="line">   +SnarkBytesLen : uint</span><br><span class="line"></span><br><span class="line">    // 原始数据的merkle根，由PoRep输出</span><br><span class="line"> +CommD : []byte</span><br><span class="line"></span><br><span class="line">    // 副本数据的merkle根，由PoRep输出</span><br><span class="line"> +CommR : []byte</span><br><span class="line"></span><br><span class="line">    // 中间层的merkle根，由PoRep输出</span><br><span class="line"> +CommRStar : []byte</span><br><span class="line"></span><br><span class="line">    // 挑战随机参数,32bytes,256bits,PoSt的输入</span><br><span class="line"> +PoStChallengeSeed : []byte</span><br><span class="line"></span><br><span class="line">    // 时空证明输出，192bytes</span><br><span class="line"> +PoStProof : []byte</span><br><span class="line"></span><br><span class="line">    // 密封复制证明,384bytes</span><br><span class="line"> +SealProof : []byte</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">location: proofs/interface.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    proofs</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">   +Live</span><br><span class="line">   +Test</span><br><span class="line"></span><br><span class="line"> +SectorStoreType : int</span><br><span class="line"></span><br><span class="line">    // 校验时空证明校验请求</span><br><span class="line">▼+VerifyPoSTRequest : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 挑战参数</span><br><span class="line">   +ChallengeSeed : PoStChallengeSeed</span><br><span class="line">   +CommRs : []CommR</span><br><span class="line">   +Faults : []uint64</span><br><span class="line">   +Proof : PoStProof</span><br><span class="line">   +StoreType : SectorStoreType</span><br><span class="line"></span><br><span class="line">▼+VerifyPoSTResponse : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +IsValid : bool</span><br><span class="line"></span><br><span class="line">    // 向特定矿工&amp;特定扇区发起密封校验请求</span><br><span class="line">▼+VerifySealRequest : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 来自于密封的返回参数</span><br><span class="line">   +CommD : CommD</span><br><span class="line">   +CommR : CommR</span><br><span class="line">   +CommRStar : CommRStar</span><br><span class="line">   +Proof : SealProof</span><br><span class="line">    // 矿工标识</span><br><span class="line">   +ProverID : [31]byte</span><br><span class="line">    // 扇区ID</span><br><span class="line">   +SectorID : [31]byte</span><br><span class="line">    // 用于控制密封校验效率</span><br><span class="line">   +StoreType : SectorStoreType</span><br><span class="line"></span><br><span class="line">▼+VerifySealResponse : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +IsValid : bool</span><br><span class="line"></span><br><span class="line">▼+Verifier : interface</span><br><span class="line">    [methods]</span><br><span class="line">    // 校验时空证明</span><br><span class="line">   +VerifyPoST(VerifyPoSTRequest) : VerifyPoSTResponse, error</span><br><span class="line">    // 校验密封证明</span><br><span class="line">   +VerifySeal(VerifySealRequest) : VerifySealResponse, error</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">location: proofs/rustverifier.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    proofs</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   -log</span><br><span class="line"></span><br><span class="line">    // RustVerifier 实现VerifyPoST与VerifySeal接口</span><br><span class="line">▼+RustVerifier : struct</span><br><span class="line">    [methods]</span><br><span class="line">   +VerifyPoST(req VerifyPoSTRequest) : VerifyPoSTResponse, error</span><br><span class="line">   +VerifySeal(req VerifySealRequest) : VerifySealResponse, error</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   +CSectorStoreType(cfg SectorStoreType) : *C.ConfiguredStore, error</span><br><span class="line">   -cUint64s(src []uint64) : *C.uint64_t, C.size_t</span><br><span class="line">   -elapsed(what string) : func()</span><br></pre></td></tr></table></figure><ul><li>sectorbuilder <ul><li>提供向unsealed扇区写入pieces的方法</li><li>提供生成时空证明的方法</li><li>提供从特定扇区读取特定pieces的方法</li><li>提供密封完成通知的方法</li><li>提供批量密封所有未完成的分段扇区</li><li>与rust-fil-proof交互，更深入的逻辑需要参见rust</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">location: proofs/sectorbuilder/interface.go</span><br><span class="line"></span><br><span class="line">package sectorbuilder</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">    // 生成生成时空证明请求</span><br><span class="line">▼+GeneratePoSTRequest : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +ChallengeSeed : proofs.PoStChallengeSeed</span><br><span class="line">   +CommRs : []proofs.CommR</span><br><span class="line"></span><br><span class="line">    // 生成生成时空证明响应</span><br><span class="line">▼+GeneratePoSTResponse : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Faults : []uint64</span><br><span class="line">   +Proof : proofs.PoStProof</span><br><span class="line"></span><br><span class="line">▼+PieceInfo : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Ref : cid.Cid</span><br><span class="line">   +Size : uint64</span><br><span class="line"></span><br><span class="line">    // 密封元数据</span><br><span class="line">▼+SealedSectorMetadata : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +CommD : proofs.CommD</span><br><span class="line">    // 副本哈希后续将被删除</span><br><span class="line">   +CommR : proofs.CommR</span><br><span class="line">   +CommRStar : proofs.CommRStar</span><br><span class="line">    // Pieces后续将被删除</span><br><span class="line">   +Pieces : []*PieceInfo</span><br><span class="line">   +Proof : proofs.SealProof</span><br><span class="line">   +SectorID : uint64</span><br><span class="line"></span><br><span class="line">    // 密封结果</span><br><span class="line">▼+SectorSealResult : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +SealingErr : error</span><br><span class="line">   +SealingResult : *SealedSectorMetadata</span><br><span class="line">   +SectorID : uint64</span><br><span class="line"></span><br><span class="line">    // SectorBuilder提供相关功能</span><br><span class="line">    // 1 写入、密封pieces至扇区</span><br><span class="line">    // 2 unseal、读取pieces</span><br><span class="line">▼+SectorBuilder : interface</span><br><span class="line">    [methods]</span><br><span class="line">    // 向unsealed扇区写入pieces</span><br><span class="line">   +AddPiece(ctx context.Context, pi *PieceInfo) : uint64, error</span><br><span class="line">   +Close() : error</span><br><span class="line">    // 生成时空证明</span><br><span class="line">   +GeneratePoST(GeneratePoSTRequest) : GeneratePoSTResponse, error</span><br><span class="line">   +GetMaxUserBytesPerStagedSector() : uint64, error</span><br><span class="line">    // 从扇区中读取特定pieces</span><br><span class="line">   +ReadPieceFromSealedSector(pieceCid cid.Cid) : io.Reader, error</span><br><span class="line">    // 密封所有未完成的分段扇区</span><br><span class="line">   +SealAllStagedSectors(ctx context.Context) : error</span><br><span class="line">    // 密封完成的通知</span><br><span class="line">   +SectorSealResults() : chan SectorSealResult</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   -init()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location: proofs/sectorbuilder/poller.go</span><br><span class="line"></span><br><span class="line">// 当pieces加入后，会进行FFI调用，定时执行密封</span><br><span class="line">const SealedSectorPollingInterval = 1 * time.Second</span><br></pre></td></tr></table></figure><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>如下对一些主要结构进行简析</p><ul><li><p>AttoFIL(10*-18 FIL)</p><ul><li>提供AttoFIL的算数运算方法</li><li>提供AttoFIL的逻辑运算方法</li></ul></li><li><p>Block </p><ul><li>区块结构</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">▼+Block : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Height : Uint64</span><br><span class="line">   +MessageReceipts : []*MessageReceipt</span><br><span class="line">   +Messages : []*SignedMessage</span><br><span class="line">   +Miner : address.Address</span><br><span class="line">   +Nonce : Uint64</span><br><span class="line">   +ParentWeight : Uint64</span><br><span class="line">   +Parents : SortedCidSet</span><br><span class="line">   +Proof : proofs.PoStProof</span><br><span class="line">   +StateRoot : cid.Cid</span><br><span class="line">   +Ticket : Signature</span><br><span class="line">   -cachedBytes : []byte</span><br><span class="line">   -cachedCid : cid.Cid</span><br><span class="line">    [methods]</span><br><span class="line">   +Cid() : cid.Cid</span><br><span class="line">   +Equals(other *Block) : bool</span><br><span class="line">   +IsParentOf(c Block) : bool</span><br><span class="line">   +Score() : uint64</span><br><span class="line">   +String() : string</span><br><span class="line">   +ToNode() : node.Node</span><br><span class="line">    [functions]</span><br><span class="line">   +DecodeBlock(b []byte) : *Block, error</span><br></pre></td></tr></table></figure><ul><li>BlockHeight <ul><li>区块高度相关操作方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">▼+BlockHeight : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -val : *big.Int</span><br><span class="line">    [methods]</span><br><span class="line">   +Add(y *BlockHeight) : *BlockHeight</span><br><span class="line">   +AsBigInt() : *big.Int</span><br><span class="line">   +Bytes() : []byte</span><br><span class="line">   +Equal(y *BlockHeight) : bool</span><br><span class="line">   +GreaterEqual(y *BlockHeight) : bool</span><br><span class="line">   +GreaterThan(y *BlockHeight) : bool</span><br><span class="line">   +LessEqual(y *BlockHeight) : bool</span><br><span class="line">   +LessThan(y *BlockHeight) : bool</span><br><span class="line">   +String() : string</span><br><span class="line">   +Sub(y *BlockHeight) : *BlockHeight</span><br><span class="line">    [functions]</span><br><span class="line">   +NewBlockHeight(x uint64) : *BlockHeight</span><br><span class="line">   +NewBlockHeightFromBytes(buf []byte) : *BlockHeight</span><br><span class="line">   +NewBlockHeightFromString(s string, base int) : *BlockHeight, bool</span><br></pre></td></tr></table></figure><ul><li><p>BytesAmount (*big.Int)</p><ul><li>提供相关的算数逻辑运算</li></ul></li><li><p>ChannelID(支付通道结构体)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">▼+ChannelID : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -val : *big.Int</span><br><span class="line">    [methods]</span><br><span class="line">   +Bytes() : []byte</span><br><span class="line">   +Equal(y *ChannelID) : bool</span><br><span class="line">   +Inc() : *ChannelID</span><br><span class="line">   +KeyString() : string</span><br><span class="line">   +String() : string</span><br><span class="line">    [functions]</span><br><span class="line">   +NewChannelID(x uint64) : *ChannelID</span><br><span class="line">   +NewChannelIDFromBytes(buf []byte) : *ChannelID</span><br><span class="line">   +NewChannelIDFromString(s string, base int) : *ChannelID, bool</span><br></pre></td></tr></table></figure><ul><li>一些变量定义<ul><li>创建各类actor对象</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">AccountActorCodeObj = dag.NewRawNode([]byte(&quot;accountactor&quot;))</span><br><span class="line">AccountActorCodeCid = AccountActorCodeObj.Cid()</span><br><span class="line">StorageMarketActorCodeObj = dag.NewRawNode([]byte(&quot;storagemarket&quot;))</span><br><span class="line">StorageMarketActorCodeCid = StorageMarketActorCodeObj.Cid()</span><br><span class="line">PaymentBrokerActorCodeObj = dag.NewRawNode([]byte(&quot;paymentbroker&quot;))</span><br><span class="line">PaymentBrokerActorCodeCid = PaymentBrokerActorCodeObj.Cid()</span><br><span class="line">MinerActorCodeObj = dag.NewRawNode([]byte(&quot;mineractor&quot;))</span><br><span class="line">MinerActorCodeCid = MinerActorCodeObj.Cid()</span><br><span class="line">BootstrapMinerActorCodeObj = dag.NewRawNode([]byte(&quot;bootstrapmineractor&quot;))</span><br><span class="line">BootstrapMinerActorCodeCid = BootstrapMinerActorCodeObj.Cid()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Message相关<ul><li>消息结构及方法</li><li>filecoin网络的交易由一些列的Message组成</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">▼+Message : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +From : address.Address</span><br><span class="line">   +Method : string</span><br><span class="line">   +Nonce : Uint64</span><br><span class="line">   +Params : []byte</span><br><span class="line">   +To : address.Address</span><br><span class="line">   +Value : *AttoFIL</span><br><span class="line">    [methods]</span><br><span class="line">   +Cid() : cid.Cid, error</span><br><span class="line">   +Marshal() : []byte, error</span><br><span class="line">   +String() : string</span><br><span class="line">   +Unmarshal(b []byte) : error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewMessage(from, to address.Address, nonce uint64, value *AttoFIL, method string, params []byte) : *Message</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">▼+MessageReceipt : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +ExitCode : uint8</span><br><span class="line">   +GasAttoFIL : *AttoFIL</span><br><span class="line">   +Return : [][]byte</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">▼+MeteredMessage : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +GasLimit : GasUnits</span><br><span class="line">   +GasPrice : AttoFIL</span><br><span class="line">    [embedded]</span><br><span class="line">   +Message : Message</span><br><span class="line">    [methods]</span><br><span class="line">   +Marshal() : []byte, error</span><br><span class="line">   +Unmarshal(b []byte) : error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewMeteredMessage(msg Message, gasPrice AttoFIL, gasLimit GasUnits) : *MeteredMessage</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">▼+SignedMessage : struct</span><br><span class="line">    [fields]</span><br><span class="line">   +Signature : Signature</span><br><span class="line">    [embedded]</span><br><span class="line">   +MeteredMessage : MeteredMessage</span><br><span class="line">    [methods]</span><br><span class="line">   +Cid() : cid.Cid, error</span><br><span class="line">   +Marshal() : []byte, error</span><br><span class="line">   +RecoverAddress(r Recoverer) : address.Address, error</span><br><span class="line">   +String() : string</span><br><span class="line">   +Unmarshal(b []byte) : error</span><br><span class="line">   +VerifySignature() : bool</span><br><span class="line">    [functions]</span><br><span class="line">   +NewSignedMessage(msg Message, s Signer, gasPrice AttoFIL, gasLimit GasUnits) : *SignedMessage, error</span><br></pre></td></tr></table></figure><ul><li>TipSet <ul><li>区块集合</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> +Tip : Block</span><br><span class="line"></span><br><span class="line">▼+TipSet : map[cid.Cid]*Tip</span><br><span class="line">    [methods]</span><br><span class="line">   +AddBlock(b *Block) : error</span><br><span class="line">   +Clone() : TipSet</span><br><span class="line">   +Equals(ts2 TipSet) : bool</span><br><span class="line">   +Height() : uint64, error</span><br><span class="line">   +MinTicket() : Signature, error</span><br><span class="line">   +ParentWeight() : uint64, error</span><br><span class="line">   +Parents() : SortedCidSet, error</span><br><span class="line">   +String() : string</span><br><span class="line">   +ToSlice() : []*Block</span><br><span class="line">   +ToSortedCidSet() : SortedCidSet</span><br></pre></td></tr></table></figure><h2 id="abi"><a href="#abi" class="headerlink" title="abi"></a>abi</h2><ul><li>abi<ul><li>对filecoin中的各类数据定义数据类型</li><li>提供abi编解码操作方法</li></ul></li></ul><h2 id="pubsub"><a href="#pubsub" class="headerlink" title="pubsub"></a>pubsub</h2><ul><li>提供功能<ul><li>提供订阅实例化以及订阅方法</li><li>提供发布实例化以及发布方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    pubsub</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+Subscriber : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -pubsub : *libp2p.PubSub</span><br><span class="line">    [methods]</span><br><span class="line">   +Subscribe(topic string) : Subscription, error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewSubscriber(sub *libp2p.PubSub) : *Subscriber</span><br><span class="line"></span><br><span class="line">▼-subscriptionWrapper : struct</span><br><span class="line">    [embedded]</span><br><span class="line">   +*libp2p.Subscription : *libp2p.Subscription</span><br><span class="line">    [methods]</span><br><span class="line">   +Next(ctx context.Context) : Message, error</span><br><span class="line"></span><br><span class="line">▼+Message : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +GetData() : []byte</span><br><span class="line">   +GetFrom() : peer.ID</span><br><span class="line"></span><br><span class="line">▼+Subscription : interface</span><br><span class="line">    [methods]</span><br><span class="line">   +Cancel()</span><br><span class="line">   +Next(ctx context.Context) : Message, error</span><br><span class="line">   +Topic() : string</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    pubsub</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+Publisher : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -pubsub : *pubsub.PubSub</span><br><span class="line">    [methods]</span><br><span class="line">   +Publish(topic string, data []byte) : error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewPublisher(sub *pubsub.PubSub) : *Publisher</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是先河系统CTO杨尉，欢迎大加关注的的Github: &lt;a href=&quot;https://github.com/waynewyang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;waynewyang&lt;/a&gt;，本文是&lt;a href=&quot;https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/&quot;&gt;filecoin技术架构分析系列文章&lt;/a&gt;第十章源码分析之支撑包分析(2)。&lt;/p&gt;
    
    </summary>
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/categories/FileCoin/"/>
    
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/tags/FileCoin/"/>
    
  </entry>
  
  <entry>
    <title>登链钱包-一款功能强大的完全开源以太坊钱包</title>
    <link href="https://learnblockchain.cn/2019/03/07/wallet-annouce/"/>
    <id>https://learnblockchain.cn/2019/03/07/wallet-annouce/</id>
    <published>2019-03-07T02:34:57.000Z</published>
    <updated>2019-04-05T10:29:31.012Z</updated>
    
    <content type="html"><![CDATA[<p>你是否和我前段时间一样，苦苦的寻找一款好用的开源以太坊钱包，你会发现可用都很少，因为很多钱包说开源，仅仅是开源部分代码，现在不需要再找了。</p><p>重要的事情说三遍：<br>这是一个款<strong>完全开源</strong>，<strong>完全免费</strong>，功能强大<strong>支持DApp浏览器功能</strong>的钱包；<br>这是一个款<strong>完全开源</strong>，<strong>完全免费</strong>，功能强大<strong>支持DApp浏览器功能</strong>的钱包；<br>这是一个款<strong>完全开源</strong>，<strong>完全免费</strong>，功能强大<strong>支持DApp浏览器功能</strong>的钱包。</p><p>再也不用傻乎乎找人开发以太坊钱包了， 直接拿去用吧；再也不用担心私钥会被上传到别人的服务器上。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>区块链是开放的，很难想象一个封闭的项目如何产生信任，开源一直是区块链社区所倡导的行为准则。<br>我们也希望开源能够降低行业的开发门槛，吸引更多的开发者和公司能够利用我们的代码，找到更多落地的应用场景，一起来推动行业的发展。<br>同时我们也相信开源可以是产品更加的安全，我们也邀请专业的区块链安全团队<a href="https://www.noneage.com/" target="_blank" rel="noopener">零时科技</a>来为钱包做安全审计。</p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p>先来看看钱包长什么样吧，我制作了一个gif图片：</p><p align="center"><br>  <img src="https://img.learnblockchain.cn/2019/upchainwallet.gif" width="450"><br></p><p>19年4月更新：加入 <strong>DApp 浏览器</strong> 功能</p><p align="center"><br>  <img src="https://img.learnblockchain.cn/2019/dapp.gif" width="450"><br></p><p>DApp 浏览器，目前暂未开源，需要请加微信：xlbxiong。</p><p>Gif 图片比较简陋，见谅见谅，可以看的出来界面参考了现在的主流钱包，感谢imToken及<a href="https://github.com/DwyaneQ/ETHWallet" target="_blank" rel="noopener">ETHWallet</a>，</p><p>大家可以戳<a href="https://wiki.learnblockchain.cn/images/upchain_wallet.apk" target="_blank" rel="noopener">链接</a>下载APK体验，<br>Google play 也已经上架，<a href="https://play.google.com/store/apps/details?id=pro.upchain.ethwallet" target="_blank" rel="noopener">链接</a></p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>目前版本支持一下功能：</p><ul><li style="list-style: none"><input type="checkbox" checked> 支持通过生成助记词、Keystore文件、私钥 创建钱包账号；</li><li style="list-style: none"><input type="checkbox" checked> 支持导出钱包账号助记词、私钥、Keystore文件；</li><li style="list-style: none"><input type="checkbox" checked> 账户余额查询及转账功能；</li><li style="list-style: none"><input type="checkbox" checked> 支持多个钱包账号管理；</li><li style="list-style: none"><input type="checkbox" checked> 支持ERC20 代币（余额显示、转账、代币币价显示）；</li><li style="list-style: none"><input type="checkbox" checked> 历史交易列表显示；</li><li style="list-style: none"><input type="checkbox" checked> 支持DApp Browser 浏览器 </li><li style="list-style: none"><input type="checkbox" checked> 二维码扫描，兼容imToken格式；</li><li style="list-style: none"><input type="checkbox" checked> 支持用法币（美元和人民币）实时显示币价；</li><li style="list-style: none"><input type="checkbox" checked> 支持以太坊官方测试网络（Infura Koven及Ropsten）及本地测试网络。</li></ul><p>功能够全面吧，尤其是最后一个功能支持以太坊官方测试网络（Infura Koven及Ropsten）及本地测试网络，估计是开发者的最爱，做为开发者的我，懂你们的痛（可以获取到免费的以太币用于测试）。</p><p>代码的讲解和相应的课程，我们后面会陆续放出，在还没有放出之前，先提醒大家几个注意的点：</p><ol><li>使用本地网络测试的时候注意Geth 或 Ganache 设置下可接收RPC连接的地址，因为默认情况下只支持本地连接，这样手机上就无法连接。</li><li>显示交易记录功能需要自己搭建一个服务器提供API接口，这个接口来自TrustWallet，为了和本应用保持版本一致，我Fork了一份，地址为<a href="https://github.com/xilibi2003/trust-ray" target="_blank" rel="noopener">trust-ray</a>，这个库会解析区块，并把交易信息存到MongoDb数据库里，然后用API提供给客户端使用。</li><li>实时币价的显示其实也是使用trust-ray提供的接口，trust-ray 使用的是<a href="https://coinmarketcap.com/" target="_blank" rel="noopener">CoinMarketCap</a>的数据，目前使用的是CoinMarketCap免费提供的数据，CoinMarketCap现在有一套新的付费接口，免费的数据可能在将来会停用，到时需要使用CoinMarketCap 的apikey来访问。</li><li>代码中ERC20_Contract目录提供了一个ERC20合约给大家部署测试Token功能。</li></ol><p>其他的代码介绍及环境搭建大家就只有等我的文章了，大家也可以学习<a href="https://ke.qq.com/course/356068?tuin=bd898bbf" target="_blank" rel="noopener">网页钱包开发课程</a>，课程详细介绍了开发钱包必备的理论知识。</p><p>有什么需要的功能，可以提issue或加我微信留言。</p><p>对了本项目的GitHub地址为：<a href="https://github.com/xilibi2003/Upchain-wallet" target="_blank" rel="noopener">Upchain-wallet</a>,  点 Star 的同学都会发大财，哈哈哈~~~  </p><h2 id="参考的开源项目"><a href="#参考的开源项目" class="headerlink" title="参考的开源项目"></a>参考的开源项目</h2><p>本钱包在开发是站在巨人的肩膀上完成，特别感谢以下项目：</p><ul><li><a href="https://docs.web3j.io/index.html" target="_blank" rel="noopener">web3j</a></li><li><a href="https://bitcoinj.github.io/javadoc/0.14.7/" target="_blank" rel="noopener">bitcoinj</a></li><li><a href="https://github.com/TrustWallet/trust-wallet-android-source" target="_blank" rel="noopener">Trust-wallet</a></li><li><a href="https://github.com/DwyaneQ/ETHWallet" target="_blank" rel="noopener">ETHWallet</a></li><li><a href="https://github.com/bingoogolapple/BGAQRCode-Android" target="_blank" rel="noopener">BGAQRCode</a></li><li><a href="https://github.com/TrustWallet/trust-ray" target="_blank" rel="noopener">Trust-ray</a></li></ul><h2 id="再啰嗦几句"><a href="#再啰嗦几句" class="headerlink" title="再啰嗦几句"></a>再啰嗦几句</h2><p>本次开源也是受到区块链社区的影响，尤其是HiBlock区块链社区一些朋友坚持布道和开源的精神影响。</p><blockquote><p>HiBlock区块链社区 是国内最大的区块链开发者社区，社区已经聚集了数千名区块链开发者。</p></blockquote><p>登链钱包是由登链学院出品，希望大家知道<a href="https://upchain.ke.qq.com" target="_blank" rel="noopener">登链学院</a>不单出品优质课程，我们也为行业发展贡献一份力量，感谢大家转发。</p><p>想要加入开源钱包讨论群的的朋友，加微信：xlbxiong  备注：钱包</p><p>PS: 我们提供专业的钱包定制开发，欢迎咨询微信：xlbxiong 备注：定制开发</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否和我前段时间一样，苦苦的寻找一款好用的开源以太坊钱包，你会发现可用都很少，因为很多钱包说开源，仅仅是开源部分代码，现在不需要再找了。&lt;/p&gt;
&lt;p&gt;重要的事情说三遍：&lt;br&gt;这是一个款&lt;strong&gt;完全开源&lt;/strong&gt;，&lt;strong&gt;完全免费&lt;/strong&gt;，功能强大&lt;strong&gt;支持DApp浏览器功能&lt;/strong&gt;的钱包；&lt;br&gt;这是一个款&lt;strong&gt;完全开源&lt;/strong&gt;，&lt;strong&gt;完全免费&lt;/strong&gt;，功能强大&lt;strong&gt;支持DApp浏览器功能&lt;/strong&gt;的钱包；&lt;br&gt;这是一个款&lt;strong&gt;完全开源&lt;/strong&gt;，&lt;strong&gt;完全免费&lt;/strong&gt;，功能强大&lt;strong&gt;支持DApp浏览器功能&lt;/strong&gt;的钱包。&lt;/p&gt;
&lt;p&gt;再也不用傻乎乎找人开发以太坊钱包了， 直接拿去用吧；再也不用担心私钥会被上传到别人的服务器上。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>filecoin技术架构分析九：filecoin源码分析之支撑包分析(1)</title>
    <link href="https://learnblockchain.cn/2019/03/06/filecoin-code-analysis-9/"/>
    <id>https://learnblockchain.cn/2019/03/06/filecoin-code-analysis-9/</id>
    <published>2019-03-06T08:35:33.000Z</published>
    <updated>2019-04-05T10:29:31.045Z</updated>
    
    <content type="html"><![CDATA[<p>我是先河系统CTO杨尉，欢迎大加关注的的Github: <a href="https://github.com/waynewyang" target="_blank" rel="noopener">waynewyang</a>，本文是<a href="https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/">filecoin技术架构分析系列文章</a>第九章filecoin源码分析之支撑包分析(1)。</p><a id="more"></a><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><blockquote><p>简析一些支撑包，便于后面分析的理解</p></blockquote><h2 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h2><ul><li>bin目录：主要为编译用shell脚本</li><li>bls-signatures:　通过cgo编译，导出库及头文件</li><li>build: 编译相关</li><li>util/version:版本检查</li><li>scripts:相关脚本</li></ul><h2 id="cborutil"><a href="#cborutil" class="headerlink" title="cborutil"></a>cborutil</h2><ul><li>对外提供功能<ul><li>读取流消息</li><li>写入流消息</li><li>主要被协议层使用</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    cborutil</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">   +MaxMessageSize</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   +ErrMessageTooLarge</span><br><span class="line"></span><br><span class="line">▼+MsgReader : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -br : *bufio.Reader</span><br><span class="line">    [methods]</span><br><span class="line">   +ReadMsg(i interface&#123;&#125;) : error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewMsgReader(r io.Reader) : *MsgReader</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    cborutil</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼+MsgWriter : struct</span><br><span class="line">    [fields]</span><br><span class="line">   -w : *bufio.Writer</span><br><span class="line">    [methods]</span><br><span class="line">   +WriteMsg(i interface&#123;&#125;) : error</span><br><span class="line">    [functions]</span><br><span class="line">   +NewMsgWriter(w io.Writer) : *MsgWriter</span><br></pre></td></tr></table></figure><h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><ul><li>对外提供功能<ul><li>地址相关操作功能</li><li>实例化铸币地址、存储市场地址、支付通道地址</li><li>实例化两个测试地址</li><li>提供主网地址、测试网地址创建接口</li><li>提供地址格式转换功能，包含22bytes与41bytes、切片字符串转换、打印。</li><li>提供地址的合法性检查功能</li></ul></li><li>地址格式<ul><li>要与id区分开，id用的是ipfs中的cid,而地址则是filecoin独立定义的。</li><li>22 bytes地址：包含1byte网络类型、1byte地址版本、20bytes哈希</li><li>41 bytes地址：包含2bytes网络类型、1byte地址版本、32bytes编码值、6bytes校验和</li><li>用命令显示的是41bytes格式的地址，address包提供了22bytes与41bytes地址的转换接口</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">location: address/constants.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    address</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">    // Base32编码的字符集</span><br><span class="line">   +Base32Charset</span><br><span class="line">    // 地址的哈希部分，目前为20 bytes</span><br><span class="line">   +HashLength, 20bytes，160bit</span><br><span class="line">    // 地址长度,为HashLength+1+1= 22 bytes</span><br><span class="line">   +Length</span><br><span class="line">    // 地址格式的版本定义：当前为0</span><br><span class="line">   +Version : byte</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">    // 基于Base32Charset的Base32实例,用于编解码</span><br><span class="line">   +Base32</span><br><span class="line">    // Base32 Reverse集合</span><br><span class="line">   +Base32CharsetReverse</span><br><span class="line">    // 铸币地址,基于&quot;filecoin&quot;哈希生成</span><br><span class="line">   +NetworkAddress : Address</span><br><span class="line">    // 支付通道地址</span><br><span class="line">   +PaymentBrokerAddress : Address</span><br><span class="line">    // 存储市场地址</span><br><span class="line">   +StorageMarketAddress : Address</span><br><span class="line">    // 测试地址</span><br><span class="line">   +TestAddress : Address</span><br><span class="line">    // 测试地址</span><br><span class="line">   +TestAddress2 : Address</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   -init()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">location: address/address.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    address</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">   +Mainnet : Network</span><br><span class="line">   +Testnet</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">    // 错误提示</span><br><span class="line">   +ErrInvalidBytes</span><br><span class="line">   +ErrUnknownNetwork</span><br><span class="line">   +ErrUnknownVersion</span><br><span class="line">   -generator</span><br><span class="line">    // 配置输入哈希长度20bytes</span><br><span class="line">   -hashConfig</span><br><span class="line"></span><br><span class="line">   // Address为22字节字符串</span><br><span class="line">▼+Address : []byte</span><br><span class="line">    [methods]</span><br><span class="line">    // 转换为编码前地址切片输出</span><br><span class="line">   +Bytes() : []byte</span><br><span class="line">    // 判断地址是否为空</span><br><span class="line">   +Empty() : bool</span><br><span class="line">    // 打印地址信息</span><br><span class="line">   +Format(f fmt.State, c rune)</span><br><span class="line">    // 输出地址中的20bytes哈希值</span><br><span class="line">   +Hash() : []byte</span><br><span class="line">    // 转换为编码后地址切片输出</span><br><span class="line">   +MarshalText() : []byte, error</span><br><span class="line">    // 输出地址的网络类型</span><br><span class="line">   +Network() : Network</span><br><span class="line">    // 转换为41bytes的编码输出</span><br><span class="line">    // 2(网络类型)+1(地址版本)+32(base32编码)+6(base32校验位)</span><br><span class="line">   +String() : string</span><br><span class="line">    // 编码后地址切片输出转换为字符</span><br><span class="line">   +UnmarshalText(in []byte) : error</span><br><span class="line">    // 获取地址版本号</span><br><span class="line">   +Version() : byte</span><br><span class="line"></span><br><span class="line">    // 类型定义</span><br><span class="line"> +Network : byte</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 采用blake2b-160再次哈希</span><br><span class="line">   +Hash(input []byte) : []byte</span><br><span class="line">    // 生成测试网络地址,输入为原始哈希,会执行blake2b-160再次哈希</span><br><span class="line">   +MakeTestAddress(input string) : Address</span><br><span class="line">    // 通过字符串网络类型转换为byte网络类型</span><br><span class="line">    // fc:主网转化为0</span><br><span class="line">    // tf:测试网化为1</span><br><span class="line">   +NetworkFromString(input string) : Network, error</span><br><span class="line">    // 通过byte网络类型转换为字符串网络类型</span><br><span class="line">    // 0:主网转化为fc</span><br><span class="line">    // 1:测试网化为tf</span><br><span class="line">   +NetworkToString(n Network) : string</span><br><span class="line">    // 构建新地址：输入为原始20bytes哈希+网络类型+地址版本</span><br><span class="line">   +New(network Network, hash []byte) : Address</span><br><span class="line">    // 构建新地址：输入为22bytes的原始切片</span><br><span class="line">   +NewFromBytes(raw []byte) : Address, error</span><br><span class="line">    // 通过41bytes的字串串生成22bytes的原始地址</span><br><span class="line">   +NewFromString(s string) : Address, error</span><br><span class="line">    // 构建新地址：输入为原始20bytes哈希,调用New</span><br><span class="line">   +NewMainnet(hash []byte) : Address</span><br><span class="line">    // 生成测试网络地址,输入为原始哈希再次哈希,被MakeTestAddress调用</span><br><span class="line">   +NewTestnet(hash []byte) : Address</span><br><span class="line">    // 校验41bytes地址的合法性</span><br><span class="line">   +ParseError(addr string) : error</span><br><span class="line"></span><br><span class="line">    // base32编码校验码生成，结果为6bytes</span><br><span class="line">   -createChecksum(hrp string, data []byte) : []byte</span><br><span class="line">    // 解码</span><br><span class="line">   -decode(addr string) : string, byte, []byte, error</span><br><span class="line">    // 编码</span><br><span class="line">   -encode(hrp string, version byte, data []byte) : string, error</span><br><span class="line">   -hrpExpand(hrp string) : []byte</span><br><span class="line">   -init()</span><br><span class="line">   -polymod(values []byte) : uint32</span><br><span class="line">    // 校验和验证</span><br><span class="line">   -verifyChecksum(hrp string, data []byte) : bool</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location: address/set.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    address</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   -addrSetEntry</span><br><span class="line"></span><br><span class="line">   // 地址集合</span><br><span class="line"> +Set : map[Address]</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   -init()</span><br></pre></td></tr></table></figure><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><ul><li>对外提供功能<ul><li>提供对内存中配置的实例化操作</li><li>对具体实例的设置和读取</li><li>对配置文件的读写</li><li>包含API、启动、数据存储、网络连接、挖矿、钱包、心跳相关配置</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    config</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">    // 对特定参数的合法性校验规则集合</span><br><span class="line">    // 1 目前只是限定昵称为字符</span><br><span class="line">   +Validators</span><br><span class="line"></span><br><span class="line">▼+APIConfig : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 是否允许跨域请求</span><br><span class="line">   +AccessControlAllowCredentials : bool</span><br><span class="line">    // 允许的方法列表</span><br><span class="line">   +AccessControlAllowMethods : []string</span><br><span class="line">    // 允许的元列表</span><br><span class="line">   +AccessControlAllowOrigin : []string</span><br><span class="line">    // 地址</span><br><span class="line">   +Address : string</span><br><span class="line">    [functions]</span><br><span class="line">    // 实例化APIconfig</span><br><span class="line">   -newDefaultAPIConfig() : *APIConfig</span><br><span class="line"></span><br><span class="line">▼+BootstrapConfig : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 启动地址集合</span><br><span class="line">   +Addresses : []string</span><br><span class="line">    // 最小节点阈值</span><br><span class="line">   +MinPeerThreshold : int</span><br><span class="line">    // 启动时间阈值，目前为10s</span><br><span class="line">   +Period : string</span><br><span class="line">    [functions]</span><br><span class="line">    //　实例化启动配置的接口</span><br><span class="line">   -newDefaultBootstrapConfig() : *BootstrapConfig</span><br><span class="line"></span><br><span class="line">    // 存储在内存之中的filecoin配置</span><br><span class="line">▼+Config : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // API相关</span><br><span class="line">   +API : *APIConfig</span><br><span class="line">    // 启动相关</span><br><span class="line">   +Bootstrap : *BootstrapConfig</span><br><span class="line">    // 数据存储相关</span><br><span class="line">   +Datastore : *DatastoreConfig</span><br><span class="line">    // 心跳相关</span><br><span class="line">   +Heartbeat : *HeartbeatConfig</span><br><span class="line">    // 挖矿相关</span><br><span class="line">   +Mining : *MiningConfig</span><br><span class="line">    // 网络连接相关</span><br><span class="line">   +Swarm : *SwarmConfig</span><br><span class="line">    // 钱包相关</span><br><span class="line">   +Wallet : *WalletConfig</span><br><span class="line">    [methods]</span><br><span class="line">    // 获取配置，参数为API的上述子结构</span><br><span class="line">   +Get(key string) : interface&#123;&#125;, error</span><br><span class="line">    // 设置配置，参数为API的上述子结构</span><br><span class="line">   +Set(dottedKey string, jsonString string) : error</span><br><span class="line">    // 写对应目录的配置文件</span><br><span class="line">   +WriteFile(file string) : error</span><br><span class="line">    [functions]</span><br><span class="line">    // 实例化配置，会调用各字节口的实例化</span><br><span class="line">   +NewDefaultConfig() : *Config</span><br><span class="line">    // 读对应目录的配置文件</span><br><span class="line">   +ReadFile(file string) : *Config, error</span><br><span class="line"></span><br><span class="line">▼+DatastoreConfig : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 路径</span><br><span class="line">   +Path : string</span><br><span class="line">    // 类型</span><br><span class="line">   +Type : string</span><br><span class="line">    [functions]</span><br><span class="line">   -newDefaultDatastoreConfig() : *DatastoreConfig</span><br><span class="line"></span><br><span class="line">▼+HeartbeatConfig : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 心跳周期</span><br><span class="line">   +BeatPeriod : string</span><br><span class="line">    // 心跳目标</span><br><span class="line">   +BeatTarget : string</span><br><span class="line">    // 昵称</span><br><span class="line">   +Nickname : string</span><br><span class="line">    // 重连时间</span><br><span class="line">   +ReconnectPeriod : string</span><br><span class="line">    [functions]</span><br><span class="line">   -newDefaultHeartbeatConfig() : *HeartbeatConfig</span><br><span class="line"></span><br><span class="line">▼+MiningConfig : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 自动密封间隔周期</span><br><span class="line">   +AutoSealIntervalSeconds : uint</span><br><span class="line">    // 区块签名地址</span><br><span class="line">   +BlockSignerAddress : address.Address</span><br><span class="line">    // 矿工地址</span><br><span class="line">   +MinerAddress : address.Address</span><br><span class="line">    // 存储报价</span><br><span class="line">   +StoragePrice : *types.AttoFIL</span><br><span class="line">    [functions]</span><br><span class="line">   -newDefaultMiningConfig() : *MiningConfig</span><br><span class="line"></span><br><span class="line">▼+SwarmConfig : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 地址</span><br><span class="line">   +Address : string</span><br><span class="line">    // 转发地址</span><br><span class="line">   +PublicRelayAddress : string</span><br><span class="line">    [functions]</span><br><span class="line">   -newDefaultSwarmConfig() : *SwarmConfig</span><br><span class="line"></span><br><span class="line">▼+WalletConfig : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 默认钱包地址</span><br><span class="line">   +DefaultAddress : address.Address</span><br><span class="line">    [functions]</span><br><span class="line">   -newDefaultWalletConfig() : *WalletConfig</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   -validate(dottedKey string, jsonString string) : error</span><br><span class="line">   -validateLettersOnly(key string, value string) : error</span><br></pre></td></tr></table></figure><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><ul><li>对外提供功能<ul><li>生成私钥接口</li><li>签名接口</li><li>私钥转公钥接口</li><li>从签名消息中提取公钥接口</li><li>验证消息合法性接口</li><li>主要用于地址生成、钱包相关</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    crypto</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">    // 定义私钥长度32位</span><br><span class="line">   +PrivateKeyBytes</span><br><span class="line">    // 定义公钥长度65位</span><br><span class="line">   +PublicKeyBytes</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 从签名消息中恢复公钥</span><br><span class="line">   +EcRecover(msg, signature []byte) : []byte, error</span><br><span class="line">    // 比较私钥是否相同</span><br><span class="line">   +Equals(sk, other []byte) : bool</span><br><span class="line">    // 生成私钥,调用GenerateKeyFromSeed</span><br><span class="line">   +GenerateKey() : []byte, error</span><br><span class="line">    // 生成私钥</span><br><span class="line">   +GenerateKeyFromSeed(seed io.Reader) : []byte, error</span><br><span class="line">    // 由私钥得到公钥</span><br><span class="line">   +PublicKey(sk []byte) : []byte</span><br><span class="line">    // 使用私钥签名</span><br><span class="line">   +Sign(sk, msg []byte) : []byte, error</span><br><span class="line">    // 验证签名合法性</span><br><span class="line">   +Verify(pk, msg, signature []byte) : bool</span><br></pre></td></tr></table></figure><h2 id="util-convert"><a href="#util-convert" class="headerlink" title="util/convert"></a>util/convert</h2><ul><li>提供功能<br>  ToCid:转cid功能</li></ul><h2 id="functional-tests"><a href="#functional-tests" class="headerlink" title="functional-tests"></a>functional-tests</h2><ul><li>测试脚本</li></ul><h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><ul><li>通过ldflags注入,表示git提交版本号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Commit string</span><br></pre></td></tr></table></figure><h2 id="fixtures"><a href="#fixtures" class="headerlink" title="fixtures"></a>fixtures</h2><ul><li>提供功能<ul><li>定义不同网络启动相关地址</li><li>预先分配初始网络状态，比如代币的预先分配</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">▼ package</span><br><span class="line">    fixtures</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ constants</span><br><span class="line">    // 开发人员，开发网络启动相关地址</span><br><span class="line">   -nightlyFilecoinBootstrap0 : string</span><br><span class="line">   -nightlyFilecoinBootstrap1 : string</span><br><span class="line">   -nightlyFilecoinBootstrap2 : string</span><br><span class="line">   -nightlyFilecoinBootstrap3 : string</span><br><span class="line">   -nightlyFilecoinBootstrap4 : string</span><br><span class="line">    // 测试网络启动相关地址</span><br><span class="line">   -testFilecoinBootstrap0 : string</span><br><span class="line">   -testFilecoinBootstrap1 : string</span><br><span class="line">   -testFilecoinBootstrap2 : string</span><br><span class="line">   -testFilecoinBootstrap3 : string</span><br><span class="line">   -testFilecoinBootstrap4 : string</span><br><span class="line">    // 用户，开发网络启动相关地址</span><br><span class="line">   -userFilecoinBootstrap0 : string</span><br><span class="line">   -userFilecoinBootstrap1 : string</span><br><span class="line">   -userFilecoinBootstrap2 : string</span><br><span class="line">   -userFilecoinBootstrap3 : string</span><br><span class="line">   -userFilecoinBootstrap4 : string</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">    // 开发人员，开发网络启动相关地址</span><br><span class="line">   +DevnetNightlyBootstrapAddrs</span><br><span class="line">    // 测试网络启动相关地址</span><br><span class="line">   +DevnetTestBootstrapAddrs</span><br><span class="line">    // 用户，开发网络启动相关地址</span><br><span class="line">   +DevnetUserBootstrapAddrs</span><br><span class="line">    // 预生成测试网络地址集合</span><br><span class="line">   +TestAddresses : []string</span><br><span class="line">    // 预生成测试矿工账户集合</span><br><span class="line">   +TestMiners : []string</span><br><span class="line">    // 预生成地址的私钥</span><br><span class="line">   -testKeys : []string</span><br><span class="line"></span><br><span class="line">▼-detailsStruct : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 创世区块cid</span><br><span class="line">   +GenesisCid : cid.Cid</span><br><span class="line">   +Keys : []*types.KeyInfo</span><br><span class="line">   +Miners : []</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 预生成的Key文件路径</span><br><span class="line">   +KeyFilePaths() : []string</span><br><span class="line"></span><br><span class="line">    // 预生成信息</span><br><span class="line">    // 1 解析gen.json文件到detailsStruct结构体</span><br><span class="line">    // 2 追击Miners信息到TestMiners中</span><br><span class="line">   -init()</span><br></pre></td></tr></table></figure><ul><li>如下为gen.json文件,可据此预先给特定矿工分配代币</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;keys&quot;: 5,</span><br><span class="line">  &quot;preAlloc&quot;: [</span><br><span class="line">    &quot;1000000000000&quot;,</span><br><span class="line">    &quot;1000000000000&quot;,</span><br><span class="line">    &quot;1000000000000&quot;,</span><br><span class="line">    &quot;1000000000000&quot;,</span><br><span class="line">    &quot;1000000000000&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;miners&quot;: [&#123;</span><br><span class="line">    &quot;owner&quot;: 0,</span><br><span class="line">    &quot;power&quot;: 1</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filnet"><a href="#filnet" class="headerlink" title="filnet"></a>filnet</h2><ul><li>提供功能<ul><li>节点启动</li><li>定期检查连接节点，如果数量不够会链接随机节点</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location: filnet/address.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    filnet</span><br><span class="line"></span><br><span class="line">▼ imports</span><br><span class="line">    gx/ipfs/QmNTCey11oxhb1AxDnQBRHtdhap6Ctud872NjAYPYYXPuc/go-multiaddr</span><br><span class="line">    gx/ipfs/QmRhFARzTHcFh8wUxwN5KvyTGq73FLC65EfFAhz8Ng7aGb/go-libp2p-peerstore</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">    // 节点id转换为完整的节点信息，包括所有的多地址格式</span><br><span class="line">   +PeerAddrsToPeerInfos(addrs []string) : []pstore.PeerInfo, error</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">location: filnet/bootstrap.go</span><br><span class="line"></span><br><span class="line">▼ package</span><br><span class="line">    filnet</span><br><span class="line"></span><br><span class="line">▶ imports</span><br><span class="line"></span><br><span class="line">▼ variables</span><br><span class="line">   -log</span><br><span class="line"></span><br><span class="line">▼+Bootstrapper : struct</span><br><span class="line">    [fields]</span><br><span class="line">    // 对应bootstrap</span><br><span class="line">   +Bootstrap : func([]peer.ID)</span><br><span class="line">    // 连接超时时间，用于连接随机节点</span><br><span class="line">   +ConnectionTimeout : time.Duration</span><br><span class="line">    // 最小连接节点数量阈值</span><br><span class="line">   +MinPeerThreshold : int</span><br><span class="line">    // 定时检查连接节点数量,小于阈值会处理</span><br><span class="line">   +Period : time.Duration</span><br><span class="line">    // 随机节点切片</span><br><span class="line">   -bootstrapPeers : []pstore.PeerInfo</span><br><span class="line">   -cancel : context.CancelFunc</span><br><span class="line">   -ctx : context.Context</span><br><span class="line">   -d : inet.Dialer</span><br><span class="line">   -dhtBootStarted : bool</span><br><span class="line">   -h : host.Host</span><br><span class="line">   -r : routing.IpfsRouting</span><br><span class="line">   -ticker : *time.Ticker</span><br><span class="line">    [methods]</span><br><span class="line">    // 定时调用Bootstrap 检查连接节点数量,小于阈值会处理</span><br><span class="line">   +Start(ctx context.Context)</span><br><span class="line">    // 停止节点</span><br><span class="line">   +Stop()</span><br><span class="line">    // 如果启动节点不够，将会尝试连接随机节点。</span><br><span class="line">   -bootstrap(currentPeers []peer.ID)</span><br><span class="line">    [functions]</span><br><span class="line">    // 实例化</span><br><span class="line">   +NewBootstrapper(bootstrapPeers []pstore.PeerInfo, h host.Host, d inet.Dialer, r routing.IpfsRouting, minPeer int, period time.Duration) : *Bootstrapper</span><br><span class="line"></span><br><span class="line">▼ functions</span><br><span class="line">   -hasPID(pids []peer.ID, pid peer.ID) : bool</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是先河系统CTO杨尉，欢迎大加关注的的Github: &lt;a href=&quot;https://github.com/waynewyang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;waynewyang&lt;/a&gt;，本文是&lt;a href=&quot;https://learnblockchain.cn/2019/03/11/filecoin-code-analysis-0/&quot;&gt;filecoin技术架构分析系列文章&lt;/a&gt;第九章filecoin源码分析之支撑包分析(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/categories/FileCoin/"/>
    
    
      <category term="FileCoin" scheme="https://learnblockchain.cn/tags/FileCoin/"/>
    
  </entry>
  
</feed>
