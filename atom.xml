<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深入浅出区块链</title>
  
  <subtitle>系统学习区块链技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://learnblockchain.cn/"/>
  <updated>2018-06-21T01:32:19.673Z</updated>
  <id>https://learnblockchain.cn/</id>
  
  <author>
    <name>Tiny熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建智能合约开发环境Remix IDE及使用</title>
    <link href="https://learnblockchain.cn/2018/06/07/remix-ide/"/>
    <id>https://learnblockchain.cn/2018/06/07/remix-ide/</id>
    <published>2018-06-07T02:56:04.000Z</published>
    <updated>2018-06-21T01:32:19.673Z</updated>
    
    <content type="html"><![CDATA[<p>目前开发智能的IDE， 首推还是Remix, 而Remix<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a>, 总是由于各种各样的（网络）原因无法使用，本文就来介绍一下如何在本地搭建智能合约开发环境remix-ide并介绍Remix的使用。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Remix 是以太坊智能合约编程语言Solidity IDE，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果还不了解，建议先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>。</p><h2 id="Remix-IDE-介绍"><a href="#Remix-IDE-介绍" class="headerlink" title="Remix IDE 介绍"></a>Remix IDE 介绍</h2><p>Remix IDE 是一款基于浏览器的IDE，跟有些开发聊的时候，发现有一些同学对浏览器的IDE，有一些偏见，其实Atom编辑器就是基于web技术开发的一款编辑器（Atom可以看做一个没有地址栏的浏览器），其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。</p><p>Remix IDE的功能全面（传统IDE有的功能这里都有），比如：</p><ol><li>代码提示补全，代码高亮</li><li>代码警告、错误提示</li><li>运行日志输出</li><li>代码调试</li><li>…</li></ol><h2 id="Remix-IDE-安装"><a href="#Remix-IDE-安装" class="headerlink" title="Remix IDE 安装"></a>Remix IDE 安装</h2><blockquote><p>更新： Remix 现在提供了一个APP, 叫Remix APP， 如果是Mac 电脑，可以直接使用其提供的发布包，地址为：<a href="https://github.com/horizon-games/remix-app/releases" target="_blank" rel="noopener">https://github.com/horizon-games/remix-app/releases</a></p></blockquote><p>如果你有很好的网络环境，可以直接访问Remix<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a>。<br>要不能还是还是像我一样老老实实把Remix IDE安装在本地，我发现要想成功安装选择对应的版本很关键，具体的版本要求如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node --version</span><br><span class="line">v7<span class="number">.10</span><span class="number">.1</span></span><br><span class="line">$ npm --version</span><br><span class="line"><span class="number">4.2</span><span class="number">.0</span></span><br><span class="line">$ nvm --version</span><br><span class="line"><span class="number">0.33</span><span class="number">.11</span></span><br></pre></td></tr></table></figure><h3 id="nvm-安装"><a href="#nvm-安装" class="headerlink" title="nvm 安装"></a>nvm 安装</h3><p>nvm 是一个node 版本工具，我们可以使用nvm来安装不同版本的node。<br>nvm 官方<a href="https://github.com/creationix/nvm/blob/master/README.md" target="_blank" rel="noopener">安装方法</a>如下：</p><ol><li><p>命令行中输入：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br></pre></td></tr></table></figure></li><li><p>在当前用户profile文件，如（~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc）添加加载nvm的脚本：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span><br></pre></td></tr></table></figure></li><li><p>重启下命令行，输入nvm 试试，应该可以看到 nvm 命令的帮助</p></li></ol><h3 id="使用nvm-安装node"><a href="#使用nvm-安装node" class="headerlink" title="使用nvm 安装node"></a>使用nvm 安装node</h3><p>因为Remix IDE 要求使用node 7.10.1, 命令行输入一下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 7</span><br></pre></td></tr></table></figure><p>安装完成之后，使用node –version 和 npm –version检查下版本号，是否和刚刚列出版本要求一致，在版本一值的qing</p><h3 id="命令行安装Remix-ide"><a href="#命令行安装Remix-ide" class="headerlink" title="命令行安装Remix ide"></a>命令行安装Remix ide</h3><p><strong>方法1</strong><br>直接使用npm安装，这也是我安装使用的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install remix-ide -g</span><br><span class="line">remix-ide</span><br></pre></td></tr></table></figure></p><p>如果出现错误：<br>Error: EACCES: permission denied, access ‘/usr/local/lib/node_modules’<br>可以尝试用以下方法解决：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们使用的是正确的node 和npm 版本的话，应该都可以安装成功，安装成功之后，remix-ide命令用来启动ide.</p><p><strong>方法2</strong><br>remix-ide的github 上还提供了另一个方法进行安装，通过clone 代码来安装，方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ethereum/remix-ide.git</span><br><span class="line"><span class="built_in">cd</span> remix-ide</span><br><span class="line">npm install</span><br><span class="line">npm run setupremix  <span class="comment"># this will clone https://github.com/ethereum/remix for you and link it to remix-ide</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h2 id="Remix-ide-使用"><a href="#Remix-ide-使用" class="headerlink" title="Remix ide 使用"></a>Remix ide 使用</h2><p>Remix IDE 默认是使用8080端口启动的，启动之后在浏览器打开：<code>http://localhost:8080/</code>, 如图：</p><p><img src="/images/remix-setup.jpg" alt=""></p><p>和大多数IDE一样，最左边是文件浏览，中间是代码编辑区域，右边是功能区域，下边是日志区域。<br>在右侧的功能区域，常用的是<code>Compile</code>、<code>Run</code>及<code>Debuger</code>几个标签页（Tab）。</p><p>在<code>Compile</code>页，会动态的显示当前编辑区域合约的编译信息，如显示错误和警告。编译的直接码信息及ABI接口可以通过点击<code>Details</code>查看到。<br>在<a href="https://learnblockchain.cn/2017/11/24/init-env/">这篇文章里</a> 也有截图说明。<br>在<code>Run</code>页，可以部署合约，以及调用合约函数等，使用非常简单，我们前面也有多篇文章讲解。<br><code>Debuger</code>页在下面调试一节单独讲解。</p><h3 id="Remix-ide-加载本地磁盘文件"><a href="#Remix-ide-加载本地磁盘文件" class="headerlink" title="Remix ide 加载本地磁盘文件"></a>Remix ide 加载本地磁盘文件</h3><p>这是一个非常用的功能，但发现使用的人非常少，通过加载本地磁盘文件，就可以方便代码管理工具（如 git）管理我们的合约代码。<br>我详细介绍下如何这个功能怎么使用？</p><blockquote><p>使用在线版本的Remix可以使用这个功能， 不过需要安装一下<a href="https://github.com/ethereum/remixd" target="_blank" rel="noopener">remixd</a>, 安装使用命令<code>npm install -g remixd</code>。</p></blockquote><ol><li><p>在需要的本地合约代码的目录下启动<code>remix-ide</code>, Remix IDE 会自动把当前目录做为共享目录。如果是使用在线的Remix，需要使用命令<code>remixd -s shared-folder</code> 来指定共享目录。</p></li><li><p>加载共享目录，在文件浏览区域上有，有这样一个图标，他用来加载本地共享目录，如图：<br><img src="https://learnblockchain.cn/images/remixd_connectionok.png" alt=""></p></li></ol><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在合约编写过程中，合约调试是必不可少的一部分，为了模拟调试的过程，我故意在代码中加入一ge错误的逻辑代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line">​</span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    </span><br><span class="line">    uint storedData;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData += x;    <span class="comment">// 错误的，多加了一个加号</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入了错误的逻辑之后，我第2次调用set函数，合约状态变量的值，可能会出错（如果第一次不是用参数0去调用的话）。<br>注意如果需要调试合约，在部署合约的环境应该选择：JavaScript VM。</p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>在我们每次执行一个交易（不管是方式调用还是函数执行）的时候，在日志都会输出一条记录，如图：<br><img src="https://learnblockchain.cn/images/remix-debug-console.png" alt=""></p><p>点击上图中的“Debug”按钮，在Remix右侧的功能区域会切换到调试面板，如下图：<br><img src="/images/remix-debug-panel.png" alt=""><br>调试过程过程中，有下面几项需要重点关注：</p><ul><li><p>Transactions: 可以查看交易及交易的执行过程，并且提供了7个调试的按钮，如下图：<br><img src="https://learnblockchain.cn/images/remix-debug-buttons.png" alt=""></p><p>  为了方便介绍，我为每个按钮编了号，每个按钮的含义是：</p><ol><li>后退一步（不进入函数内部）</li><li>后退一步（进入函数内部）</li><li>前进一步（进入函数内部）</li><li>前进一步（不进入函数内部）</li><li>跳到上一个断点</li><li>跳出当前调用</li><li>跳到下一个断点</li></ol></li><li>Solidity Locals：显示当前上下文的局部变量的值， 如图：</li></ul><p><img src="https://learnblockchain.cn/images/remix-debug-locals.png" alt=""></p><ul><li>Solidity State： 显示当前执行合约的状态变量，如下图:<br><img src="https://learnblockchain.cn/images/remix-debug-state.png" alt=""></li></ul><p>在本例中，我们跟踪运行步骤的时候，可以看到局部变量的值为2，赋值给状态变量之后，状态变量的值更改为了3，所以可以判断运行当前语句的时候出错了。</p><ul><li>Step detail： 显示当前步骤的gas详情等，如下图:<br><img src="https://learnblockchain.cn/images/remix-debug-gas.png" alt=""></li></ul><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>这部分为小专栏读者准备，欢迎订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/ethereum/remix-ide" target="_blank" rel="noopener">remix-ide github</a></li><li><a href="http://remix.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Remix Document</a></li></ol><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你学习区块链中遇到问题，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>问答社区，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。</p><!---在本例中，我们的代码比较简单，执行的不多，可以不用设置断点，如果代码比较多，这可以设置断点，利用上面介绍的第7个按钮快速的调转到断点处，设置断点的方法很简单，在编辑区域，点击代码的行号，就可以在当前行设置一个断点，如下图：![](/images/remix-debug-break.png)上图在第8行出设置了一个断点，成功设置断点会在行号处，加上一个色块来标示断点。取消断点的方式是，再次点击断点处。有一点需要注意一下，如果在声明变量的地方设置断点，这断点可能会触发两次，第一次是初始化为0，第二次是赋实际的值。-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前开发智能的IDE， 首推还是Remix, 而Remix&lt;a href=&quot;https://remix.ethereum.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;, 总是由于各种各样的（网络）原因无法使用，本文就来介绍一下如何在本地搭建智能合约开发环境remix-ide并介绍Remix的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="IDE" scheme="https://learnblockchain.cn/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Solidity 教程系列11 - 视图函数、虚函数讲解</title>
    <link href="https://learnblockchain.cn/2018/05/17/solidity-functions/"/>
    <id>https://learnblockchain.cn/2018/05/17/solidity-functions/</id>
    <published>2018-05-17T14:16:29.000Z</published>
    <updated>2018-05-17T15:23:43.135Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第11篇 - Solidity 视图函数、虚函数讲解。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="视图函数（View-Functions）"><a href="#视图函数（View-Functions）" class="headerlink" title="视图函数（View Functions）"></a>视图函数（View Functions）</h2><p>一个函数如果它不修改状态变量，应该声明为<strong>view</strong>函数，不过下面几种情况认为是修改了状态：</p><ol><li>写状态变量</li><li>触发事件（events）</li><li>创建其他的合约</li><li>call调用附加了以太币</li><li>调用了任何没有<strong>view</strong>或<strong>pure</strong>修饰的函数</li><li>使用了低级别的调用（low-level calls）</li><li>使用了包含特定操作符的内联汇编</li></ol><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>) + now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误做法，虽然可以编译通过</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">df</span>(<span class="params">uint a</span>) <span class="title">public</span> <span class="title">view</span>  </span>&#123;</span><br><span class="line">        data = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个地方需要注意一下：</p><ol><li>声明为<strong>view</strong> 和声明为<strong>constant</strong>是等价的，constant是view的别名，constant在计划Solidity 0.5.0版本之后会弃用（constant这个词有歧义，view 也更能表达返回值可视）。</li><li>访问函数都被标记为view。</li></ol><p>当前编译器并未强制要求声明为view，但建议大家对于不会修改状态的函数的标记为view。</p><h2 id="纯函数（Pure-Functions）"><a href="#纯函数（Pure-Functions）" class="headerlink" title="纯函数（Pure Functions）"></a>纯函数（Pure Functions）</h2><p>函数可以声明为<strong>view</strong>，表示它即不读取状态，也不修改状态，除了上一节介绍的几种修改状态的情况，以下几种情况被认为是读取了状态：</p><ol><li>读状态变量</li><li>访问了 <strong>this.balance</strong> 或 <strong>\<address>.balance</address></strong></li><li>访问了<strong>block</strong>, <strong>tx</strong>, <strong>msg</strong> 的成员 (msg.sig 和 msg.data除外).</li><li>调用了任何没有<strong>pure</strong>修饰的函数</li><li>使用了包含特定操作符的内联汇编</li></ol><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管view 和 pure 修饰符编译器并未强制要求使用，view 和 pure 修饰也不会带来gas 消耗的改变，但是更好的编码习惯让我们跟容易发现智能合约中的错误。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/develop/contracts.html#functions" target="_blank" rel="noopener">官方文档-函数</a></p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了200多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第11篇 - Solidity 视图函数、虚函数讲解。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/Solidity/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>详解 Solidity 事件Event - 完全搞懂事件的使用</title>
    <link href="https://learnblockchain.cn/2018/05/09/solidity-event/"/>
    <id>https://learnblockchain.cn/2018/05/09/solidity-event/</id>
    <published>2018-05-09T12:37:03.000Z</published>
    <updated>2018-05-10T13:49:31.287Z</updated>
    
    <content type="html"><![CDATA[<p>很多同学对Solidity 中的Event有疑问，这篇文章就来详细的看看Solidity 中Event到底有什么用？</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>，另外<br>本文在监听合约事件是对上一篇<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>进行补充，如果阅读了上一篇可以更好的理解本文。</p><h2 id="什么是事件Evnet"><a href="#什么是事件Evnet" class="headerlink" title="什么是事件Evnet"></a>什么是事件Evnet</h2><p>事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并记录到区块链中.<br>来捋这个关系：区块链是打包一系列交易的区块组成的链条，每一个交易“收据”会包含0到多个日志记录，日志代表着智能合约所触发的事件。</p><p><strong>在DAPP的应用中，如果监听了某事件，当事件发生时，会进行回调。</strong><br>不过要注意：日志和事件在合约内是无法被访问的，即使是创建日志的合约。</p><p>在Solidity 代码中，使用event 关键字来定义一个事件，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event EventName(address bidder, uint amount);</span><br></pre></td></tr></table></figure><p>这个用法和定义函数式一样的，并且事件在合约中同样可以被继承。触发一个事件使用emit(说明，之前的版本里并不需要使用emit)，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emit EventName(msg.sender, msg.value);</span><br></pre></td></tr></table></figure><p>触发事件可以在任何函数中调用，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testEvent</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发一个事件</span></span><br><span class="line">     emit EventName(msg.sender, msg.value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>通过上面的介绍，可能大家还是不清楚事件有什么作用，如果你跟过<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>这篇文章，你会发现点击”Updata Info”按钮之后，虽然调用智能合约成功，但是当前的界面并没有得到更新。<br>使用事件监听，就可以很好的解决这个问题，让看看如何实现。</p><h3 id="修改合约，定义事件及触发事件"><a href="#修改合约，定义事件及触发事件" class="headerlink" title="修改合约，定义事件及触发事件"></a>修改合约，定义事件及触发事件</h3><p>先回顾一下合约代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract InfoContract &#123;</span><br><span class="line">    </span><br><span class="line">   string fName;</span><br><span class="line">   uint age;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">       fName = _fName;</span><br><span class="line">       age = _age;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">string, uint</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (fName, age);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，需要定义一个事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">event Instructor(</span><br><span class="line">      string name,</span><br><span class="line">      uint age</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>这个事件中，会接受两个参数：name 和  age , 也就是需要跟踪的两个信息。</p><p>然后，需要在setInfo函数中，触发Instructor事件，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    fName = _fName;</span><br><span class="line">    age = _age;</span><br><span class="line">    emit Instructor(_fName, _age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>, 点击”Updata Info”按钮之后，会调用setInfo函数，函数时触发Instructor事件。</p><h3 id="使用Web3监听事件，刷新UI"><a href="#使用Web3监听事件，刷新UI" class="headerlink" title="使用Web3监听事件，刷新UI"></a>使用Web3监听事件，刷新UI</h3><p>现在需要使用Web3监听事件，刷新UI。<br>先回顾下之前的使用Web3和智能合约交互的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">"http://localhost:7545"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> infoContract = web3.eth.contract(ABI INFO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> info = infoContract.at(<span class="string">'CONTRACT ADDRESS'</span>);</span><br><span class="line"></span><br><span class="line">    info.getInfo(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!error)</span><br><span class="line">            &#123;</span><br><span class="line">                $(<span class="string">"#info"</span>).html(result[<span class="number">0</span>]+<span class="string">' ('</span>+result[<span class="number">1</span>]+<span class="string">' years old)'</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(result);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">"#button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        info.setInfo($(<span class="string">"#name"</span>).val(), $(<span class="string">"#age"</span>).val());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>现在可以不需要 info.getInfo()来获取信息，而改用监听事件获取信息，先定义一个变量引用事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor();</span><br></pre></td></tr></table></figure><p>然后使用<strong>.watch()</strong>方法来添加一个回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">instructorEvent.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            &#123;</span><br><span class="line">                $(<span class="string">"#info"</span>).html(result.args.name + <span class="string">' ('</span> + result.args.age + <span class="string">' years old)'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(error);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>代码更新之后，可以在浏览器查看效果，这是点击”Updata Info”按钮之后，会及时更新界面，如图：<br><img src="/images/solidity_event.jpg" alt=""></p><p>完整的代码请订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="事件高级用法-过滤器"><a href="#事件高级用法-过滤器" class="headerlink" title="事件高级用法-过滤器"></a>事件高级用法-过滤器</h2><p>有时我们会有这样的需求：获取当前所有姓名及年龄记录，或者是，要过滤出年龄28岁的记录，应该如何做呢？<br>以及另外一个常见的场景：想要获取到代币合约中所有的转账记录，也同样需要使用事件过滤器功能，这部分内容请大家订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>阅读。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://coursetro.com/posts/code/100/Solidity-Events-Tutorial---Using-Web3.js-to-Listen-for-Smart-Contract-Events" target="_blank" rel="noopener">https://coursetro.com/posts/code/100/Solidity-Events-Tutorial---Using-Web3.js-to-Listen-for-Smart-Contract-Events</a><br><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。</p><!-- 有时我们会有这样的需求：获取当前所有姓名及年龄记录，应该如何做呢？实际上事件支持过滤器，可以从所有的区块中过滤出符合要求的事件，如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor(&#123;&#125;, &#123;<span class="attr">fromBlock</span>: <span class="number">0</span>, <span class="attr">toBlock</span>: <span class="string">'latest'</span>&#125;);</span><br></pre></td></tr></table></figure><p>或者是，要过滤出年龄28岁的记录，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor(&#123; <span class="string">'age'</span>: <span class="number">28</span>&#125;);</span><br></pre></td></tr></table></figure><p>比如，我们要获取到代币合约中，所有的转账记录， 就可以使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transferEvent = token.Transfer(&#123;&#125;, &#123;<span class="attr">fromBlock</span>: <span class="number">0</span>, <span class="attr">toBlock</span>: <span class="string">'latest'</span>&#125;)</span><br><span class="line"><span class="keyword">var</span> transferEvent.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// handle result.args.from  result.args.to</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> –&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多同学对Solidity 中的Event有疑问，这篇文章就来详细的看看Solidity 中Event到底有什么用？&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
      <category term="Event" scheme="https://learnblockchain.cn/tags/Event/"/>
    
      <category term="web3" scheme="https://learnblockchain.cn/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>智能合约最佳实践 之 Solidity 编码规范</title>
    <link href="https://learnblockchain.cn/2018/05/04/solidity-style-guide/"/>
    <id>https://learnblockchain.cn/2018/05/04/solidity-style-guide/</id>
    <published>2018-05-04T02:22:08.000Z</published>
    <updated>2018-05-07T06:42:11.127Z</updated>
    
    <content type="html"><![CDATA[<p>每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。</p><a id="more"></a><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="避免使用"><a href="#避免使用" class="headerlink" title="避免使用"></a>避免使用</h3><p>小写的l，大写的I，大写的O 应该避免在命名中单独出现，因为很容易产生混淆。</p><h3 id="合约、库、事件、枚举及结构体命名"><a href="#合约、库、事件、枚举及结构体命名" class="headerlink" title="合约、库、事件、枚举及结构体命名"></a>合约、库、事件、枚举及结构体命名</h3><p>  合约、库、事件及结构体命名应该使用单词首字母大写的方式，这个方式也称为：帕斯卡命名法或大驼峰式命名法，比如：SimpleToken， SmartBank， CertificateHashRepository，Player。</p><h3 id="函数、参数、变量及修饰器"><a href="#函数、参数、变量及修饰器" class="headerlink" title="函数、参数、变量及修饰器"></a>函数、参数、变量及修饰器</h3><p>函数、参数、变量及修饰器应该使用首单词小写后面单词大写的方式，这个方式也称为：（小）驼峰式命名法，是一种混合大小写的方式，如：</p><ul><li>函数名应该如：getBalance，transfer，verifyOwner，addMember。</li><li>参数和变量应该如：initialSupply，senderAddress，account，isPreSale。</li><li>修饰器应该如：onlyAfter，onlyOwner。</li></ul><h2 id="代码格式相关"><a href="#代码格式相关" class="headerlink" title="代码格式相关"></a>代码格式相关</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>使用空格（spaces）而不是Tab, 缩进应该是4个空格</p><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>合约之间应该有空行，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数之间应该有空行，例如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有实现的话，空行可以省去，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左括号应该跟定义在一行"><a href="#左括号应该跟定义在一行" class="headerlink" title="左括号应该跟定义在一行"></a>左括号应该跟定义在一行</h3><p>定义包括合约定义、函数定义、库定义、结构体定义等等，例如推荐使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> contract Coin &#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Coin</span><br><span class="line">&#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左括号应该跟条件控制在一行"><a href="#左括号应该跟条件控制在一行" class="headerlink" title="左括号应该跟条件控制在一行"></a>左括号应该跟条件控制在一行</h3><p>在使用if, else, while, for 时，推荐的写法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    ...;&#125;</span><br></pre></td></tr></table></figure><p>如果控制语句内只有一行，括号可省略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">    x += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但像下面一个语句有多方就不能省略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">    someArray.push(Coin(&#123;</span><br><span class="line">        name: <span class="string">'spam'</span>,</span><br><span class="line">        value: <span class="number">42</span></span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure><h3 id="表达式内的空格"><a href="#表达式内的空格" class="headerlink" title="表达式内的空格"></a>表达式内的空格</h3><ul><li><p>一个单行的表达里，在小括号、中括号、大括号里应该避免不必要的空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam(ham[<span class="number">1</span>], Coin(&#123;<span class="attr">name</span>: <span class="string">"ham"</span>&#125;));</span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam( ham[ <span class="number">1</span> ], Coin( &#123; <span class="attr">name</span>: <span class="string">"ham"</span> &#125; ) );</span><br></pre></td></tr></table></figure>有一种例外是，结尾的括号跟在结束的分号后面， 应该加一个空格，如下面的方式也是推荐的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleLine</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123; spam(); &#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>分号；前不应该有空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params">uint i, Coin coin</span>) <span class="title">public</span>;</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params">uint i , Coin coin</span>) <span class="title">public</span> ;</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p>不要为对齐添加不必要的空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line">long_variable = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x             = <span class="number">1</span>;</span><br><span class="line">y             = <span class="number">2</span>;</span><br><span class="line">long_variable = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>回退函数不应该有空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而不是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="控制每一行长度"><a href="#控制每一行长度" class="headerlink" title="控制每一行长度"></a>控制每一行长度</h3><p>每行不应该太长，最好在79（或99）个字符以内，函数的参数应该是单独的行，且只有一个缩进，例如推荐的方式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">                              longArgument2,</span><br><span class="line">                              longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1, longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">longArgument1,</span><br><span class="line">longArgument2,</span><br><span class="line">longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3);</span><br></pre></td></tr></table></figure><p>对应的赋值语句应该是这样写：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> thisIsALongNestedMapping[being][set][to_some_value] = someFunction(</span><br><span class="line">    argument1,</span><br><span class="line">    argument2,</span><br><span class="line">    argument3,</span><br><span class="line">    argument4</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1,</span><br><span class="line">                                                                   argument2,</span><br><span class="line">                                                                   argument3,</span><br><span class="line">                                                                   argument4);</span><br></pre></td></tr></table></figure><p>事件定义也应该遵循同样的原则，例如应该使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(</span><br><span class="line">    adress sender,</span><br><span class="line">    adress recipient,</span><br><span class="line">    uint256 publicKey,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes32[] options</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(</span><br><span class="line">    sender,</span><br><span class="line">    recipient,</span><br><span class="line">    publicKey,</span><br><span class="line">    amount,</span><br><span class="line">    options</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(adress sender,</span><br><span class="line">                        adress recipient,</span><br><span class="line">                        uint256 publicKey,</span><br><span class="line">                        uint256 amount,</span><br><span class="line">                        bytes32[] options);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(sender,</span><br><span class="line">                  recipient,</span><br><span class="line">                  publicKey,</span><br><span class="line">                  amount,</span><br><span class="line">                  options);</span><br></pre></td></tr></table></figure><h3 id="文件编码格式"><a href="#文件编码格式" class="headerlink" title="文件编码格式"></a>文件编码格式</h3><p>推荐使用utf-8 及 ASCII 编码</p><h3 id="引入文件应该在最上方"><a href="#引入文件应该在最上方" class="headerlink" title="引入文件应该在最上方"></a>引入文件应该在最上方</h3><p>建议使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"owned"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"owned"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数编写规范"><a href="#函数编写规范" class="headerlink" title="函数编写规范"></a>函数编写规范</h2><h3 id="函数的顺序"><a href="#函数的顺序" class="headerlink" title="函数的顺序"></a>函数的顺序</h3><p>在编写函数的时候，应该让大家容易找到构造函数，回退函数，官方推荐的的函数顺序是：</p><ol><li>构造函数</li><li>回退函数 (如果有)</li><li>外部函数（external）</li><li>公有函数(public)</li><li>内部函数(internal)</li><li>私有函数（private）</li></ol><p>同一类函数时，constant函数放在后面， 例如推荐方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> contract A &#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回退函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带有constant 外部函数 </span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是下面的函数顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> contract A &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="明确函数的可见性"><a href="#明确函数的可见性" class="headerlink" title="明确函数的可见性"></a>明确函数的可见性</h3><p>所有的函数（包括构造函数）应该在定义的时候明确函数的可见性，例如应该使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">explicitlyPublic</span>(<span class="params">uint val</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">implicitlyPublic</span>(<span class="params">uint val</span>) </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可见性应该在修饰符前面"><a href="#可见性应该在修饰符前面" class="headerlink" title="可见性应该在修饰符前面"></a>可见性应该在修饰符前面</h3><p>函数的可见性应该写在自定义的函数修饰符前面，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyowner</span> </span>&#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) <span class="title">onlyowner</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区分函数和事件"><a href="#区分函数和事件" class="headerlink" title="区分函数和事件"></a>区分函数和事件</h3><p>为了防止函数和事件（Event）产生混淆，声明一个事件使用大写并加入前缀（可使用LOG）。对于函数， 始终以小写字母开头，构造函数除外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议</span></span><br><span class="line">event Transfer() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议</span></span><br><span class="line">event LogTransfer() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量应该使用全大写及下划线分割大词的方式，如：MAX_BLOCKS，TOKEN_NAME， CONTRACT_VERSION。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/v0.4.23/style-guide.html" target="_blank" rel="noopener">Solidity style-guide</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>美链BEC合约漏洞技术分析</title>
    <link href="https://learnblockchain.cn/2018/04/25/bec-overflow/"/>
    <id>https://learnblockchain.cn/2018/04/25/bec-overflow/</id>
    <published>2018-04-25T02:13:07.000Z</published>
    <updated>2018-04-26T01:49:16.484Z</updated>
    
    <content type="html"><![CDATA[<p>这两天币圈链圈被美链BEC智能合约的漏洞导致代币价值几乎归零的事件刷遍朋友圈。这篇文章就来分析下BEC智能合约的漏洞</p><a id="more"></a><h2 id="漏洞攻击交易"><a href="#漏洞攻击交易" class="headerlink" title="漏洞攻击交易"></a>漏洞攻击交易</h2><p>我们先来还原下攻击交易，这个交易可以在这个<a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f" target="_blank" rel="noopener">链接</a>查询到。<br>我截图给大家看一下：<br><img src="https://learnblockchain.cn/images/BEC_transfer.jpg" alt=""></p><p>攻击者向两个账号转移57896044618…000.792003956564819968个BEC，相当于BEC凭空进行了一个巨大的增发，几乎导致BEC价格瞬间归零。<br>下面我们来分析下这个攻击过程。</p><h2 id="合约漏洞分析"><a href="#合约漏洞分析" class="headerlink" title="合约漏洞分析"></a>合约漏洞分析</h2><p>我们先来看看<a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" target="_blank" rel="noopener">BEC智能合约的代码</a>，<br>BEC在合约中加入一个批量转账的函数，它的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchTransfer</span>(<span class="params">address[] _receivers, uint256 _value</span>) <span class="title">public</span> <span class="title">whenNotPaused</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    uint cnt = _receivers.length;</span><br><span class="line">    uint256 amount = uint256(cnt) * _value;</span><br><span class="line">    <span class="built_in">require</span>(cnt &gt; <span class="number">0</span> &amp;&amp; cnt &lt;= <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">require</span>(_value &gt; <span class="number">0</span> &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(amount);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        balances[_receivers[i]] = balances[_receivers[i]].add(_value);</span><br><span class="line">        Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是，调用者传入若干个地址和转账金额，在经过一些条件检查之后，对msg.sender的余额进行减操作，对每一个对每一个传入的地址进行加操作，以实现BEC的转移。<br>问题出在 <code>uint256 amount = uint256(cnt) * _value;</code> 这句代码，当传入值<code>_value</code>过大时（接近uint256的取值范围的最大值），<code>uint256 amount = uint256(cnt) * _value</code>计算时会发生溢出，导致amount实际的值是一个非常小的数（此时amount不再是<code>cnt * _value</code>的实际值），amount很小，也使得后面对调用者余额校验可正常通过（即<code>require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount)</code>语句通过）。</p><p>我们来结合实际攻击交易使用的参数来分析一下：</p><p><img src="https://learnblockchain.cn/images/BEC_transfer_params.jpg" alt=""></p><p><code>batchTransfer</code>的参数<code>_value</code>值为16进制的<code>800000000000000000000...</code>，参数<code>_receivers</code>数组的大小为2，相乘之后刚好可超过uint256所能表示的整数大小上限，引发溢出问题<code>amount</code>实际的值为0，后面的转账操作实际上msg.sender的余额减0， 而对两个账号进行了加16进制的<code>800000000000000000000...</code>，最终的结果是相当于增发了2 * 16进制的<code>800000000000000000000...</code>。</p><p>实际上对于这种整数溢出漏洞，最简单的方法是采用 SafeMath 数学计算库来避免。有趣的是BEC智能合约代码中，其实其他的都使用了SafeMath， 而关键的<code>uint256 amount = uint256(cnt) * _value</code>却没有使用。<br>心痛程序员，也心痛韭菜。这句代码改为<code>uint256 amount = _value.mul(uint256(cnt));</code>就可以防止溢出问题</p><p>所以在做加减乘除的时候请记得一定使用：SafeMath，代码在<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" target="_blank" rel="noopener">这里</a></p><h2 id="溢出补充说明"><a href="#溢出补充说明" class="headerlink" title="溢出补充说明"></a>溢出补充说明</h2><p>溢出补充说明为小专栏订阅用户福利，小专栏的文章内介绍了什么时候会发生上溢，什么时候会发生下溢，并且给出了代码事例。<br>大家可请前往我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>阅读。</p><p>知识星球<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a></strong>做好的区块链技术问答社区，欢迎来提问，作为星球成员福利，成员可加入区块链技术付费交流群。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><!--Solidity最大可以处理256位数字, 最大值为 `2**256 - 1`, 对(`2**256 - 1`) 加1的结果会溢出归0。`2**255` 乘2也同样会溢出归0。对无符号类型最小值是零，对零做减1会得到 (`2**256 - 1`)。我们用一段代码验证一下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity <span class="number">0.4</span><span class="number">.20</span>;</span><br><span class="line">contract TestFlow &#123;</span><br><span class="line">    uint256 public zero = <span class="number">0</span>;</span><br><span class="line">    uint256 public max = <span class="number">2</span>**<span class="number">256</span> - <span class="number">1</span>;</span><br><span class="line">    uint256 public mm = <span class="number">2</span>**<span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subUnderFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  zero - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addOverFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  max + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mulOverFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  mm * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约部署和运行，之前已经经过很多次，我直接贴运行结果：<br><img src="https://learnblockchain.cn/images/BEC_transfer_flow.jpg" alt=""></p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天币圈链圈被美链BEC智能合约的漏洞导致代币价值几乎归零的事件刷遍朋友圈。这篇文章就来分析下BEC智能合约的漏洞&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Web3与智能合约交互实战</title>
    <link href="https://learnblockchain.cn/2018/04/15/web3-html/"/>
    <id>https://learnblockchain.cn/2018/04/15/web3-html/</id>
    <published>2018-04-15T13:24:16.000Z</published>
    <updated>2018-05-10T03:46:26.625Z</updated>
    
    <content type="html"><![CDATA[<p>Web3与智能合约交互实战</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在最初学习以太坊的时候，很多人都是自己创建以太坊节点后，使用geth与之交互。这种使用命令行交互的方法虽然让很多程序员感到兴奋（黑客帝国的既视感？），但不可能指望普通用户通过命令行使用Dapp。因此，我们需要一种友好的方式（比如一个web页面）来与智能合约交互，于是问题的答案就是<code>web3.js</code>。</p><h2 id="Web3-js"><a href="#Web3-js" class="headerlink" title="Web3.js"></a>Web3.js</h2><p><a href="https://web3js.readthedocs.io/en/1.0/" target="_blank" rel="noopener">Web3.js</a>是以太坊官方的Javascript API，可以帮助智能合约开发者使用HTTP或者IPC与本地的或者远程的以太坊节点交互。实际上就是一个库的集合，主要包括下面几个库：</p><ul><li><code>web3-eth</code>用来与以太坊区块链和智能合约交互</li><li><code>web3-shh</code>用来控制whisper协议与p2p通信以及广播</li><li><code>web3-bzz</code>用来与swarm协议交互</li><li><code>web3-utils</code>包含了一些Dapp开发有用的功能</li></ul><p>Web3与geth通信使用的是 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON-RPC</a> ，这是一种轻量级的RPC（Remote Procedure Call）协议，整个通信的模型可以抽象为下图。</p><p><img src="/images/Communication_Model.jpg" alt="Web3 Communication Model"></p><h2 id="搭建测试链"><a href="#搭建测试链" class="headerlink" title="搭建测试链"></a>搭建测试链</h2><p>在开发初期，我们并没有必要使用真实的公链，为了开发效率，一般选择在本地搭建测试链。在本文我们选择的<a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a>（在此之前使用的是testrpc，Ganache属于它的升级版），一个图形化测试软件（也有命令行版本），可以一键在本地搭建以太坊区块链测试环境，并且将区块链的状态通过图形界面显示出来，Ganache的运行界面如下图所示。</p><p><img src="/images/Ganache.png" alt="Ganache"></p><p>从图中可以看到Ganache会默认创建10个账户，监听地址是<code>http://127.0.0.1:7545</code>，可以实时看到<code>Current Block</code>、<code>Gas Price</code>、<code>Gas Limit</code>等信息。</p><h2 id="创建智能合约"><a href="#创建智能合约" class="headerlink" title="创建智能合约"></a>创建智能合约</h2><p>目前以太坊官方全力支持的智能合约开发环境是<a href="https://remix.ethereum.org" target="_blank" rel="noopener">Remix IDE</a>，我们在合约编辑页面编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract InfoContract &#123;</span><br><span class="line">    </span><br><span class="line">   string fName;</span><br><span class="line">   uint age;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">       fName = _fName;</span><br><span class="line">       age = _age;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">string, uint</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (fName, age);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，就是简单的给<code>name</code>和<code>age</code>变量赋值与读取，接下来切换到 run 的 tab 下，将<code>Environment</code>切换成<code>Web3 Provider</code>，并输入我们的测试链的地址<code>http://127.0.0.1:7545</code>，这里对这三个选项做一简单说明：</p><ul><li><code>Javascript VM</code>：简单的Javascript虚拟机环境，纯粹练习智能合约编写的时候可以选择</li><li><code>Injected Web3</code>：连接到嵌入到页面的Web3，比如连接到MetaMask</li><li><code>Web3 Provider</code>：连接到自定义的节点，如私有的测试网络。</li></ul><p>如果连接成功，那么在下面的<code>Account</code>的选项会默认选择 Ganache 创建的第一个账户地址。接下来我们点击<code>Create</code>就会将我们的智能合约部署到我们的测试网中。接下来 Remix 的页面不要关闭，在后面编写前端代码时还要用到合约的地址以及<code>ABI</code>信息。</p><h2 id="安装Web3"><a href="#安装Web3" class="headerlink" title="安装Web3"></a>安装Web3</h2><p>在这之前，先在终端创建我们的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir info</span><br><span class="line">&gt; <span class="built_in">cd</span> info</span><br></pre></td></tr></table></figure><p>接下来使用 node.js 的包管理工具 npm 初始化项目，创建<code>package.json</code> 文件，其中保存了项目需要的相关依赖环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm init</span><br></pre></td></tr></table></figure><p>一路按回车直到项目创建完成。最后，运行下面命令安装web.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm install web3</span><br></pre></td></tr></table></figure><blockquote><p>   <em>注意：</em> 在实际安装过程中我发现web3在安装完成后并没有 <code>/node_modules/web3/dist/we3.min.js</code> 文件，这个问题在 <a href="https://github.com/ethereum/web3.js/issues/1041" target="_blank" rel="noopener">issue#1041</a>中有体现，但官方好像一直没解决。不过可以在这里<a href="https://codeload.github.com/ethereum/web3.js/zip/develop" target="_blank" rel="noopener">下载</a>所需的文件，解压后将<code>dist</code>文件夹的内容拷贝到 <code>/node_modules/web3</code>路径下。</p></blockquote><h2 id="创建-UI"><a href="#创建-UI" class="headerlink" title="创建 UI"></a>创建 UI</h2><p>在项目目录下创建<code>index.html</code>，在这里我们将创建基础的 UI，功能包括<code>name</code>和<code>age</code>的输入框，以及一个按钮，这些将通过 jQuery 实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"main.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/web3/dist/web3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Info Contract<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"info"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span> <span class="attr">class</span>=<span class="string">"col-lg-2 control-label"</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span> <span class="attr">class</span>=<span class="string">"col-lg-2 control-label"</span>&gt;</span>Age<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>Update Info<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.slim.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">       <span class="comment">// Our future code here..</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来需要编写<code>main.css</code>文件设定基本的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#F0F0F0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Raleway'</span>,<span class="string">'Source Sans Pro'</span>, <span class="string">'Arial'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2em</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#info</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##使用Web3与智能合约交互<br>UI 创建好之后，在<code>&lt;script&gt;</code>标签中间编写<code>web.js</code>的代码与智能合约交互。首先创建<code>web3</code>实例，并与我们的测试环境连接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">"http://localhost:7545"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码是<a href="https://github.com/ethereum/web3.js/" target="_blank" rel="noopener">web3.js Github</a>提供的样例，意思是如果<code>web3</code>已经被定义，那么就可以直接当作我们的 provider 使用。如果没有定义，则我们手动指定 provider。</p><blockquote><p>这里可能会存在疑问：为什么 web3 会被事先定义呢？实际上，如果你使用类似 <a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>（一个 Chrome 上的插件，迷你型以太坊钱包）这样的软件，provider 就会被自动植入。</p></blockquote><p>在上面代码的基础上，接下来设置默认的以太坊账户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>在上文中我们使用 Ganache 已经创建了 10 个账户了，这里我们选择第一个账户当作默认账户。</p><p>接下来需要让我们的<code>web3</code>知道我们的合约是什么样的，这里需要用到合约的 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">ABI（Application Binary Interface）</a>。<code>ABI</code>可以使我们调用合约的函数，并且从合约中获取数据。</p><p>在上文中我们已经在 Remix 中创建了我们的合约，这时重新回到 Remix，在 Compile 的 tab 下我们点击<code>Details</code> 出现的页面中我们可以拷贝合约的<code>ABI</code>，如下图所示。<br><img src="/images/ABI.png" alt=""><br>将其复制到代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> infoContract = web3.eth.contract(PASTE ABI HERE!);</span><br></pre></td></tr></table></figure><p>接下来转到 run 的tab，拷贝合约的地址，将其复制到下面的代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info = InfoContract.at(<span class="string">'PASTE CONTRACT ADDRESS HERE'</span>);</span><br></pre></td></tr></table></figure><p>完成这些我们就可以调用合约中的函数了，下面我们使用 jQuery 与我们的合约进行交互：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">info.getInfo(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)</span><br><span class="line">        &#123;</span><br><span class="line">            $(<span class="string">"#info"</span>).html(result[<span class="number">0</span>]+<span class="string">' ('</span>+result[<span class="number">1</span>]+<span class="string">' years old)'</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(result);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    info.setInfo($(<span class="string">"#name"</span>).val(), $(<span class="string">"#age"</span>).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上的代码就简单地实现了对合约中两个函数的调用，分别读取和显示<code>name</code>和<code>age</code>变量。</p><p>到此我们就完成了全部的代码，完整代码可以在 <a href="https://github.com/xilibi2003/InfoContract" target="_blank" rel="noopener">InfoContract</a> 中找到。在浏览器中打开<code>index.html</code>测试效果如下图（输入名字和年龄后刷新）。</p><p><img src="/images/page.png" alt=""></p><p>本文的作者是盖盖，他的微信公众号: chainlab</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://coursetro.com/posts/code/99/Interacting-with-a-Smart-Contract-through-Web3.js-(Tutorial" target="_blank" rel="noopener">Interacting with a Smart Contract through Web3.js (Tutorial)</a>)</li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web3与智能合约交互实战&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Web3" scheme="https://learnblockchain.cn/tags/Web3/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列10 - 完全理解函数修改器</title>
    <link href="https://learnblockchain.cn/2018/04/09/solidity-modify/"/>
    <id>https://learnblockchain.cn/2018/04/09/solidity-modify/</id>
    <published>2018-04-09T12:35:47.000Z</published>
    <updated>2018-05-17T15:10:40.883Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第10篇，带大家完全理解Solidity的函数修改器。<br>Solidity系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="函数修改器-Function-Modifiers"><a href="#函数修改器-Function-Modifiers" class="headerlink" title="函数修改器(Function Modifiers)"></a>函数修改器(Function Modifiers)</h2><p>函数修改器(Modifiers)可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。</p><blockquote><p>如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。</p></blockquote><p>修改器是一种可被继承合约属性，同时还可被继承的合约重写(override)。下面我们来看一段示例代码： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">owned</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义了一个函数修改器，可被继承</span></span><br><span class="line">    <span class="comment">//  修饰时，函数体被插入到 “_;” 处</span></span><br><span class="line">    <span class="comment">// 不符合条件时，将抛出异常</span></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    <span class="comment">//  使用继承的`onlyOwner` </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    <span class="comment">// 函数修改器可接收参数</span></span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Register</span>(<span class="params">uint initialPrice</span>) <span class="title">public</span> </span>&#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要提供payable 以接受以太</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">costs</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">        registeredAddresses[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changePrice</span>(<span class="params">uint _price</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面onlyOwner就是定义的一个函数修改器，当用这个修改器区修饰一个函数时，则函数必须满足onlyOwner的条件才能运行，这里的条件是：必须是合约的创建这才能调用函数，否则抛出异常。<br>我们在<a href="https://learnblockchain.cn/2018/01/27/create-token2/">实现一个可管理、增发、兑换、冻结等高级功能的代币</a>文章中就使用了这个函数修改器。</p><h3 id="多个修改器"><a href="#多个修改器" class="headerlink" title="多个修改器"></a>多个修改器</h3><p>如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。</p><p>在修改器中或函数内的显式的return语句，仅仅跳出当前的修改器或函数。返回的变量会被赋值，但执行流会在前一个修改器后面定义的”_”后继续执行， 如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        <span class="built_in">require</span>(!locked);</span><br><span class="line">        locked = <span class="literal">true</span>;</span><br><span class="line">        _;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止递归调用</span></span><br><span class="line">    <span class="comment">// return 7 之后，locked = false 依然会执行</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">noReentrancy</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender.call());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改器的参数可以是任意表达式。在此上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。</p><h3 id="深入理解修改器的执行次序"><a href="#深入理解修改器的执行次序" class="headerlink" title="深入理解修改器的执行次序"></a>深入理解修改器的执行次序</h3><p>再来看一个复杂一点的例子，来深入理解修改器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract modifysample &#123;</span><br><span class="line"></span><br><span class="line">    uint a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    modifier mf1 (uint b) &#123;</span><br><span class="line">        uint c = b;</span><br><span class="line">        _;</span><br><span class="line">        c = a;</span><br><span class="line">        a = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     modifier mf2 () &#123;</span><br><span class="line">        uint c = a;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier mf3() &#123;</span><br><span class="line">        a = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        _;</span><br><span class="line">        a = <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) <span class="title">mf1</span>(<span class="params">a</span>) <span class="title">mf2</span> <span class="title">mf3</span> <span class="title">public</span>   </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>)   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的智能合约运行test1()之后，状态变量a的值是多少， 是1， 11， 12，还是13呢？<br>答案是 11, 大家可以运行下test2获取下a值。</p><p>我们来分析一下 test1， 它扩展之后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint c = b;</span><br><span class="line">        uint c = a;</span><br><span class="line">            a = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            _;</span><br><span class="line">            a = <span class="number">13</span>;</span><br><span class="line">c = a;</span><br><span class="line">a = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>这个时候就一目了然了，最后a 为11， 注意第5及第6行是不是执行的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers" target="_blank" rel="noopener">官方文档-Function Modifiers</a></p><p>如果你想和认识我，和我建立联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术爱好者。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第10篇，带大家完全理解Solidity的函数修改器。&lt;br&gt;Solidity系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列9 - 错误处理</title>
    <link href="https://learnblockchain.cn/2018/04/07/solidity-errorhandler/"/>
    <id>https://learnblockchain.cn/2018/04/07/solidity-errorhandler/</id>
    <published>2018-04-07T12:35:47.000Z</published>
    <updated>2018-04-07T14:37:06.216Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第9篇介绍Solidity 错误处理。<br>Solidity系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="什么是错误处理"><a href="#什么是错误处理" class="headerlink" title="什么是错误处理"></a>什么是错误处理</h2><p>错误处理是指在程序发生错误时的处理方式，Solidity处理错误和我们常见的语言不一样，Solidity是通过回退状态的方式来处理错误。发生异常时会撤消当前调用（及其所有子调用）所改变的状态，同时给调用者返回一个错误标识。注意<strong>捕捉异常是不可能的</strong>，因此没有try … catch…。</p><p>为什么Solidity处理错误要这样设计呢？<br>我们可以把区块链理解为是全球共享的分布式事务性数据库。<strong>全球共享</strong>意味着参与这个网络的每一个人都可以读写其中的记录。如果想修改这个数据库中的内容，就必须创建一个事务，<strong>事务</strong>意味着要做的修改（假如我们想同时修改两个值）只能被完全的应用或者一点都没有进行。<br>学习过数据库的同学，应该理解事务的含义，如果你对事务一词不是很理解，建议你搜索一下“数据库事务“。<br>Solidity错误处理就是要保证每次调用都是事务性的。</p><h2 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h2><p>Solidity提供了两个函数assert和require来进行条件检查，如果条件不满足则抛出异常。assert函数通常用来检查（测试）内部错误，而require函数来检查输入变量或合同状态变量是否满足条件以及验证调用外部合约返回值。<br>另外，如果我们正确使用assert，有一个Solidity分析工具就可以帮我们分析出智能合约中的错误，帮助我们发现合约中有逻辑错误的bug。</p><p>除了可以两个函数assert和require来进行条件检查，另外还有两种方式来触发异常：</p><ol><li><strong>revert</strong>函数可以用来标记错误并回退当前调用</li><li>使用<strong>throw</strong>关键字抛出异常（从0.4.13版本，throw关键字已被弃用，将来会被淘汰。）</li></ol><p>当子调用中发生异常时，异常会自动向上“冒泡”。 不过也有一些例外：send，和底层的函数调用call, delegatecall，callcode，当发生异常时，这些函数返回false。</p><p>注意：在一个不存在的地址上调用底层的函数call，delegatecall，callcode 也会返回成功，所以我们在进行调用时，应该总是优先进行函数存在性检查。</p><p>在下面通过一个示例来说明如何使用require来检查输入条件，以及assert用于内部错误检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendHalf</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 仅允许偶数</span></span><br><span class="line">        uint balanceBeforeTransfer = <span class="keyword">this</span>.balance;</span><br><span class="line">        addr.transfer(msg.value / <span class="number">2</span>);  <span class="comment">// 如果失败，会抛出异常，下面的代码就不是执行</span></span><br><span class="line">        assert(<span class="keyword">this</span>.balance == balanceBeforeTransfer - msg.value / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际运行下，看看异常是如何发生的：</p><ol><li><p>首先打开<a href="https://remix.ethereum.org" target="_blank" rel="noopener">Remix</a>，贴入代码，点击创建合约。如下图：<br><img src="/images/solidity_error1.jpg" alt=""></p></li><li><p>运行测试1：附加1wei (奇数)去调用sendHalf，这时会发生异常，如下图:</p></li></ol><p><img src="/images/solidity_error2.jpg" alt=""></p><ol><li>运行测试2：附加2wei 去调用sendHalf，运行正常。</li><li>运行测试3：附加2wei以及sendHalf参数为当前合约本身，在转账是发生异常，因为合约无法接收转账，错误提示上图类似。</li></ol><h2 id="assert类型异常"><a href="#assert类型异常" class="headerlink" title="assert类型异常"></a>assert类型异常</h2><p>在下述场景中自动产生assert类型的异常:</p><ol><li>如果越界，或负的序号值访问数组，如i &gt;= x.length 或 i &lt; 0时访问x[i]</li><li>如果序号越界，或负的序号值时访问一个定长的bytesN。</li><li>被除数为0， 如5/0 或 23 % 0。</li><li>对一个二进制移动一个负的值。如:5&lt;&lt;i; i为-1时。</li><li>整数进行可以显式转换为枚举时，如果将过大值，负值转为枚举类型则抛出异常</li><li>如果调用未初始化内部<a href="https://learnblockchain.cn/2017/12/12/solidity_func/">函数类型</a>的变量。</li><li>如果调用<strong>assert</strong>的参数为false</li></ol><h2 id="require类型异常"><a href="#require类型异常" class="headerlink" title="require类型异常"></a>require类型异常</h2><p>在下述场景中自动产生require类型的异常:</p><ol><li>调用<strong>throw</strong></li><li>如果调用<strong>require</strong>的参数为false</li><li>如果你通过消息调用一个函数，但在调用的过程中，并没有正确结束(gas不足，没有匹配到对应的函数，或被调用的函数出现异常)。底层操作如call,send,delegatecall或callcode除外，它们不会抛出异常，但它们会通过返回false来表示失败。</li><li>如果在使用new创建一个新合约时出现第3条的原因没有正常完成。</li><li>如果调用外部函数调用时，被调用的对象不包含代码。</li><li>如果合约没有payable修饰符的public的函数在接收以太币时（包括构造函数，和回退函数）。</li><li>如果合约通过一个public的getter函数（public getter funciton）接收以太币。</li><li>如果<strong>.transfer()</strong>执行失败</li></ol><p>当发生require类型的异常时，Solidity会执行一个回退操作（指令0xfd）。<br>当发生assert类型的异常时，Solidity会执行一个无效操作（指令0xfe）。<br>在上述的两种情况下，EVM都会撤回所有的状态改变。是因为期望的结果没有发生，就没法继续安全执行。必须保证交易的原子性（一致性，要么全部执行，要么一点改变都没有，不能只改变一部分），所以需要撤销所有操作，让整个交易没有任何影响。</p><p>注意assert类型的异常会消耗掉所有的gas, 而require从大都会版本（Metropolis， 即目前主网所在的版本）起不会消耗gas。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#error-handling-assert-require-revert-and-exceptions" target="_blank" rel="noopener">Solidity 错误处理</a></li></ul><p>欢迎来我的知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener"><strong>深入浅出区块链</strong></a>讨论区块链技术，同时我也会为大家提供区块链技术解答，作为星友福利，星友可加入区块链技术付费交流群。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第9篇介绍Solidity 错误处理。&lt;br&gt;Solidity系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>剖析非同质化代币ERC721-全面解析ERC721标准</title>
    <link href="https://learnblockchain.cn/2018/03/23/token-erc721/"/>
    <id>https://learnblockchain.cn/2018/03/23/token-erc721/</id>
    <published>2018-03-23T13:54:50.000Z</published>
    <updated>2018-03-26T01:58:47.075Z</updated>
    
    <content type="html"><![CDATA[<p>什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721.</p><a id="more"></a><h2 id="ERC721是什么"><a href="#ERC721是什么" class="headerlink" title="ERC721是什么"></a>ERC721是什么</h2><p>在<a href="https://learnblockchain.cn/2018/01/12/create_token/">创建代币</a>一篇，我们讲到过ERC20代币，<br>和ERC20一样，ERC721同样是一个代币标准，ERC721官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 </p><blockquote><p>ERC721 是由Dieter Shirley 在2017年9月提出。Dieter Shirley 正是谜恋猫CryptoKitties背后的公司Axiom Zen的技术总监。因此谜恋猫也是第一个实现了ERC721 标准的去中心化应用。ERC721号提议已经被以太坊作为标准接受，但该标准仍处于草稿阶段。本文介绍的ERC721标准基于最新(2018/03/23官方提议。</p></blockquote><p>那怎么理解<strong>非同质</strong>代币呢?</p><p>非同质代表独一无二，谜恋猫为例，每只猫都被赋予拥有基因，是独一无二的（一只猫就是一个NFTs），猫之间是不能置换的。这种独特性使得某些稀有猫具有收藏价值，也因此受到追捧。</p><p>ERC20代币是可置换的，且可细分为N份（1 = 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。</p><blockquote><p>如果同一个集合的两个物品具有不同的特征，这两个物品是非同质的，而同质是某个部分或数量可以被另一个同等部分或数量所代替。</p></blockquote><p>非同质性其实广泛存在于我们的生活中，如图书馆的每一本，宠物商店的每一只宠物，歌手所演唱的歌曲，花店里不同的花等等，因此ERC721合约必定有广泛的应用场景。通过这样一个标准，也可建立跨功能的NFTs管理和销售平台（就像有支持ERC20的交易所和钱包一样），使生态更加强大。</p><h2 id="ERC721标准"><a href="#ERC721标准" class="headerlink" title="ERC721标准"></a>ERC721标准</h2><p>ERC721最为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line">interface ERC721 <span class="comment">/* is ERC165 */</span> &#123;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">ownerOf</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">safeTransferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId, bytes data</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">safeTransferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address _approved, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">setApprovalForAll</span>(<span class="params">address _operator, bool _approved</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">getApproved</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">isApprovedForAll</span>(<span class="params">address _owner, address _operator</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>接口说明：</strong></p><ul><li>balanceOf(): 返回由_owner 持有的NFTs的数量。</li><li>ownerOf(): 返回tokenId代币持有者的地址。</li><li>approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。</li><li>setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。</li><li><p>getApproved()、isApprovedForAll(): 用来查询授权。</p></li><li><p>safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查：</p></li></ul><ol><li>调用者msg.sender应该是当前tokenId的所有者或被授权的地址</li><li>_from 必须是 _tokenId的所有者</li><li>_tokenId 应该是当前合约正在监测的NFTs 中的任何一个</li><li>_to 地址不应该为 0</li><li>如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为<code>bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))</code>抛出异常。<br>一个可接收NFT的合约必须实现ERC721TokenReceiver接口：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721TokenReceiver &#123;</span><br><span class="line">    <span class="comment">/// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onERC721Received</span>(<span class="params">address _from, uint256 _tokenId, bytes data</span>) <span class="title">external</span> <span class="title">returns</span>(<span class="params">bytes4</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。</li></ul><h2 id="ERC165-标准"><a href="#ERC165-标准" class="headerlink" title="ERC165 标准"></a>ERC165 标准</h2><p>ERC721标准同时要求必须符合ERC165标准 ，其接口如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ERC165 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceID</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">ERC165</a>同样是一个合约标准，这个标准要求合约提供其实现了哪些接口，这样再与合约进行交互的时候可以先调用此接口进行查询。<br>interfaceID为函数选择器，计算方式有两种，如：<code>bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));</code>或<code>ERC165.supportsInterface.selector</code>，多个函数的接口ID为函数选择器的异或值。<br>关于ERC165，这里不深入介绍，有兴趣的同学可以阅读<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">官方提案</a>。</p><h2 id="可选实现接口：ERC721Metadata"><a href="#可选实现接口：ERC721Metadata" class="headerlink" title="可选实现接口：ERC721Metadata"></a>可选实现接口：ERC721Metadata</h2><p>ERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT所对应的资源）。<br>其接口定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721Metadata <span class="comment">/* is ERC721 */</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">string _name</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">symbol</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">string _symbol</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenURI</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>接口说明：</strong></p><ul><li>name(): 返回合约名字，尽管是可选，但强烈建议实现，即便是返回空字符串。</li><li>symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。</li><li>tokenURI(): 返回_tokenId所对应的外部资源文件的URI（通常是IPFS或HTTP(S)路径）。外部资源文件需要包含名字、描述、图片，其格式的要求如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Asset Metadata"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"Identifies the asset to which this NFT represents"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"description"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"Describes the asset to which this NFT represents"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"image"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>tokenURI通常是被web3调用，以便在应用层做相应的查询和展示。</p><h2 id="可选实现接口：ERC721Enumerable"><a href="#可选实现接口：ERC721Enumerable" class="headerlink" title="可选实现接口：ERC721Enumerable"></a>可选实现接口：ERC721Enumerable</h2><p>ERC721Enumerable的主要目的是提高合约中NTF的可访问性，其接口定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721Enumerable <span class="comment">/* is ERC721 */</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenByIndex</span>(<span class="params">uint256 _index</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenOfOwnerByIndex</span>(<span class="params">address _owner, uint256 _index</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>接口说明：</strong></p><ul><li>totalSupply(): 返回NFT总量</li><li>tokenByIndex(): 通过索引返回对应的tokenId。</li><li>tokenOfOwnerByIndex(): 所有者可以一次拥有多个的NFT, 此函数返回_owner拥有的NFT列表中对应索引的tokenId。</li></ul><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="NTF-IDs"><a href="#NTF-IDs" class="headerlink" title="NTF IDs"></a>NTF IDs</h3><p>NTF ID，即tokenId，在合约中用唯一的uint265进行标识，每个NFT的ID在智能合约的生命周期内不允许改变。推荐的实现方式有：</p><ol><li>从0开始，每新加一个NFT，NTF ID加1</li><li>使用sha3后uuid 转换为 NTF ID</li></ol><h3 id="与ERC-20的兼容性"><a href="#与ERC-20的兼容性" class="headerlink" title="与ERC-20的兼容性"></a>与ERC-20的兼容性</h3><p>ERC721标准尽可能遵循 ERC-20 的语义，但由于同质代币与非同质代币之间的根本差异，并不能完全兼容ERC-20。</p><h3 id="交易、挖矿、销毁"><a href="#交易、挖矿、销毁" class="headerlink" title="交易、挖矿、销毁"></a>交易、挖矿、销毁</h3><p>在实现transter相关接口时除了满足上面的的条件外，我们可以根据需要添加自己的逻辑，如加入黑名单等。<br>同时挖矿、销毁尽管不是标准的一部分，我们可以根据需要实现。</p><h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><p>参考实现为订阅用户专有福利，请订阅我的小专栏：<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。<br><!-- 1. [CryptoKitties Deployed Contract.](https://ethfiddle.com/09YbyJRfiI) 2. [XXXXERC721](https://github.com/fulldecent/erc721-example)3. [ERC721ExampleDeed](https://github.com/nastassiasachs/ERC721ExampleDeed) --></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">EIPS-165</a></li><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md" target="_blank" rel="noopener">EIPS-721</a></li></ol><p>欢迎来我的知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener"><strong>深入浅出区块链</strong></a>讨论区块链，作为星友福利，星友可加入区块链技术付费交流群。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721.&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
      <category term="ERC721" scheme="https://learnblockchain.cn/tags/ERC721/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建以太坊私有链</title>
    <link href="https://learnblockchain.cn/2018/03/18/create_private_blockchain/"/>
    <id>https://learnblockchain.cn/2018/03/18/create_private_blockchain/</id>
    <published>2018-03-18T12:05:59.000Z</published>
    <updated>2018-03-19T02:13:22.400Z</updated>
    
    <content type="html"><![CDATA[<p>在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊语言有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="go-ethereum客户端安装"><a href="#go-ethereum客户端安装" class="headerlink" title="go-ethereum客户端安装"></a>go-ethereum客户端安装</h2><p>Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择geth工具来进行开发。由于本人是mac，所以优先使用mac进行开发啦。mac中geth安装如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap ethereum/ethereum</span><br><span class="line">brew install ethereum</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --help</span><br></pre></td></tr></table></figure><p>如果输出一些帮助提示命令，则说明安装成功。<br>其他平台可参考<a href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum" target="_blank" rel="noopener">Geth 安装</a></p><h2 id="搭建私有链"><a href="#搭建私有链" class="headerlink" title="搭建私有链"></a>搭建私有链</h2><p>以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。首先将下面的内容保存到一个json文件中，例如genesis.json。<br>json文件内容如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">        <span class="attr">"chainId"</span>: <span class="number">10</span>, </span><br><span class="line">        <span class="attr">"homesteadBlock"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"eip155Block"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"eip158Block"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="attr">"alloc"</span>      : &#123;&#125;,</span><br><span class="line">  <span class="attr">"coinbase"</span>   : <span class="string">"0x0000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"difficulty"</span> : <span class="string">"0x20000"</span>,</span><br><span class="line">  <span class="attr">"extraData"</span>  : <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"gasLimit"</span>   : <span class="string">"0x2fefd8"</span>,</span><br><span class="line">  <span class="attr">"nonce"</span>      : <span class="string">"0x0000000000000042"</span>,</span><br><span class="line">  <span class="attr">"mixhash"</span>    : <span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"parentHash"</span> : <span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"timestamp"</span>  : <span class="string">"0x00"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化：写入创世区块"><a href="#初始化：写入创世区块" class="headerlink" title="初始化：写入创世区块"></a>初始化：写入创世区块</h2><p>准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示：</p><p><img src="/images/create_private_blockchain_1.png" alt=""></p><p>接下来进入privatechain目录中，执行初始化命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd privatechain</span><br><span class="line">geth --datadir data0 init genesis.json</span><br></pre></td></tr></table></figure><p>上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。</p><p>运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有<code>Successfully wrote genesis state</code>字样，说明初始化成功。</p><p>初始化成功后的目录如下：<br><img src="/images/create_private_blockchain_2.png" alt=""><br>其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。</p><h2 id="启动私有链节点"><a href="#启动私有链节点" class="headerlink" title="启动私有链节点"></a>启动私有链节点</h2><p>初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir data0 --networkid 1108 console</span><br></pre></td></tr></table></figure><p>上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id(上面命令可能会运行失败，我直接重启mac，再进入到privateChain目录中，简单粗暴)。</p><p>运行上面的命令后，就启动了区块链节点并进入了Javascript Console：<br><img src="/images/create_private_blockchain_3.png" alt=""><br>这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括：</p><p><strong>eth：</strong>包含一些跟操作区块链相关的方法<br><strong>net：</strong>包含以下查看p2p网络状态的方法<br><strong>admin：</strong>包含一些与管理节点相关的方法<br><strong>miner：</strong>包含启动&amp;停止挖矿的一些方法<br><strong>personal：</strong>主要包含一些管理账户的方法<br><strong>txpool：</strong>包含一些查看交易内存池的方法<br><strong>web3：</strong>包含了以上对象，还包含一些单位换算的方法</p><h2 id="玩转Javascript-Console"><a href="#玩转Javascript-Console" class="headerlink" title="玩转Javascript Console"></a>玩转Javascript Console</h2><p>进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。</p><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>此时没有账户，接下来使用personal对象来创建一个账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">&gt; Passphrase:</span><br><span class="line">&gt; Repeat passphrase:</span><br><span class="line">&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><br></pre></td></tr></table></figure><p>Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">&gt; Passphrase:</span><br><span class="line">&gt; Repeat passphrase:</span><br><span class="line">&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;</span><br></pre></td></tr></table></figure><p>这时候再去看账户，就有两个了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;]</span><br></pre></td></tr></table></figure><p>账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。</p><p><img src="/images/create_private_blockchain_4.png" alt=""><br>json文件中信息格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;address&quot;: &quot;4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  &quot;crypto&quot;: &#123;</span><br><span class="line">    &quot;cipher&quot;: &quot;aes-128-ctr&quot;,</span><br><span class="line">    &quot;ciphertext&quot;: &quot;238d6d48126b762c8f13e84622b1bbb7713f7244c2f24555c99b76396fae8355&quot;,</span><br><span class="line">    &quot;cipherparams&quot;: &#123;</span><br><span class="line">      &quot;iv&quot;: &quot;d0f5a3d3e6c1eeec77bf631bc938725d&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;kdf&quot;: &quot;scrypt&quot;,</span><br><span class="line">    &quot;kdfparams&quot;: &#123;</span><br><span class="line">      &quot;dklen&quot;: 32,</span><br><span class="line">      &quot;n&quot;: 262144,</span><br><span class="line">      &quot;p&quot;: 1,</span><br><span class="line">      &quot;r&quot;: 8,</span><br><span class="line">      &quot;salt&quot;: &quot;70dc72c4eb63bea50f7637d9ff85bb53f6ca8ace17f4245feae9c0bc9abaad82&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mac&quot;: &quot;bd7fc0c937c39f1cbbf1ca654c33b53d7f9c644c6dacfeefe1641d2f3decea04&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;id&quot;: &quot;57803d82-0cd4-4a78-9c29-9f9252fdcf60&quot;,</span><br><span class="line">  &quot;version&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看账户余额"><a href="#查看账户余额" class="headerlink" title="查看账户余额"></a>查看账户余额</h3><p>eth对象提供了查看账户余额的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">0</span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。</p><h3 id="启动-amp-停止挖矿"><a href="#启动-amp-停止挖矿" class="headerlink" title="启动&amp;停止挖矿"></a>启动&amp;停止挖矿</h3><p>通过miner.start()来启动挖矿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(10)</span><br></pre></td></tr></table></figure><p>其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</p><p>如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miner.stop()：</span><br></pre></td></tr></table></figure><p>注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。</p><p>挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.coinbase</span><br><span class="line">&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><br></pre></td></tr></table></figure><p>现在的coinbase是账户0，要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.setEtherbase(eth.accounts[1])</span><br><span class="line">true</span><br><span class="line">&gt; eth.coinbase</span><br><span class="line">&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;</span><br></pre></td></tr></table></figure><p>挖到区块以后，账户0里面应该就有余额了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">2.31e+21</span><br></pre></td></tr></table></figure><p>getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&apos;ether&apos;)</span><br><span class="line">2310</span><br></pre></td></tr></table></figure><h3 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h3><p>截止目前，账户一的余额还是0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>可以通过发送一笔交易，从账户0转移10个以太币到账户1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(10,&apos;ether&apos;)</span><br><span class="line">&quot;10000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">Error: authentication needed: password or unlock</span><br><span class="line">    at web3.js:3143:20</span><br><span class="line">    at web3.js:6347:15</span><br><span class="line">    at web3.js:5081:36</span><br><span class="line">    at &lt;anonymous&gt;:1:1</span><br></pre></td></tr></table></figure><p>这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[0])</span><br><span class="line">Unlock account 0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f</span><br><span class="line">Passphrase: </span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(10,&apos;ether&apos;)</span><br><span class="line">&quot;10000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">INFO [03-07|11:13:11] Submitted transaction                    fullhash=0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6 recipient=0x46B24d04105551498587e3C6CE2c3341d5988938</span><br><span class="line">&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;</span><br></pre></td></tr></table></figure><p>我们去查看账户1中的余额：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; txpool.status</span><br><span class="line">&#123;</span><br><span class="line">  pending: 1,</span><br><span class="line">  queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一条pending的交易，pending表示已提交但还未被处理的交易。</p><p>要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(1);admin.sleepBlocks(1);miner.stop();</span><br></pre></td></tr></table></figure><p>当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&apos;ether&apos;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="查看交易和区块"><a href="#查看交易和区块" class="headerlink" title="查看交易和区块"></a>查看交易和区块</h3><p>eth对象封装了查看交易和区块信息的方法。</p><p>查看当前区块总数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.blockNumber</span><br><span class="line">463</span><br></pre></td></tr></table></figure><p>通过区块号查看区块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBlock(66)</span><br><span class="line">&#123;</span><br><span class="line">  difficulty: 135266,</span><br><span class="line">  extraData: &quot;0xd783010802846765746886676f312e31308664617277696e&quot;,</span><br><span class="line">  gasLimit: 3350537,</span><br><span class="line">  gasUsed: 0,</span><br><span class="line">  hash: &quot;0x265dfcc0649bf6240812256b2b9b4e3ae48d51fd8e43e25329ac111556eacdc8&quot;,</span><br><span class="line">  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  miner: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  mixHash: &quot;0xaf755722f62cac9b483d3437dbc795f2d3a02e28ec03d39d8ecbb6012906263c&quot;,</span><br><span class="line">  nonce: &quot;0x3cd80f6ec5c2f3e9&quot;,</span><br><span class="line">  number: 66,</span><br><span class="line">  parentHash: &quot;0x099776a52223b892d13266bb3aec3cc04c455dc797185f0b3300d39f9fc0a8ec&quot;,</span><br><span class="line">  receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</span><br><span class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</span><br><span class="line">  size: 535,</span><br><span class="line">  stateRoot: &quot;0x0c9feec5a201c8c98618331aecbfd2d4d93da1c6064abd0c41ae649fc08d8d06&quot;,</span><br><span class="line">  timestamp: 1520391527,</span><br><span class="line">  totalDifficulty: 8919666,</span><br><span class="line">  transactions: [],</span><br><span class="line">  transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</span><br><span class="line">  uncles: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过交易hash查看交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getTransaction(&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  blockHash: &quot;0x1cb368a27cc23c786ff5cdf7cd4351d48f4c8e8aea2e084a5e9d7c480449c79a&quot;,</span><br><span class="line">  blockNumber: 463,</span><br><span class="line">  from: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  gas: 90000,</span><br><span class="line">  gasPrice: 18000000000,</span><br><span class="line">  hash: &quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;,</span><br><span class="line">  input: &quot;0x&quot;,</span><br><span class="line">  nonce: 0,</span><br><span class="line">  r: &quot;0x31d22686e0d408a16497becf6d47fbfdffe6692d91727e5b7ed3d73ede9e66ea&quot;,</span><br><span class="line">  s: &quot;0x7ff7c14a20991e2dfdb813c2237b08a5611c8c8cb3c2dcb03a55ed282ce4d9c3&quot;,</span><br><span class="line">  to: &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;,</span><br><span class="line">  transactionIndex: 0,</span><br><span class="line">  v: &quot;0x38&quot;,</span><br><span class="line">  value: 10000000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="私有链" scheme="https://learnblockchain.cn/categories/ethereum/%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="私有链" scheme="https://learnblockchain.cn/tags/%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何编写一个可升级的智能合约</title>
    <link href="https://learnblockchain.cn/2018/03/15/contract-upgrade/"/>
    <id>https://learnblockchain.cn/2018/03/15/contract-upgrade/</id>
    <published>2018-03-15T08:14:01.000Z</published>
    <updated>2018-03-19T02:07:02.498Z</updated>
    
    <content type="html"><![CDATA[<p>区块链信任基础的数据不可修改的特性，让它传统应用程序有一个很大的不同的地方是一经发布于区块链上就无法修改（不能直接在原有的合约上直接修改再重新发布）。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约及<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">Solidity语言</a>有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="当智能合约出现bug"><a href="#当智能合约出现bug" class="headerlink" title="当智能合约出现bug"></a>当智能合约出现bug</h2><p>一方面正式由于智能合约的不可修改的特性，因为只要规则确定之后，没人能够修改它，大家才能够信任它。但另一方面，如果规则的实现有Bug, 可能会造成代币被盗，或是调用消耗大量的gas。这时就需要我们去修复错误。</p><p>我们知道一个智能合约包含两部分： 代码逻辑和数据，而代码逻辑又是最容易出问题的部分, 如在实现如下合约时，由于手抖在写addTen()时，10写成了11。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balanceOf[addr] + <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们在部署之后发现了这个问题，想要修复这个bug的话，只好重新部署合约，可是这时会有一个尴尬的问题，原来的合约已经有很多人使用，如果部署新的合约，老合约的数据将会丢失。</p><h2 id="数据合约及控制合约"><a href="#数据合约及控制合约" class="headerlink" title="数据合约及控制合约"></a>数据合约及控制合约</h2><p>那么如何解决上面的问题了，一个解决方案是分离合约中的数据，使用一个单独的合约来存储数据（下文称数据合约），使用一个单独的合约写业务逻辑（下文称控制合约）。<br>我们来看看代码如何实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract DataContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ControlContract &#123;</span><br><span class="line"></span><br><span class="line">    DataContract dataContract;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ControlContract</span>(<span class="params">address _dataContractAddr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        dataContract = DataContract(_dataContractAddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataContract.balanceOf(addr) + <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有两个合约DataContract 专门用来存数据，ControlContract用来处理逻辑，并利用DataContract来读写数据。通过这样的设计，可以在更新控制合约后保持数据合约不变，这样就不会丢失数据，也不用迁移数据。</p><h2 id="读写控制"><a href="#读写控制" class="headerlink" title="读写控制"></a>读写控制</h2><p>通过DataContract我们可以单独更新合约逻辑，不过你也许发现了一个新的问题，DataContract的数据不仅仅可以被ControlContract读写，还可以被其他的合约读写，因此需要对DataContract添加读写控制。我们给DataContract添加一个mapping, 用来控制哪些地址可以访问数据，同时添加了修饰器及设置访问的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract DataContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) accessAllowed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DataContract</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier platform() &#123;</span><br><span class="line">        <span class="built_in">require</span>(accessAllowed[msg.sender] == <span class="literal">true</span>);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowAccess</span>(<span class="params">address _addr</span>) <span class="title">platform</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[_addr] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">denyAccess</span>(<span class="params">address _addr</span>) <span class="title">platform</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[_addr] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>订阅我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>可参看合约的完整代码。</p><p>部署方法如下：</p><ol><li>先部署DataContract合约</li><li>使用DataContract合约地址作为部署ControlContract合约的参数</li><li>用ControlContract合约地址作为参数调用DataContract合约的allowAccess方法。<br>如果需要更新控制合约(如修复了addTen)则重新执行第2-3步，同时对老的控制合约执行denyAccess()。</li></ol><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>当我们在实现数据合约时，它包含的逻辑应该越少越好，并且应该是严格测试过的，因为一旦数据合约部署之后，就没法更改。<br>大多数情况下，和用户交互的是DApp， 因此当控制合约升级之后，需要升级DApp，使之关联新的控制合约。</p><p>尽管合约可以通过本文的方式升级，但我们依然要谨慎升级，因为升级表示你可以重写逻辑，会降低用户对你的信任度。<br>本文介绍升级方法更多的是一种思路，实际项目中可能会对应多个控制合约及数据合约。</p><p>欢迎来我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>讨论区块链技术。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链信任基础的数据不可修改的特性，让它传统应用程序有一个很大的不同的地方是一经发布于区块链上就无法修改（不能直接在原有的合约上直接修改再重新发布）。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列8 - Solidity API</title>
    <link href="https://learnblockchain.cn/2018/03/14/solidity-api/"/>
    <id>https://learnblockchain.cn/2018/03/14/solidity-api/</id>
    <published>2018-03-14T15:04:43.000Z</published>
    <updated>2018-03-18T13:55:32.192Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。</p><p>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><p>Solidity API 主要表现为Solidity 内置的特殊的变量及函数，他们存在于全局命名空间里，主要分为以下几类：</p><ol><li>有关区块和交易的属性</li><li>有关错误处理</li><li>有关数学及加密功能</li><li>地址相关</li><li>合约相关</li></ol><p>下面详细讲解下</p><h2 id="区块和交易的属性（Block-And-Transaction-Properties）"><a href="#区块和交易的属性（Block-And-Transaction-Properties）" class="headerlink" title="区块和交易的属性（Block And Transaction Properties）"></a>区块和交易的属性（Block And Transaction Properties）</h2><p>用来提供一些区块链当前的信息。</p><ul><li>block.blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。</li><li>block.coinbase (address): 当前块矿工的地址。</li><li>block.difficulty (uint):当前块的难度。</li><li>block.gaslimit (uint):当前块的gaslimit。</li><li>block.number (uint):当前区块的块号。</li><li>block.timestamp (uint): 当前块的Unix时间戳（从1970/1/1 00:00:00 UTC开始所经过的秒数）</li><li>msg.data (bytes): 完整的调用数据（calldata）。</li><li>msg.gas (uint): 当前还剩的gas。</li><li>msg.sender (address): 当前调用发起人的地址。</li><li>msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。</li><li>msg.value (uint): 这个消息所附带的以太币，单位为wei。</li><li>now (uint): 当前块的时间戳(block.timestamp的别名)</li><li>tx.gasprice (uint) : 交易的gas价格。</li><li>tx.origin (address): 交易的发送者（全调用链）</li></ul><p>注意：<br>msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。</p><p>不应该依据 block.timestamp, now 和 block.blockhash来产生一个随机数（除非你确实需要这样做），这几个值在一定程度上被矿工影响（比如在赌博合约里，不诚实的矿工可能会重试去选择一个对自己有利的hash）。</p><p>对于同一个链上连续的区块来说，当前区块的时间戳（timestamp）总是会大于上一个区块的时间戳。</p><p>为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0.</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>assert(bool condition)<br>用于判断内部错误，条件不满足时抛出异常</li><li>require(bool condition):<br>用于判断输入或外部组件错误，条件不满足时抛出异常</li><li>revert():<br>终止执行并还原改变的状态</li></ul><h2 id="数学及加密功能"><a href="#数学及加密功能" class="headerlink" title="数学及加密功能"></a>数学及加密功能</h2><ul><li>addmod(uint x, uint y, uint k) returns (uint):<br>计算(x + y) % k，加法支持任意的精度且不会在2**256处溢出，从0.5.0版本开始断言k != 0。</li><li>mulmod(uint x, uint y, uint k) returns (uint):<br>计算 (x <em> y) % k， 乘法支持任意的精度且不会在2*</em>256处溢出， 从0.5.0版本开始断言k != 0。</li><li>keccak256(…) returns (bytes32):<br>使用以太坊的（Keccak-256）计算HASH值。紧密打包参数。</li><li>sha256(…) returns (bytes32):<br>使用SHA-256计算hash值，紧密打包参数。</li><li>sha3(…) returns (bytes32):<br>keccak256的别名</li><li>ripemd160(…) returns (bytes20):<br>使用RIPEMD-160计算HASH值。紧密打包参数。</li><li>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):<br>通过椭圆曲线签名来恢复与公钥关联的地址，或者在错误时返回零。可用于签名数据的校验，如果返回结果是签名者的公匙地址，那么说明数据是正确的。<blockquote><p>ecrecover函数需要四个参数，需要被签名数据的哈希结果值，r，s，v分别来自签名结果串。<br>r = signature[0:64]<br>s = signature[64:128]<br>v = signature[128:130]<br>其中v取出来的值或者是00或01。要使用时，我们先要将其转为整型，再加上27，所以我们将得到27或28。在调用函数时v将填入27或28。</p></blockquote></li></ul><p>用javascript表达如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'0x8CbaC5e4d803bE2A3A5cd3DbE7174504c6DD0c1C'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hash = web3.sha3(msg)</span><br><span class="line"><span class="keyword">var</span> sig = web3.eth.sign(address, h).slice(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> r = <span class="string">`0x<span class="subst">$&#123;sig.slice(<span class="number">0</span>, <span class="number">64</span>)&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">`0x<span class="subst">$&#123;sig.slice(<span class="number">64</span>, <span class="number">128</span>)&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> v = web3.toDecimal(sig.slice(<span class="number">128</span>, <span class="number">130</span>)) + <span class="number">27</span></span><br></pre></td></tr></table></figure></p><p>订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>可以参考到完整的使用例子。<br><!-- [例子](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio)： --></p><p>紧密打包参数（tightly packed）意思是说参数不会补位，是直接连接在一起的，下面几个是相等的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class="line">keccak256(&quot;abc&quot;)</span><br><span class="line"></span><br><span class="line">keccak256(0x616263)  // hex</span><br><span class="line">keccak256(6382179)</span><br><span class="line">keccak256(97, 98, 99)   //ascii</span><br></pre></td></tr></table></figure><p>如果需要填充，可以使用显式类型转换：keccak256(“\x00\x12”) 与keccak256(uint16(0x12))相同。</p><p>注意，常量将使用存储它们所需的最少字节数来打包，例如keccak256(0) == keccak256(uint8(0))和keccak256(0x12345678) == keccak256(uint32(0x12345678))</p><p>在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为私链实现了一种预编译合约，合约要在收到第一个消息后才会真正存在（虽然他们的合约代码是硬编码的）。而向一个不存在的合约发送消息，所以才会导致Out-Of-Gas的问题。一种解决办法（workaround）是每个在你真正使用它们之前先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。</p><h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><ul><li><p><address>.balance (uint256):<br>Address的余额，以wei为单位。</address></p></li><li><p><address>.transfer(uint256 amount):<br>发送给定数量的ether到某个地址，以wei为单位。失败时抛出异常。</address></p></li><li><p><address>.send(uint256 amount) returns (bool):<br>发送给定数量的ether到某个地址，以wei为单位, 失败时返回false。</address></p></li><li><p><address>.call(…) returns (bool):<br>发起底层的call调用。失败时返回false。</address></p></li><li><p><address>.callcode(…) returns (bool):<br>发起底层的callcode调用，失败时返回false。<br>不鼓励使用，未来可能会移除。</address></p></li><li><p><address>.delegatecall(…) returns (bool):<br>发起底层的delegatecall调用，失败时返回false</address></p></li></ul><p>更多信息参考<a href="https://xiaozhuanlan.com/topic/7921803456" target="_blank" rel="noopener">地址篇</a>。</p><p><strong>警告</strong>：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p><h2 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h2><ul><li>this（当前合约的类型）:<br>表示当前合约，可以显式的转换为Address</li><li>selfdestruct(address recipient):<br>销毁当前合约，并把它所有资金发送到给定的地址。</li><li>suicide(address recipient):<br>selfdestruct的别名</li></ul><p>另外，当前合约里的所有函数均可支持调用，包括当前函数本身。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables" target="_blank" rel="noopener">Special Variables and Functions</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。&lt;/p&gt;
&lt;p&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何通过以太坊智能合约来进行众筹（ICO）</title>
    <link href="https://learnblockchain.cn/2018/02/28/ico-crowdsale/"/>
    <id>https://learnblockchain.cn/2018/02/28/ico-crowdsale/</id>
    <published>2018-02-28T12:30:42.000Z</published>
    <updated>2018-05-03T02:26:43.863Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="众筹"><a href="#众筹" class="headerlink" title="众筹"></a>众筹</h2><p>先简单说下众筹的概念：一般是这样的，我一个非常好的想法，但是我没有钱来做这事，于是我把这个想法发给大家看，说：我做这件事需要5百万，大家有没有兴趣投些钱，如果大家在30天内投够了5百万我就开始做，到时大家都是原始股东，如果募资额不到5百万，大家投的钱就还给大家。</p><p>现在ICO众筹已经被各路大佬拿来割韭菜而被玩坏了（不管有无达标，都把钱卷走）。</p><p>其实区块链技术本事非常适合解决众筹的信任问题，借助于智能合约，可以实现当募资额完成时，募资款自动打到指定账户，当募资额未完成时，可退款。这个过程不需要看众筹大佬的人品，不用依靠第三方平台信用担保。</p><h2 id="代币"><a href="#代币" class="headerlink" title="代币"></a>代币</h2><p>传统的众筹在参与之后通常不容易交易（参与之后无法转给其他人），而通过用代币来参与众筹，则很容易进行交易，众筹的参与人可随时进行买卖，待众筹项目实施完成的时候，完全根据代币持有量进行回馈。</p><p>举个例子说明下，大家会更容易理解，有这一个众筹：A有技术做一个能监测健康的指环，为此向公众募资200百万，募资时100块对应一个代币，约定在指环上市之后，代币的持有人可以用一个代币来兑换一个指环。而指环的研发周期是一年，因此在指环还未上市的一年里，众筹的参与人可以随时交易所持有的代币。</p><h2 id="众筹智能合约代码"><a href="#众筹智能合约代码" class="headerlink" title="众筹智能合约代码"></a>众筹智能合约代码</h2><p>接下来就看看如何实现一个众筹智能合约。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">interface token &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address receiver, uint amount</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">Crowdsale</span> </span>&#123;</span><br><span class="line">    address public beneficiary;  <span class="comment">// 募资成功后的收款方</span></span><br><span class="line">    uint public fundingGoal;   <span class="comment">// 募资额度</span></span><br><span class="line">    uint public amountRaised;   <span class="comment">// 参与数量</span></span><br><span class="line">    uint public deadline;      <span class="comment">// 募资截止期</span></span><br><span class="line"></span><br><span class="line">    uint public price;    <span class="comment">//  token 与以太坊的汇率 , token卖多少钱</span></span><br><span class="line">    token public tokenReward;   <span class="comment">// 要卖的token</span></span><br><span class="line"></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    bool fundingGoalReached = <span class="literal">false</span>;  <span class="comment">// 众筹是否达到目标</span></span><br><span class="line">    bool crowdsaleClosed = <span class="literal">false</span>;   <span class="comment">//  众筹是否结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事件可以用来跟踪信息</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    event GoalReached(address recipient, uint totalAmountRaised);</span><br><span class="line">    event FundTransfer(address backer, uint amount, bool isContribution);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数, 设置相关属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Crowdsale</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address ifSuccessfulSendTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint fundingGoalInEthers,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint durationInMinutes,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint finneyCostOfEachToken,</span></span></span><br><span class="line"><span class="function"><span class="params">        address addressOfTokenUsedAsReward</span>) </span>&#123;</span><br><span class="line">            beneficiary = ifSuccessfulSendTo;</span><br><span class="line">            fundingGoal = fundingGoalInEthers * <span class="number">1</span> ether;</span><br><span class="line">            deadline = now + durationInMinutes * <span class="number">1</span> minutes;</span><br><span class="line">            price = finneyCostOfEachToken * <span class="number">1</span> finney;</span><br><span class="line">            tokenReward = token(addressOfTokenUsedAsReward);   <span class="comment">// 传入已发布的 token 合约的地址来创建实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无函数名的Fallback函数，</span></span><br><span class="line"><span class="comment">     * 在向合约转账时，这个函数会被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!crowdsaleClosed);</span><br><span class="line">        uint amount = msg.value;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        amountRaised += amount;</span><br><span class="line">        tokenReward.transfer(msg.sender, amount / price);</span><br><span class="line">        FundTransfer(msg.sender, amount, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  定义函数修改器modifier（作用和Python的装饰器很相似）</span></span><br><span class="line"><span class="comment">    * 用于在函数执行前检查某种前置条件（判断通过之后才会继续执行该方法）</span></span><br><span class="line"><span class="comment">    * _ 表示继续执行之后的代码</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    modifier afterDeadline() &#123; <span class="keyword">if</span> (now &gt;= deadline) _; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断众筹是否完成融资目标， 这个方法使用了afterDeadline函数修改器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkGoalReached</span>(<span class="params"></span>) <span class="title">afterDeadline</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amountRaised &gt;= fundingGoal) &#123;</span><br><span class="line">            fundingGoalReached = <span class="literal">true</span>;</span><br><span class="line">            GoalReached(beneficiary, amountRaised);</span><br><span class="line">        &#125;</span><br><span class="line">        crowdsaleClosed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成融资目标时，融资款发送到收款方</span></span><br><span class="line"><span class="comment">     * 未完成融资目标时，执行退款</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">safeWithdrawal</span>(<span class="params"></span>) <span class="title">afterDeadline</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fundingGoalReached) &#123;</span><br><span class="line">            uint amount = balanceOf[msg.sender];</span><br><span class="line">            balanceOf[msg.sender] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.sender.send(amount)) &#123;</span><br><span class="line">                    FundTransfer(msg.sender, amount, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    balanceOf[msg.sender] = amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fundingGoalReached &amp;&amp; beneficiary == msg.sender) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beneficiary.send(amountRaised)) &#123;</span><br><span class="line">                FundTransfer(beneficiary, amountRaised, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//If we fail to send the funds to beneficiary, unlock funders balance</span></span><br><span class="line">                fundingGoalReached = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署及说明"><a href="#部署及说明" class="headerlink" title="部署及说明"></a>部署及说明</h2><p>在部署这个合约之前，我们需要先部署一个代币合约，请参考<a href="https://learnblockchain.cn/2018/01/12/create_token/">一步步教你创建自己的数字货币</a>。</p><ol><li><p>创建众筹合约我们需要提供一下几个参数：<br>ifSuccessfulSendTo： 募资成功后的收款方（其实这里可以默认为合约创建者）<br>fundingGoalInEthers： 募资额度， 为了方便我们仅募3个ether<br>durationInMinutes： 募资时间<br>finneyCostOfEachToken 每个代币的价格, 这里为了方便使用了<a href="https://learnblockchain.cn/2018/02/02/solidity-unit/">单位finney</a>及值为：1 （1 ether =  1000 finney）<br>addressOfTokenUsedAsReward： 代币合约地址。<br>如：<br><img src="https://learnblockchain.cn/images/crowdsale_create.jpeg" alt=""><br>本文使用的参数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;0xc6f9ea59d424733e8e1902c7837ea75e20abfb49&quot;,3, 100, 1,&quot;0xad8972e2b583f580fc52f737b98327eb65d08f8c&quot;</span><br></pre></td></tr></table></figure></li><li><p>参与人投资的时候实际购买众筹合约代币，所以需要先向合约预存代币，代币的数量为：募资额度 / 代币的价格 ， 这里为：3 * 1000/1 = 3000 （当能也可以大于3000）。<br>向合约预存代币可以使用<a href="https://www.myetherwallet.com/#send-transaction" target="_blank" rel="noopener">myetherwallet</a>钱包，或在remix中重新加载代币合约，执行代币合约tranfer()函数进行代币转账，转账的地址就是我们创建合约的地址。如使用myetherwallet转账如图：<br><img src="https://learnblockchain.cn//images/crowdsale_send_token.jpeg" alt=""></p></li><li><p>投资人向众筹合约转账（发送以太币）即是参与众筹行为，转账时，会执行Fallback回退函数（即无名函数）向其账户打回相应的代币。</p></li><li><p>safeWithdrawl() 可以被参与人或收益人调用，如果融资不达标参与人可收回之前投资款，如果融资达标收益人可以拿到所有的融资款。</p></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>上面是一个很正规的募资合约。接下来讲两个募资合约的扩展，如何实现无限募资合约及割韭菜合约。<br>这部分内容独家发布在我的小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a></p><p>如果你在学习中遇到问题，欢迎到我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>提问，作为星球成员福利，成员可加入区块链技术付费交流群。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://ethereum.org/crowdsale" target="_blank" rel="noopener">Create a crowdsale</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
      <category term="ICO" scheme="https://learnblockchain.cn/tags/ICO/"/>
    
  </entry>
  
  <entry>
    <title>什么是拜占庭将军问题</title>
    <link href="https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/"/>
    <id>https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-07-16T04:44:51.302Z</updated>
    
    <content type="html"><![CDATA[<p>接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢?</p><a id="more"></a><h2 id="什么是拜占庭将军问题"><a href="#什么是拜占庭将军问题" class="headerlink" title="什么是拜占庭将军问题"></a>什么是拜占庭将军问题</h2><p>也被称为“拜占庭容错”、“拜占庭将军问题”。<br>拜占庭将军问题是Leslie Lamport（2013年的图灵讲得主）用来为描述<strong>分布式系统一致性问题</strong>（Distributed Consensus）在<a href="http://lamport.azurewebsites.net/pubs/byz.pdf" target="_blank" rel="noopener">论文</a>中抽象出来一个著名的例子。</p><p>这个例子大意是这样的：</p><p>拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？</p><blockquote><p>拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的.</p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>单从上面的说明可能无法理解这个问题的复杂性，我们来简单分析一下：</p><ol><li><p>先看在没有叛徒情况下，假如一个将军A提一个进攻提议（如：明日下午1点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午2点、3点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现A提议有3个支持者，B提议有4个支持者，C提议有2个支持者等等。</p></li><li><p>再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知A明日下午1点进攻， 通知B明日下午2点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午1点进攻又同意下午2点进攻）。</p><blockquote><p>叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为「Byzantine fault tolerance」，简称为BFT。</p></blockquote></li></ol><p>相信大家已经可以明白这个问题的复杂性了。</p><h2 id="中本聪的解决方案"><a href="#中本聪的解决方案" class="headerlink" title="中本聪的解决方案"></a>中本聪的解决方案</h2><p>在出现比特币之前，解决分布式系统一致性问题主要是Lamport提出的Paxos算法或其衍生算法。Paxos类算法仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。</p><p>中本聪在比特币中创造性的引入了“工作量证明（POW : Proof of Work）”来解决这个问题，有兴趣可进一步阅读<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">工作量证明</a>。<br>通过工作量证明就增加了发送信息的成本，降低节点发送消息速率，这样就以保证在一个时间只有一个节点(或是很少)在进行广播，同时在广播时会附上自己的签名。<br>这个过程就像一位将军A在向其他的将军（B、C、D…）发起一个进攻提议一样，将军B、C、D…看到将军A签过名的进攻提议书，如果是诚实的将军就会立刻同意进攻提议，而不会发起自己新的进攻提议。</p><p>以上就是比特币网络中是单个区块（账本）达成共识的方法（取得一致性）。</p><p>理解了单个区块取得一致性的方法，那么整个区块链（总账本）如果达成一致也好理解。<br>我们稍微把将军问题改一下：假设攻下一个城堡需要多次的进攻，每次进攻的提议必须基于之前最多次数的胜利进攻下提出的（只有这样敌方已有损失最大，我方进攻胜利的可能性就更大），这样约定之后，将军A在收到进攻提议时，就会检查一下这个提议是不是基于最多的胜利提出的，如果不是（基于最多的胜利）将军A就不会同意这样的提议，如果是的，将军A就会把这次提议记下来。</p><p>这就是比特币网络<a href="https://xiaozhuanlan.com/topic/0298513746" target="_blank" rel="noopener">最长链选择</a>。</p><h2 id="经济学分析"><a href="#经济学分析" class="headerlink" title="经济学分析"></a>经济学分析</h2><p>工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。</p><p>很多人批评工作量证明造成巨大的电力浪费，促使人们去探索新的解决一致性（共识）问题的机制：权益证明机制（POS: Proof of Stake）是一个代表。在拜占庭将军问题的角度来看，它同样提高了做叛徒的成本，因为账户需要首先持有大量余额才能有更多的几率广播区块，POS不是本文重点，以后在讲。</p><blockquote><p>共识算法的核心就是解决拜占庭将军问题（分布式网络一致性问题）。</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://lamport.azurewebsites.net/pubs/byz.pdf" target="_blank" rel="noopener">The Byzantine Generals Problem</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢?&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="共识协议" scheme="https://learnblockchain.cn/tags/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列7 - 以太单位及时间单位</title>
    <link href="https://learnblockchain.cn/2018/02/02/solidity-unit/"/>
    <id>https://learnblockchain.cn/2018/02/02/solidity-unit/</id>
    <published>2018-02-02T11:51:03.000Z</published>
    <updated>2018-03-19T03:26:58.537Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第7篇介绍以太单位及时间单位，系列带你全面深入理解Solidity语言。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="货币单位（Ether-Units）"><a href="#货币单位（Ether-Units）" class="headerlink" title="货币单位（Ether Units）"></a>货币单位（Ether Units）</h2><p>一个数字常量（字面量）后面跟随一个后缀<strong>wei</strong>, <strong>finney</strong>,<strong>szabo</strong>或<strong>ether</strong>，这个后缀就是货币单位。不同的单位可以转换。不含任何后缀的默认单位是wei。<br>不同的以太币单位转换关系如下：</p><ul><li>1 ether == 10^3 finney == 1000 finney</li><li>1 ether == 10^6 szabo</li><li>1 ether == 10^18 wei</li></ul><blockquote><p>插曲：以太币单位其实是密码学家的名字，是以太坊创始人为了纪念他们在数字货币的领域的贡献。他们分别是：<br>wei:  Wei Dai  戴伟 密码学家 ，发表 B-money<br>finney: Hal Finney   芬尼  密码学家、工作量证明机制（POW）提出<br>szabo:  Nick Szabo  尼克萨博  密码学家、智能合约的提出者</p></blockquote><p>我们可以使用一下代码验证一个转换关系：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract testUnit &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tf</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> ether == <span class="number">1000</span> finney)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ts</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> ether == <span class="number">1000000</span> szabo)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tgw</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> ether == <span class="number">1000000000000000000</span> wei)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="时间单位（Time-Units）"><a href="#时间单位（Time-Units）" class="headerlink" title="时间单位（Time Units）"></a>时间单位（Time Units）</h2><p>时间单位: seconds, minutes, hours, days, weeks, years均可做为后缀，并进行相互转换，规则如下：</p><ul><li>1 == 1 seconds (默认是seconds为单位)</li><li>1 minutes == 60 seconds</li><li>1 hours == 60 minutes</li><li>1 days == 24 hours</li><li>1 weeks = 7 days</li><li>1 years = 365 days</li></ul><p>使用这些单位进行日期计算需要特别小心，因为不是每年都是365天，且并不是每天都有24小时，因为还有闰秒。由于无法预测闰秒，必须由外部的预言（oracle）来更新从而得到一个精确的日历库。</p><p>这些后缀不能用于变量。如果想对输入的变量说明其不同的单位，可以使用下面的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract testTUnit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">currTimeInSeconds</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint256</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint start, uint daysAfter</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= start + daysAfter * <span class="number">1</span> days) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables" target="_blank" rel="noopener">units</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第7篇介绍以太单位及时间单位，系列带你全面深入理解Solidity语言。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>实现一个可管理、增发、兑换、冻结等高级功能的代币</title>
    <link href="https://learnblockchain.cn/2018/01/27/create-token2/"/>
    <id>https://learnblockchain.cn/2018/01/27/create-token2/</id>
    <published>2018-01-27T09:04:13.000Z</published>
    <updated>2018-04-09T14:52:20.591Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。<br><a id="more"></a></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在<a href="https://learnblockchain.cn/2018/01/12/create_token/">上一篇：一步步教你创建自己的数字货币（代币）进行ICO</a>中我们实现一个最基本功能的代币，本文将在上一遍文章的基础上，讲解如果添加更多的高级功能。</p><h2 id="实现代币的管理者"><a href="#实现代币的管理者" class="headerlink" title="实现代币的管理者"></a>实现代币的管理者</h2><p>虽然区块链是去中心化的，但是实现对代币（合约）的管理，也在许多应用中有需求，为了对代币进行管理，首先需要给合约添加一个管理者。</p><p>我们来看看如果实现，先创建一个<strong>owned</strong>合约。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract owned &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">owned</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现所有权转移</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferOwnership</span>(<span class="params">address newOwner</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约重要的是加入了一个函数修改器（Function Modifiers）<strong>onlyOwner</strong>，函数修改器是一个合约属性，可以被继承，还能被重写。它用于在函数执行前检查某种前置条件。<br>关于函数修改器可进一步阅读<a href="https://learnblockchain.cn/2018/04/09/solidity-modify/">Solidity 教程系列10 - 完全理解函数修改器</a></p><blockquote><p>如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。</p></blockquote><p>然后让代币合约继承owned以拥有<strong>onlyOwner</strong>修改器，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract MyToken is owned &#123;</span><br><span class="line">    function MyToken(</span><br><span class="line">        uint256 initialSupply,</span><br><span class="line">        string tokenName,</span><br><span class="line">        uint8 decimalUnits,</span><br><span class="line">        string tokenSymbol,</span><br><span class="line">        address centralMinter</span><br><span class="line">        ) &#123;</span><br><span class="line">        if(centralMinter != 0 ) owner = centralMinter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代币增发"><a href="#代币增发" class="headerlink" title="代币增发"></a>代币增发</h2><p>实现代币增发，代币增发就如同央行印钞票一样，想必很多人都需要这样的功能。</p><p>给合约添加以下的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mintToken</span>(<span class="params">address target, uint256 mintedAmount</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        balanceOf[target] += mintedAmount;</span><br><span class="line">        totalSupply += mintedAmount;</span><br><span class="line">        Transfer(<span class="number">0</span>, owner, mintedAmount);</span><br><span class="line">        Transfer(owner, target, mintedAmount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>注意<strong>onlyOwner</strong>修改器添加在函数末尾，这表示只有<strong>ower</strong>才能调用这用函数。<br>他的功能很简单，就是给指定的账户增加代币，同时增加总供应量。</p><h2 id="资产冻结"><a href="#资产冻结" class="headerlink" title="资产冻结"></a>资产冻结</h2><p>有时为了监管的需要，需要实现冻结某些账户，冻结后，其资产仍在账户，但是不允许交易，之道解除冻结。<br>给合约添加以下的变量和方法（可以添加到合约的任何地方，但是建议把mapping加到和其他mapping一起，event也是如此）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) public frozenAccount;</span><br><span class="line">event FrozenFunds(address target, bool frozen);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freezeAccount</span>(<span class="params">address target, bool freeze</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    frozenAccount[target] = freeze;</span><br><span class="line">    FrozenFunds(target, freeze);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单单以上的代码还无法冻结，需要把他加入到transfer函数中才能真正生效，因此修改transfer函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!frozenAccount[msg.sender]);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样在转账前，对发起交易的账号做一次检查，只有不是被冻结的账号才能转账。</p><h2 id="代币买卖（兑换）"><a href="#代币买卖（兑换）" class="headerlink" title="代币买卖（兑换）"></a>代币买卖（兑换）</h2><p>可以自己的货币中实现代币与其他数字货币（ether 或其他tokens）的兑换机制。有了这个功能，我们的合约就可以在一买一卖中赚利润了。</p><p>先来设置下买卖价格<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint256 public sellPrice;</span><br><span class="line">uint256 public buyPrice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPrices</span>(<span class="params">uint256 newSellPrice, uint256 newBuyPrice</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    sellPrice = newSellPrice;</span><br><span class="line">    buyPrice = newBuyPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setPrices()添加了<strong>onlyOwner</strong>修改器，注意买卖的价格单位是wei（最小的货币单位： 1 eth = 1000000000000000000 wei)</p><p>添加来添加买卖函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params"></span>) <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint amount</span>)</span>&#123;</span><br><span class="line">    amount = msg.value / buyPrice;                    <span class="comment">// calculates the amount</span></span><br><span class="line">    <span class="built_in">require</span>(balanceOf[<span class="keyword">this</span>] &gt;= amount);               <span class="comment">// checks if it has enough to sell</span></span><br><span class="line">    balanceOf[msg.sender] += amount;                  <span class="comment">// adds the amount to buyer's balance</span></span><br><span class="line">    balanceOf[<span class="keyword">this</span>] -= amount;                        <span class="comment">// subtracts amount from seller's balance</span></span><br><span class="line">    Transfer(<span class="keyword">this</span>, msg.sender, amount);               <span class="comment">// execute an event reflecting the change</span></span><br><span class="line">    <span class="keyword">return</span> amount;                                    <span class="comment">// ends function and returns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sell</span>(<span class="params">uint amount</span>) <span class="title">returns</span> (<span class="params">uint revenue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(balanceOf[msg.sender] &gt;= amount);         <span class="comment">// checks if the sender has enough to sell</span></span><br><span class="line">    balanceOf[<span class="keyword">this</span>] += amount;                        <span class="comment">// adds the amount to owner's balance</span></span><br><span class="line">    balanceOf[msg.sender] -= amount;                  <span class="comment">// subtracts the amount from seller's balance</span></span><br><span class="line">    revenue = amount * sellPrice;</span><br><span class="line">    msg.sender.transfer(revenue);                     <span class="comment">// sends ether to the seller: it's important to do this last to prevent recursion attacks</span></span><br><span class="line">    Transfer(msg.sender, <span class="keyword">this</span>, amount);               <span class="comment">// executes an event reflecting on the change</span></span><br><span class="line">    <span class="keyword">return</span> revenue;                                   <span class="comment">// ends function and returns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加入了买卖功能后，要求我们在创建合约时发送足够的以太币，以便合约有能力回购市面上的代币，否则合约将破产，用户没法先合约卖代币。</p><h2 id="实现Gas的自动补充"><a href="#实现Gas的自动补充" class="headerlink" title="实现Gas的自动补充"></a>实现Gas的自动补充</h2><p>以太坊中的交易时需要gas（支付给矿工的费用，费用以ether来支付）。而如果用户没有以太币，只有代币的情况（或者我们想向用户隐藏以太坊的细节），就需要自动补充gas的功能。这个功能将使我们代币更加好用。</p><p>自动补充的逻辑是这样了，在执行交易之前，我们判断用户的余额（用来支付矿工的费用），如果用户的余额非常少（低于某个阈值时）可能影响到交易进行，合约自动售出一部分代币来补充余额，以帮助用户顺利完成交易。</p><p>先来设定余额阈值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint minBalanceForAccounts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setMinBalance</span>(<span class="params">uint minimumBalanceInFinney</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">         minBalanceForAccounts = minimumBalanceInFinney * <span class="number">1</span> finney;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>finney 是货币单位 1 finney = 0.001eth<br>然后交易中加入对用户的余额的判断。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(msg.sender.balance &lt; minBalanceForAccounts)</span><br><span class="line">        sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);</span><br><span class="line">    <span class="keyword">if</span>(_to.balance&lt;minBalanceForAccounts)   <span class="comment">// 可选，让接受者也补充余额，以便接受者使用代币。</span></span><br><span class="line">        _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码部署"><a href="#代码部署" class="headerlink" title="代码部署"></a>代码部署</h2><p>高级功能完整代码请前往我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>， 项目的完整的部署方法参考<a href="https://learnblockchain.cn/2018/01/12/create_token/">上一篇</a>，不同的是创建合约时需要预存余额，如图：</p><p><img src="https://learnblockchain.cn/images/create_adv_token.jpg" alt=""></p><p>专栏已经有多篇文章介绍Remix Solidity IDE的使用，这里就不一一截图演示了，请大家自己测试验证。</p><p>如果你在创建代币的过程中遇到问题，欢迎到我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>提问，作为星球成员福利，成员可加入区块链技术付费交流群。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://ethereum.org/token" target="_blank" rel="noopener">Create your own crypto-currency with ethereum</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。&lt;br&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
  </entry>
  
  <entry>
    <title>一步步教你创建自己的数字货币（代币）进行ICO</title>
    <link href="https://learnblockchain.cn/2018/01/12/create_token/"/>
    <id>https://learnblockchain.cn/2018/01/12/create_token/</id>
    <published>2018-01-12T14:36:39.000Z</published>
    <updated>2018-02-08T12:34:13.385Z</updated>
    
    <content type="html"><![CDATA[<p>本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程.</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="代币Token"><a href="#代币Token" class="headerlink" title="代币Token"></a>代币Token</h2><p>如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。<br>利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。<br>因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。<br><img src="https://learnblockchain.cn/images/token_info.jpeg" alt=""></p><p>今天我们就来详细讲一讲怎样创建一个这样的代币。</p><h3 id="ERC20-Token"><a href="#ERC20-Token" class="headerlink" title="ERC20 Token"></a>ERC20 Token</h3><p>也许你经常看到ERC20和代币一同出现， ERC20是以太坊定义的一个<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md" target="_blank" rel="noopener">代币标准</a>。<br>要求我们在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。<br>其接口如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = <span class="string">"Token Name"</span>;</span><br><span class="line">    string public constant symbol = <span class="string">"SYM"</span>;</span><br><span class="line">    uint8 public constant decimals = <span class="number">18</span>;  <span class="comment">// 18 is the most common number of decimal places</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">balanceOf</span>(<span class="params">address tokenOwner</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint balance</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">allowance</span>(<span class="params">address tokenOwner, address spender</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint remaining</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transfer</span>(<span class="params">address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address spender, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address from, address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Transfer</span>(<span class="params">address indexed from, address indexed to, uint tokens</span>);</span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Approval</span>(<span class="params">address indexed tokenOwner, address indexed spender, uint tokens</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>简单说明一下：<br>name ：  代币名称<br>symbol： 代币符号<br>decimals： 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。<br>totalSupply() : 发行代币总量。<br>balanceOf(): 查看对应账号的代币余额。<br>transfer(): 实现代币交易，用于给用户发送代币（从我们的账户里）。<br>transferFrom():  实现代币用户之间的交易。<br>allowance(): 控制代币的交易，如可交易账号及资产。<br>approve():  允许用户可花费的代币数。</p><h2 id="编写代币合约代码"><a href="#编写代币合约代码" class="headerlink" title="编写代币合约代码"></a>编写代币合约代码</h2><p>代币合约代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">interface tokenRecipient &#123; <span class="function"><span class="keyword">function</span> <span class="title">receiveApproval</span>(<span class="params">address _from, uint256 _value, address _token, bytes _extraData</span>) <span class="title">public</span>; &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">TokenERC20</span> </span>&#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals = <span class="number">18</span>;  <span class="comment">// 18 是建议的默认值</span></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;  <span class="comment">// </span></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    event Burn(address indexed <span class="keyword">from</span>, uint256 value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">TokenERC20</span>(<span class="params">uint256 initialSupply, string tokenName, string tokenSymbol</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        totalSupply = initialSupply * <span class="number">10</span> ** uint256(decimals);</span><br><span class="line">        balanceOf[msg.sender] = totalSupply;</span><br><span class="line">        name = tokenName;</span><br><span class="line">        symbol = tokenSymbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_transfer</span>(<span class="params">address _from, address _to, uint _value</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_to != <span class="number">0x0</span>);</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_from] &gt;= _value);</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_to] + _value &gt; balanceOf[_to]);</span><br><span class="line">        uint previousBalances = balanceOf[_from] + balanceOf[_to];</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        balanceOf[_to] += _value;</span><br><span class="line">        Transfer(_from, _to, _value);</span><br><span class="line">        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= allowance[_from][msg.sender]);     <span class="comment">// Check allowance</span></span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        _transfer(_from, _to, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address _spender, uint256 _value</span>) <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        allowance[msg.sender][_spender] = _value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approveAndCall</span>(<span class="params">address _spender, uint256 _value, bytes _extraData</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        tokenRecipient spender = tokenRecipient(_spender);</span><br><span class="line">        <span class="keyword">if</span> (approve(_spender, _value)) &#123;</span><br><span class="line">            spender.receiveApproval(msg.sender, _value, <span class="keyword">this</span>, _extraData);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[msg.sender] &gt;= _value);</span><br><span class="line">        balanceOf[msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;</span><br><span class="line">        Burn(msg.sender, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burnFrom</span>(<span class="params">address _from, uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_from] &gt;= _value);</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= allowance[_from][msg.sender]);</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;</span><br><span class="line">        Burn(_from, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的详细解读，请订阅我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在开发测试智能合约时，<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>和<a href="https://remix.ethereum.org" target="_blank" rel="noopener">Remix Solidity IDE</a>是两个非常好用的工具，今天就用他们来完成部署。</p><ol><li><p>安装和配置MetaMask请参考<a href="https://learnblockchain.cn/2018/01/12/first-dapp">开发、部署第一个去中心化应用</a>，不同的上本文选择了以太坊的测试网络Ropsten，如果你没有余额请点击购买buy，进入的网站可以送一些测试以太币给你，配置好之后，界面应该如下：<br><img src="https://learnblockchain.cn/images/metamask_main.png" alt=""></p></li><li><p>浏览器打开Remix Solidity IDE，复制以上源码粘贴上，在右侧选项参考如图的设置：<br><img src="https://learnblockchain.cn/images/token_create_remix.jpeg" alt=""><br>注意Environment和Account和MetaMask保持一致，然后选择合约TokenERC20，填入你想要的发行量，名称及代号，就可以创建合约了。<br>这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。</p></li><li><p>打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框：<br><img src="https://learnblockchain.cn/images/metamask_add_token.png" alt=""><br>填入刚刚复制的地址，点ADD，这时你就可以看到你创建的代币了，如图：<br><img src="https://learnblockchain.cn/images/metamask_token_added.png" alt=""></p></li></ol><p>哈哈，你已经完成了代币的创建和部署(正式网络和测试网络部署方法一样)，可以在<a href="https://ropsten.etherscan.io/token/0x1f0c085ad323bb69758111cf9ecdc32a32d9a5bb" target="_blank" rel="noopener">Etherscan</a>查询到我们刚刚部署的代币。可以用它进行ICO了，从此走上人生巅峰（玩笑话，不鼓励大家发行无意义的代币）。</p><h2 id="代币交易"><a href="#代币交易" class="headerlink" title="代币交易"></a>代币交易</h2><p>由于MetaMask插件没有提供代币交易功能，同时考虑到很多人并没有以太坊钱包或是被以太坊钱包网络同步问题折磨，今天我用<a href="https://www.myetherwallet.com" target="_blank" rel="noopener">网页钱包</a>来讲解代币交易。</p><ol><li>进入<a href="https://www.myetherwallet.com/#send-transaction" target="_blank" rel="noopener">网页钱包地址</a>, 第一次进入有一些安全提示需要用户确认。</li><li>进入之后，按照下图进行设置：<br><img src="https://learnblockchain.cn/images/myetherwaller.jpeg" alt=""></li><li>连接上之后，如图<br><img src="https://learnblockchain.cn/images/myetherwaller_connected.jpeg" alt=""><br>需要添加代币，填入代币合约地址。</li><li>进行代币转账交易<br><img src="https://learnblockchain.cn/images/myetherwaller_transfer.jpeg" alt=""><br>在接下来的交易确认也，点击确认即可。</li><li>交易完成后，可以看到MetaMask中代币余额减少了，如图：<br><img src="https://learnblockchain.cn/images/metamask_token_tansfered.png" alt=""></li></ol><p>代币交易是不是很简单，只要明白了交易流程，使用其他的钱包也是一样的道理。</p><p>如果你在创建代币的过程中遇到问题，我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>可为大家解答问题，作为星球成员福利，成员还可加入区块链技术付费交流群。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" target="_blank" rel="noopener">代币标准</a></li><li><a href="https://ethereum.org/token" target="_blank" rel="noopener">Create your own crypto-currency with ethereum</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程.&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
  </entry>
  
  <entry>
    <title>一步步教你开发、部署第一个去中心化应用(Dapp) - 宠物商店</title>
    <link href="https://learnblockchain.cn/2018/01/12/first-dapp/"/>
    <id>https://learnblockchain.cn/2018/01/12/first-dapp/</id>
    <published>2018-01-12T14:36:39.000Z</published>
    <updated>2018-01-24T12:39:59.700Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和<a href="https://learnblockchain.cn/2017/11/24/init-env/">编写智能合约</a>结合起来看。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a><br>除此之外，你最好还了解一些HTML及JavaScript知识。</p><p>本文通过实例教大家来开发去中心化应用，应用效果如图：<br><img src="https://learnblockchain.cn/images/Petshop.jpg" alt=""></p><p>从本文，你可以学习到：</p><ul><li>搭建智能合约开发环境</li><li>创建Truffle项目</li><li>编写智能合约</li><li>编译和部署智能合约到区块链</li><li>如何通过Web3和智能合约交互</li><li>MetaMask 的使用</li></ul><p><a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>用户在教程结尾处可以下载完整的Dapp代码。</p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>Pete有一个宠物店，有16只宠物，他想开发一个去中心化应用，让大家来领养宠物。<br>在truffle box中，已经提供了pet-shop的网站部分的代码，我们只需要编写合约及交互部分。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node</a></li><li>安装 Truffle ：<code>npm install -g truffle</code></li><li>安装<a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a></li></ol><blockquote><p>Ganache（或Ganache CLI）已经取代了 testrpc。</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol><li><p>建立项目目录并进入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir pet-shop-tutorial</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> pet-shop-tutorial</span></span><br></pre></td></tr></table></figure></li><li><p>使用truffle unbox 创建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> &gt;</span><span class="bash"> truffle unbox pet-shop</span></span><br><span class="line"> Downloading...</span><br><span class="line"> Unpacking...</span><br><span class="line"> Setting up...</span><br><span class="line"> Unbox successful. Sweet!</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  Compile:        truffle compile</span><br><span class="line">  Migrate:        truffle migrate</span><br><span class="line">  Test contracts: truffle test</span><br><span class="line">  Run dev server: npm run dev</span><br></pre></td></tr></table></figure></li></ol><p>这一步需要等待一会</p><blockquote><p>也可以使用truffle init 来创建一个全新的项目。</p></blockquote><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><code>contracts/</code>  智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol（稍后再讲）<br><code>migrations/</code> 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。<br><code>test/</code> 智能合约测试用例文件夹<br><code>truffle.js/</code> 配置文件</p><p>其他代码可以暂时不用管</p><h2 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h2><p>智能合约承担着分布式应用的后台逻辑和存储。智能合约使用solidity编写，可阅读<br><a href="https://learnblockchain.cn/categories/ethereum/Solidity/">solidity系列文章</a></p><p>在contracts目录下，添加合约文件Adoption.sol<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">contract Adoption &#123;</span><br><span class="line"></span><br><span class="line">  address[<span class="number">16</span>] public adopters;  <span class="comment">// 保存领养者的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 领养宠物</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">adopt</span>(<span class="params">uint petId</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(petId &gt;= <span class="number">0</span> &amp;&amp; petId &lt;= <span class="number">15</span>);  <span class="comment">// 确保id在数组长度内</span></span><br><span class="line"></span><br><span class="line">    adopters[petId] = msg.sender;        <span class="comment">// 保存调用这地址 </span></span><br><span class="line">    <span class="keyword">return</span> petId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回领养者</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAdopters</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address[<span class="number">16</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adopters;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编译部署智能合约"><a href="#编译部署智能合约" class="headerlink" title="编译部署智能合约"></a>编译部署智能合约</h2><p>Truffle集成了一个开发者控制台，可用来生成一个开发链用来测试和部署智能合约。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>Solidity是编译型语言，需要把可读的Solidity代码编译为EVM字节码才能运行。<br>dapp的根目录pet-shop-tutorial下，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> truffle compile</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compiling ./contracts/Adoption.sol...</span><br><span class="line">Writing artifacts to ./build/contracts</span><br></pre></td></tr></table></figure></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>编译之后，就可以部署到区块链上。<br>在migrations文件夹下已经有一个1_initial_migration.js部署脚本，用来部署Migrations.sol合约。<br>Migrations.sol 用来确保不会部署相同的合约。</p><p>现在我们来创建一个自己的部署脚本<code>2_deploy_contracts.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Adoption = artifacts.require(&quot;Adoption&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  deployer.deploy(Adoption);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在执行部署之前，需要确保有一个区块链运行, 可以使用<br><a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a>来开启一个私链来进行开发测试，默认会在7545端口上运行一个开发链。<br>Ganache 启动之后是这样：<br><img src="https://learnblockchain.cn/images/ganache-initial.png" alt=""></p><p>接下来执行部署命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; truffle  migrate</span><br></pre></td></tr></table></figure></p><p>执行后，有一下类似的输出，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Using network &apos;develop&apos;.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Deploying Migrations...</span><br><span class="line">  ... 0x3076b7dac65afc44ec51508bf6f2b6894f833f0f9560ecad2d6d41ed98a4679f</span><br><span class="line">  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Deploying Adoption...</span><br><span class="line">  ... 0x2c6ab4471c225b5473f2079ee42ca1356007e51d5bb57eb80bfeb406acc35cd4</span><br><span class="line">  Adoption: 0x345ca3e014aaf5dca488057592ee47305d9b3e10</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure></p><p>在打开的Ganache里可以看到区块链状态的变化，现在产生了4个区块。<br><img src="https://learnblockchain.cn/images/ganache-migrated.png" alt=""><br>这时说明已经智能合约已经部署好了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们来测试一下智能合约，测试用例可以用 JavaScript or Solidity来编写，这里使用Solidity。</p><p>在<code>test</code>目录下新建一个<code>TestAdoption.sol</code>，编写测试合约<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"truffle/Assert.sol"</span>;   <span class="comment">// 引入的断言</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"truffle/DeployedAddresses.sol"</span>;  <span class="comment">// 用来获取被测试合约的地址</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../contracts/Adoption.sol"</span>;      <span class="comment">// 被测试合约</span></span><br><span class="line"></span><br><span class="line">contract TestAdoption &#123;</span><br><span class="line">  Adoption adoption = Adoption(DeployedAddresses.Adoption());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 领养测试用例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testUserCanAdoptPet</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    uint returnedId = adoption.adopt(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    uint expected = <span class="number">8</span>;</span><br><span class="line">    Assert.equal(returnedId, expected, <span class="string">"Adoption of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 宠物所有者测试用例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testGetAdopterAddressByPetId</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易，</span></span><br><span class="line">    address expected = <span class="keyword">this</span>;</span><br><span class="line">    address adopter = adoption.adopters(<span class="number">8</span>);</span><br><span class="line">    Assert.equal(adopter, expected, <span class="string">"Owner of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试所有领养者</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testGetAdopterAddressByPetIdInArray</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 领养者的地址就是本合约地址</span></span><br><span class="line">    address expected = <span class="keyword">this</span>;</span><br><span class="line">    address[<span class="number">16</span>] memory adopters = adoption.getAdopters();</span><br><span class="line">    Assert.equal(adopters[<span class="number">8</span>], expected, <span class="string">"Owner of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Assert.sol 及 DeployedAddresses.sol是Truffle框架提供，在test目录下并不提供truffle目录。</p><p>TestAdoption合约中添加adopt的测试用例</p><h3 id="运行测试用例"><a href="#运行测试用例" class="headerlink" title="运行测试用例"></a>运行测试用例</h3><p>在终端中，执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>如果测试通过，则终端输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Using network &apos;develop&apos;.</span><br><span class="line"></span><br><span class="line">Compiling ./contracts/Adoption.sol...</span><br><span class="line">Compiling ./test/TestAdoption.sol...</span><br><span class="line">Compiling truffle/Assert.sol...</span><br><span class="line">Compiling truffle/DeployedAddresses.sol...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  TestAdoption</span><br><span class="line">    ✓ testUserCanAdoptPet (62ms)</span><br><span class="line">    ✓ testGetAdopterAddressByPetId (53ms)</span><br><span class="line">    ✓ testGetAdopterAddressByPetIdInArray (73ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (554ms)</span><br></pre></td></tr></table></figure></p><h2 id="创建用户接口和智能合约交互"><a href="#创建用户接口和智能合约交互" class="headerlink" title="创建用户接口和智能合约交互"></a>创建用户接口和智能合约交互</h2><p>我们已经编写和部署及测试好了我们的合约，接下我们为合约编写UI，让合约真正可以用起来。</p><p>在Truffle Box <code>pet-shop</code>里，已经包含了应用的前端代码，代码在<code>src/</code>文件夹下。</p><p>在编辑器中打开<code>src/js/app.js</code><br>可以看到用来管理整个应用的App对象，init函数加载宠物信息，就初始化<a href="https://github.com/ethereum/web3.js/" target="_blank" rel="noopener">web3</a>.<br>web3是一个实现了与以太坊节点通信的库，我们利用web3来和合约进行交互。</p><h3 id="初始化web3"><a href="#初始化web3" class="headerlink" title="初始化web3"></a>初始化web3</h3><p>接下来，我们来编辑app.js修改initWeb3():<br>删除注释，修改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">initWeb3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Is there an injected web3 instance?</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    App.web3Provider = web3.currentProvider;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If no injected web3 instance is detected, fall back to Ganache</span></span><br><span class="line">    App.web3Provider = <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:7545'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  web3 = <span class="keyword">new</span> Web3(App.web3Provider);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> App.initContract();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中优先使用<a href="https://github.com/ethereum/mist" target="_blank" rel="noopener">Mist</a> 或 <a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>提供的web3实例，如果没有则从本地环境创建一个。</p><h3 id="实例化合约"><a href="#实例化合约" class="headerlink" title="实例化合约"></a>实例化合约</h3><p>使用truffle-contract会帮我们保存合约部署的信息，就不需要我们手动修改合约地址，修改initContract()代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initContract: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 加载Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息</span></span><br><span class="line">  $.getJSON(<span class="string">'Adoption.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用Adoption.json数据创建一个可交互的TruffleContract合约实例。</span></span><br><span class="line">    <span class="keyword">var</span> AdoptionArtifact = data;</span><br><span class="line">    App.contracts.Adoption = TruffleContract(AdoptionArtifact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the provider for our contract</span></span><br><span class="line">    App.contracts.Adoption.setProvider(App.web3Provider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use our contract to retrieve and mark the adopted pets</span></span><br><span class="line">    <span class="keyword">return</span> App.markAdopted();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> App.bindEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="处理领养"><a href="#处理领养" class="headerlink" title="处理领养"></a>处理领养</h3><p>修改markAdopted()代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">markAdopted: <span class="function"><span class="keyword">function</span>(<span class="params">adopters, account</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adoptionInstance;</span><br><span class="line"></span><br><span class="line">  App.contracts.Adoption.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    adoptionInstance = instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用合约的getAdopters(), 用call读取信息不用消耗gas</span></span><br><span class="line">    <span class="keyword">return</span> adoptionInstance.getAdopters.call();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">adopters</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adopters.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (adopters[i] !== <span class="string">'0x0000000000000000000000000000000000000000'</span>) &#123;</span><br><span class="line">        $(<span class="string">'.panel-pet'</span>).eq(i).find(<span class="string">'button'</span>).text(<span class="string">'Success'</span>).attr(<span class="string">'disabled'</span>, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改handleAdopt()代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">handleAdopt: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> petId = <span class="built_in">parseInt</span>($(event.target).data(<span class="string">'id'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adoptionInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取用户账号</span></span><br><span class="line">  web3.eth.getAccounts(<span class="function"><span class="keyword">function</span>(<span class="params">error, accounts</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> account = accounts[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">    App.contracts.Adoption.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">      adoptionInstance = instance;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 发送交易领养宠物</span></span><br><span class="line">      <span class="keyword">return</span> adoptionInstance.adopt(petId, &#123;<span class="attr">from</span>: account&#125;);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> App.markAdopted();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在浏览器中运行"><a href="#在浏览器中运行" class="headerlink" title="在浏览器中运行"></a>在浏览器中运行</h2><h3 id="安装-MetaMask"><a href="#安装-MetaMask" class="headerlink" title="安装 MetaMask"></a>安装 MetaMask</h3><p>MetaMask 是一款插件形式的以太坊轻客户端，开发过程中使用MetaMask和我们的dapp进行交互是个很好的选择，通过此<a href="https://metamask.io/" target="_blank" rel="noopener">链接</a>安装，安装完成后，浏览器工具条会显示一个小狐狸图标。</p><h3 id="配置钱包"><a href="#配置钱包" class="headerlink" title="配置钱包"></a>配置钱包</h3><p>在接受隐私说明后，会出现页面如下：<br><img src="https://learnblockchain.cn/images/metamask-initial.png" alt=""></p><p>这里我们通过还原一个Ganache为我们创建好的钱包，作为我们的开发测试钱包。点击页面的<strong> Import Existing DEN</strong>，输入Ganache显示的助记词。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p><p>然后自己想要的密码，点击OK。<br>如图：<br><img src="https://learnblockchain.cn/images/metamask-seed.png" alt=""></p><h3 id="连接开发区块链网络"><a href="#连接开发区块链网络" class="headerlink" title="连接开发区块链网络"></a>连接开发区块链网络</h3><p>默认连接的是以太坊主网（左上角显示），选择<strong>Custom RPC</strong>，添加一个网络：<strong><a href="http://127.0.0.1:7545" target="_blank" rel="noopener">http://127.0.0.1:7545</a></strong>，点返回后，显示如下：<br><img src="/images/metamask-account1.png" alt=""><br>这是左上角显示为<strong>Private Network</strong>，账号是Ganache中默认的第一个账号。</p><p>至此MetaMask的安装，配置已经完成。</p><h3 id="安装和配置lite-server"><a href="#安装和配置lite-server" class="headerlink" title="安装和配置lite-server"></a>安装和配置lite-server</h3><p>接下来需要本地的web 服务器提供服务的访问， Truffle Box <strong>pet-shop</strong>里提供了一个<strong>lite-server</strong>可以直接使用，我们看看它是如何工作的。<br><strong>bs-config.json</strong>指示了lite-server的工作目录。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseDir"</span>: [<span class="string">"./src"</span>, <span class="string">"./build/contracts"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>./src 是网站文件目录<br>./build/contracts 是合约输出目录</p><p>以此同时，在package.json文件的scripts中添加了dev命令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "lite-server",</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>当运行npm run dev的时候，就会启动lite-server</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run dev</span><br></pre></td></tr></table></figure><p>会自动打开浏览器显示我们的dapp，如本文的第一张图。<br>现在领养一直宠物看看，当我们点击<strong>Adopt</strong>时，MetaMask会提示我们交易的确认，如图：</p><p><img src="https://learnblockchain.cn/images/metamask-transactionconfirm.png" alt=""></p><p>点击Submit确认后，就可以看到成功领养了这次宠物。</p><p>在MetaMask中，也可以看到交易的清单：<br><img src="https://learnblockchain.cn/images/metamask-transactionsuccess.png" alt=""></p><p>好了，恭喜你，即将成为一名去中心化式应用开发者的你已经成为迈出了坚实的一步。<br>如果学习中遇到问题，欢迎来我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>交流。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://truffleframework.com/tutorials/pet-shop" target="_blank" rel="noopener">Truffle手册</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和&lt;a href=&quot;https://learnblockchain.cn/2017/11/24/init-env/&quot;&gt;编写智能合约&lt;/a&gt;结合起来看。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Dapp" scheme="https://learnblockchain.cn/categories/ethereum/Dapp/"/>
    
    
      <category term="Dapp入门" scheme="https://learnblockchain.cn/tags/Dapp%E5%85%A5%E9%97%A8/"/>
    
      <category term="以太坊概念" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术学习指引</title>
    <link href="https://learnblockchain.cn/2018/01/11/guide/"/>
    <id>https://learnblockchain.cn/2018/01/11/guide/</id>
    <published>2018-01-11T07:03:36.000Z</published>
    <updated>2018-06-15T08:42:40.817Z</updated>
    
    <content type="html"><![CDATA[<p>本文为博客文章索引，小白必看。有新文章时会更新本文，建议大家加入收藏夹中，如果你觉得本站不错，欢迎你转发给朋友。</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>给迷失在如何学习区块链技术的同学一个指引，区块链技术是随比特币诞生，因此要搞明白区块链技术，应该先了解下比特币。<br>但区块链技术不单应用于比特币，还有非常多的现实应用场景，想做区块链应用开发，可进一步阅读以太坊系列。</p><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>如果你是还不知比特币是什么，那就看看<a href="https://learnblockchain.cn/2017/10/23/whatisbitcoin/">比特币是什么</a></p><h3 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h3><p>接下来可以通过下面这几篇文章了解比特币大概的运行原理：</p><ul><li><a href="https://learnblockchain.cn/2017/10/25/whatbc/">区块链记账原理</a><br> 通过这篇可以了解到区块链是一个怎样的结构</li><li><a href="https://learnblockchain.cn/2017/11/02/bitcoin-own/">比特币所有权及隐私问题</a><br> 通过这篇可以了解到地址私钥 非对称加密应用 等概念</li><li><a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">比特币如何挖矿</a><br> 通过这篇了解工作量证明</li><li><a href="https://learnblockchain.cn/2017/12/07/bitcoin-sonsensus/">比特币如何达成共识 - 最长链的选择</a><br> 通过这篇可以了解共识机制。<h3 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h3></li><li><a href="https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/">什么是拜占庭将军问题</a></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>在基础入门之后，可以进一步阅读以下几篇，理解分布式网络，交易验证。</p><ul><li><a href="https://learnblockchain.cn/2017/11/07/bitcoin-p2p/">分析比特币网络：一种去中心化、点对点的网络架构</a></li><li><a href="https://learnblockchain.cn/2017/11/10/bitcoin-script/">比特币区块结构 Merkle 树及简单支付验证分析</a></li><li><a href="https://xiaozhuanlan.com/topic/1402935768" target="_blank" rel="noopener">比特币脚本及交易分析 - 智能合约雏形</a></li></ul><p>看完上面这些，区块链应该理解差不多了，就可以尝试实现一个简单的区块链了。参考这篇<a href="https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/">用Python从零开始创建区块链</a>。</p><h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>一个技术要落地还得靠应用， 以太坊就这样一个建立在区块链技术之上，去中心化的应用平台。可以阅读几下几篇，这部分以开发为主，需要大家多发时间实践。</p><ul><li><a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊开发入门</a></li><li><a href="https://learnblockchain.cn/2017/11/24/init-env/">智能合约开发环境搭建及Hello World合约</a></li><li><a href="https://learnblockchain.cn/2018/06/07/remix-ide/">搭建智能合约开发环境Remix IDE及使用</a></li><li><a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options">以太坊客户端Geth命令用法-参数详解</a></li><li><a href="https://learnblockchain.cn/2017/12/01/geth_cmd_short/">Geth控制台使用实战及Web3.js使用</a></li><li><a href="https://learnblockchain.cn/2018/03/18/create_private_blockchain/">如何搭建以太坊私有链</a></li></ul><h3 id="智能合约及应用开发"><a href="#智能合约及应用开发" class="headerlink" title="智能合约及应用开发"></a>智能合约及应用开发</h3><ul><li><a href="https://learnblockchain.cn/2018/01/12/first-dapp/">一步步教你开发、部署第一个Dapp应用</a></li><li><a href="https://learnblockchain.cn/2018/01/12/create_token/">一步步教你创建自己的数字货币（代币）进行ICO</a></li><li><a href="https://learnblockchain.cn/2018/01/27/create-token2/">实现一个可管理、增发、兑换、冻结等高级功能的代币</a></li><li><a href="https://learnblockchain.cn/2018/02/28/ico-crowdsale/">如何通过以太坊智能合约来进行众筹（ICO）</a></li><li><a href="https://learnblockchain.cn/2018/03/23/token-erc721/">剖析非同质化代币ERC721–全面解析ERC721标准</a></li><li><p><a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a></p></li><li><p><a href="https://learnblockchain.cn/2018/03/15/contract-upgrade/">如何编写一个可升级的智能合约</a></p></li><li><a href="https://learnblockchain.cn/2018/04/25/bec-overflow/">美链BEC合约漏洞技术分析</a></li></ul><h3 id="Solidity语言教程"><a href="#Solidity语言教程" class="headerlink" title="Solidity语言教程"></a>Solidity语言教程</h3><p>Solidity语言是开发智能合约最广泛的语言，本专栏应该是国内最深度介绍Solidity的文章了。</p><ul><li><a href="https://learnblockchain.cn/2017/12/05/solidity1/">Solidity 教程系列1 - 类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/12/solidity2/">Solidity 教程系列2 - 地址类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/12/solidity_func/">Solidity 教程系列3 - 函数类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/21/solidity_reftype_datalocation/">Solidity 教程系列4 - 数据存储位置分析</a></li><li><a href="https://learnblockchain.cn/2017/12/21/solidity-arrays/">Solidity 教程系列5 - 数组介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/27/solidity-structs/">Solidity 教程系列6 - 结构体与映射</a></li><li><a href="https://learnblockchain.cn/2018/02/02/solidity-unit/">Solidity 教程系列7 - 以太单位及时间单位</a></li><li><a href="https://learnblockchain.cn/2018/03/14/solidity-api/">Solidity 教程系列8 - Solidity API</a></li><li><a href="https://learnblockchain.cn/2018/04/07/solidity-errorhandler/">Solidity 教程系列9 - 错误处理</a></li><li><p><a href="https://learnblockchain.cn/2018/04/09/solidity-modify/">Solidity 教程系列10 - 完全理解函数修改器</a></p></li><li><p><a href="https://learnblockchain.cn/2018/05/04/solidity-style-guide/">智能合约最佳实践 之 Solidity 编码规范</a></p></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">《深入浅出区块链》</a>及微信技术交流群, 主要用来提供一个学习的问答及交流平台，问答交流内容不限于博客文章。<br>目前定价149，有需要加入的同学请加微信：xlbxiong</p><p>温馨提示：微信不提供免费技术解答服务，感谢理解。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><h3 id="以下为广告"><a href="#以下为广告" class="headerlink" title="以下为广告"></a>以下为广告</h3><p>我和朋友一起创建了登链科技，是一家从事区块链技术服务与咨询的公司。旨在帮助企业更好的拥抱区块链。<br>我们提供的服务包括（不限于）：</p><ol><li>为游戏公司提供基于区块链的道具、角色等；</li><li>为公司提供基于区块链的股权激励方案；</li><li>为数字产品版权登记、交易平台；</li><li>各种公开透明场景下的服务，如：网络彩票发行、投票、众筹等等；</li><li>区块链技术培训（企业内训）与技术咨询服务。</li></ol><p>所有的服务均可以提供完整的解决方案：如提供面向用户的官方网站、苹果及安卓APP、微信公众号、小程序和企业内部使用的管理后台。<br>业务咨询，请联系：xlb@niuwasoft.com</p><p>另外，我们正在寻找那些热爱技术、愿意迎接挑战的小伙伴（含实习生和正式员工）。<br>我们会提供市场化的薪资待遇和远高于普通公司的成长机会（入职员工由我亲自带领，并且经常有技术培训）。</p><p>如果你对我们感兴趣，欢迎提交简历（千万别忘改贴上你的github地址哦）至xlb@niuwasoft.com。目前所有职位均位于百岛之城珠海。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为博客文章索引，小白必看。有新文章时会更新本文，建议大家加入收藏夹中，如果你觉得本站不错，欢迎你转发给朋友。&lt;/p&gt;
    
    </summary>
    
      <category term="目录" scheme="https://learnblockchain.cn/categories/%E7%9B%AE%E5%BD%95/"/>
    
    
      <category term="如何学习" scheme="https://learnblockchain.cn/tags/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目录" scheme="https://learnblockchain.cn/tags/%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列6 - 结构体与映射</title>
    <link href="https://learnblockchain.cn/2017/12/27/solidity-structs/"/>
    <id>https://learnblockchain.cn/2017/12/27/solidity-structs/</id>
    <published>2017-12-27T03:55:26.000Z</published>
    <updated>2018-03-18T13:55:32.194Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第6篇 - Solidity 结构体与映射。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本系列文章一部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，另一部分是Solidity深入分析，这部分请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读。</p><h2 id="结构体-Structs"><a href="#结构体-Structs" class="headerlink" title="结构体(Structs)"></a>结构体(Structs)</h2><p>Solidity提供<strong>struct</strong>来定义自定义类型，自定义的类型是引用类型。<br>我们看看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    <span class="comment">// 定义一个包含两个成员的新类型</span></span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newCampaign</span>(<span class="params">address beneficiary, uint goal</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint campaignID</span>) </span>&#123;</span><br><span class="line">        campaignID = numCampaigns++; <span class="comment">// campaignID 作为一个变量返回</span></span><br><span class="line">        <span class="comment">// 创建一个结构体实例，存储在storage ，放入mapping里</span></span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">contribute</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="comment">// 用mapping对应项创建一个结构体引用</span></span><br><span class="line">        <span class="comment">// 也可以用 Funder(msg.sender, msg.value) 来初始化.</span></span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;<span class="attr">addr</span>: msg.sender, <span class="attr">amount</span>: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkGoalReached</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool reached</span>) </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="keyword">if</span> (c.amount &lt; c.fundingGoal)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = <span class="number">0</span>;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是一个简化版的众筹合约，但它可以让我们理解<strong>structs</strong>的基础概念，<strong>struct</strong>可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。</p><p>不能声明一个struct同时将自身struct作为成员，这个限制是基于结构体的大小必须是有限的。<br>但<strong>struct</strong>可以作为<strong>mapping</strong>的值类型成员。</p><p>注意在函数中，将一个<strong>struct</strong>赋值给一个局部变量（默认是storage类型），实际是拷贝的引用，所以修改局部变量值的同时，会影响到原变量。</p><p>当然，也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如campaigns[campaignID].amount = 0</p><h2 id="映射-Mappings"><a href="#映射-Mappings" class="headerlink" title="映射(Mappings)"></a>映射(Mappings)</h2><p>映射类型，一种键值对的映射关系存储结构。定义方式为mapping(_KeyType =&gt; _KeyValue)。键类型允许除映射、变长数组、合约、枚举、结构体外的几乎所有类型（）。值类型没有任何限制，可以为任何类型包括映射类型。</p><p><strong>映射</strong>可以被视作为一个哈希表，所有可能的键会被虚拟化的创建，映射到一个类型的默认值（二进制的全零表示）。在映射表中，并不存储键的数据，仅仅存储它的keccak256哈希值，这个哈希值在查找值时需要用到。<br>正因为此，<strong>映射</strong>是没有长度的，也没有键集合或值集合的概念。</p><p><strong>映射类型</strong>，仅能用来作为状态变量，或在内部函数中作为<strong>storage</strong>类型的引用。</p><p>可以通过将映射标记为public，来让Solidity创建一个访问器。通过提供一个键值做为参数来访问它，将返回对应的值。<br>映射的值类型也可以是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。<br>来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>映射并未提供迭代输出的方法，可以自行实现一个这样的数据结构。参考<a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol" target="_blank" rel="noopener">iterable mapping</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#mappings" target="_blank" rel="noopener">Solidity官方文档</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第6篇 - Solidity 结构体与映射。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
</feed>
