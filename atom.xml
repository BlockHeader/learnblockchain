<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深入浅出区块链</title>
  
  <subtitle>系统学习区块链技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://learnblockchain.cn/"/>
  <updated>2018-10-26T10:17:23.747Z</updated>
  <id>https://learnblockchain.cn/</id>
  
  <author>
    <name>Tiny熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>以太坊钱包开发系列4 - 发送Token(代币）</title>
    <link href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/"/>
    <id>https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/</id>
    <published>2018-10-26T09:34:44.000Z</published>
    <updated>2018-10-26T10:17:23.747Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊去中心化网页钱包开发系列，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/">创建钱包账号</a>、<a href="https://learnblockchain.cn/2018/10/25/2018/10/25/eth-web-wallet_2/">账号Keystore文件导入导出</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/">展示钱包信息及发起签名交易</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/">发送Token(代币）</a>，本文是第四篇，Token（代币、通证）是以太坊的一大特色，既然开发钱包，则发送Token 功能必不可少。</p><a id="more"></a><h2 id="合约-ABI-信息"><a href="#合约-ABI-信息" class="headerlink" title="合约 ABI 信息"></a>合约 ABI 信息</h2><p>首先我们需要明白，进行Token转账的时候，其实是在调用合约的转账函数，而要调用一个合约的函数，需要知道合约的 ABI 信息。</p><p>其次 通常我们所说的Token， 其实指的是符合 ERC20 标准接口的合约， <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" target="_blank" rel="noopener">ERC20</a> 接口定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = <span class="string">"Token Name"</span>;</span><br><span class="line">    string public constant symbol = <span class="string">"SYM"</span>;</span><br><span class="line">    uint8 public constant decimals = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">balanceOf</span>(<span class="params">address tokenOwner</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint balance</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">allowance</span>(<span class="params">address tokenOwner, address spender</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint remaining</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address spender, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transfer</span>(<span class="params">address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address from, address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Transfer</span>(<span class="params">address indexed from, address indexed to, uint tokens</span>);</span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Approval</span>(<span class="params">address indexed tokenOwner, address indexed spender, uint tokens</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>ABI 全称是 Application Binary Interface，它就是合约接口的描述，因此有了合约的接口定义，就可以很容易通过编译拿到ABI 信息，比如像下图在Remix 的编译选项卡就可以直接复制ABI。</p><p><img src="/media/15403775499051.jpg" alt=""></p><p>生成的 ABI 描述大概长这样： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"totalSupply"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"tokenOwner"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"address"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"balanceOf"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"balance"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>它是一个JSON形式的数组，数组里每一个元素，都是对函数接口的描述，在外部调用合约的时候就需要遵从这个接口，以上面的接口为例，通常一个接口描述包含下述几个字段：</p><ul><li>name: 函数会事件的名称</li><li>type: 可取值有function，constructor，fallback，event</li><li>inputs: 函数的输入参数，每个参数对象包含下述属性：<ul><li>name: 参数名称</li><li>type: 参数的规范型(Canonical Type)。</li></ul></li><li>outputs:  一系列的类似inputs的对象，如果无返回值时，可以省略。</li><li>constant: true表示函数声明自己不会改变状态变量的值。</li><li>payable: true表示函数可以接收ether，否则表示不能。</li></ul><p>接下来在构造合约对象就需要是使用ABI。</p><h2 id="构造合约对象"><a href="#构造合约对象" class="headerlink" title="构造合约对象"></a>构造合约对象</h2><p>ethers.js 构造合约对象很简单，仅需要提供三个参数给ethers.Contract构造函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abi = [...];</span><br><span class="line"><span class="keyword">var</span> addr = <span class="string">"0x..."</span>; </span><br><span class="line"><span class="keyword">var</span> contract = <span class="keyword">new</span> ethers.Contract(address, abi, provider);</span><br></pre></td></tr></table></figure><p>合约的地址在合约部署之后，可以获得，关于Token合约部署及ERC20相关的概念，这里不展开讲，不熟悉的同学，可以参考我另一篇文章<a href="https://learnblockchain.cn/2018/01/12/create_token/">创建自己的数字货币</a>。</p><p>只有就可以是使用 <code>contract</code> 对象来调用Token合约的函数。</p><h2 id="获取Token余额及转移Token"><a href="#获取Token余额及转移Token" class="headerlink" title="获取Token余额及转移Token"></a>获取Token余额及转移Token</h2><h3 id="获取Token余额"><a href="#获取Token余额" class="headerlink" title="获取Token余额"></a>获取Token余额</h3><p>结合UI来实现以下获取Token余额，UI如下： </p><p> <img src="/media/15405195250777.jpg" alt=""></p><p>在HTML里，定义的标签如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span>TT Token:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">readonly</span>=<span class="string">"readonly"</span> <span class="attr">class</span>=<span class="string">"readonly"</span> <span class="attr">id</span>=<span class="string">"wallet-token-balance"</span> <span class="attr">value</span>=<span class="string">"0.0"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的逻辑代码也很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> tokenBalance = $(<span class="string">'#wallet-token-balance'</span>);</span><br><span class="line"> <span class="comment">// 直接调用合约方法</span></span><br><span class="line">contract.balanceOf(activeWallet.address).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>)</span>&#123;</span><br><span class="line">    tokenBalance.val(balance);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="转移Token"><a href="#转移Token" class="headerlink" title="转移Token"></a>转移Token</h3><p>转移Token的UI效果如下：</p><p> <img src="/media/15405195493994.jpg" alt=""></p><p>界面的HTML代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>转移代币:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>发送至:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(target address)"</span> <span class="attr">id</span>=<span class="string">"wallet-token-send-target-address"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>金额:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(amount)"</span> <span class="attr">id</span>=<span class="string">"wallet-token-send-amount"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wallet-token-submit-send"</span> <span class="attr">class</span>=<span class="string">"submit disable"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面定义了两个文本输入框及一个“发送“按钮，在逻辑处理部分，转移Token代币尽管和获取余额类似，同样是调用合约的方法，不过转移代币需要发起一个交易，因此需要测量gas 消耗。<br>点击发送时运行一下（关键）代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputTargetAddress = $(<span class="string">'#wallet-token-send-target-address'</span>);</span><br><span class="line"><span class="keyword">var</span> inputAmount = $(<span class="string">'#wallet-token-send-amount'</span>);</span><br><span class="line"><span class="keyword">var</span> submit = $(<span class="string">'#wallet-token-submit-send'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> targetAddress = ethers.utils.getAddress(inputTargetAddress.val());</span><br><span class="line"><span class="keyword">var</span> amount = inputAmount.val();</span><br><span class="line"></span><br><span class="line">submit.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 先计算transfer 需要的gas 消耗量，这一步有默认值，非必须。</span></span><br><span class="line">    contract.estimate.transfer(targetAddress, amount)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">gas</span>) </span>&#123;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 必须关联一个有过签名钱包对象</span></span><br><span class="line">          <span class="keyword">let</span> contractWithSigner = contract.connect(activeWallet); </span><br><span class="line">          </span><br><span class="line">          <span class="comment">//  发起交易，前面2个参数是函数的参数，第3个是交易参数</span></span><br><span class="line">          contractWithSigner.transfer(targetAddress, amount, &#123;</span><br><span class="line">              gasLimit: gas,</span><br><span class="line">              <span class="comment">// 偷懒，直接是用 2gwei</span></span><br><span class="line">              gasPrice: ethers.utils.parseUnits(<span class="string">"2"</span>, <span class="string">"gwei"</span>),</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(tx);</span><br><span class="line">                <span class="comment">// 介绍刷新上面的Token余额，重置输入框</span></span><br><span class="line">            &#125;);  </span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述有一个地方都要注意一下，在合约调用 transfer 之前， 需要连接一个<strong>signer</strong>，因为发起交易的时候需要用它来进行签名，在ethers.js API里 Wallet 是 signer（抽象类）的实现类。</p><blockquote><p>所有会更改区块链数据的函数都需要关联签名器，如果是视图函数则只需要连接provider。</p></blockquote><p>ethers.js 的 Contract 提供了一个非常方便方法：<code>contract.estimate.functionName</code> 来计算预测交易的gasLimit。</p><p>在发起交易的时候，可以提供一个可选的<a href="https://docs.ethers.io/ethers.js/html/api-contract.html?highlight=estimate#overrides" target="_blank" rel="noopener">Overrides</a>参数，在这个参数里可以指定如交易的 gasLimit 、 gasPrice，如果我们不指定这个参数时，会默认使用 contract.estimate 获得的值作为 gasLimit，以及 provider.getGasPrice() 的值来指定 gasPrice。</p><p>哈哈，恭喜大家，到这里这里就完整的实现了一个基于以太坊去中心化网页钱包。</p><p>这是一条硬广，欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">深入浅出区块链技术小专栏</a>，目前仅需69元， 订阅就可以查看完整源码，还有其他惊喜哦~。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://docs.ethers.io/ethers.js/html" target="_blank" rel="noopener">Ethers.js</a></li></ol><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><p><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链知识星球</a>最专业技术问答社区，加入社区还可以在微信群里和300多位区块链技术爱好者一起交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以太坊去中心化网页钱包开发系列，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/&quot;&gt;创建钱包账号&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/2018/10/25/eth-web-wallet_2/&quot;&gt;账号Keystore文件导入导出&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/&quot;&gt;展示钱包信息及发起签名交易&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/&quot;&gt;发送Token(代币）&lt;/a&gt;，本文是第四篇，Token（代币、通证）是以太坊的一大特色，既然开发钱包，则发送Token 功能必不可少。&lt;/p&gt;
    
    </summary>
    
      <category term="钱包" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/ethereum/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包开发系列3 - 展示钱包信息及发起签名交易</title>
    <link href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/"/>
    <id>https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/</id>
    <published>2018-10-26T02:31:44.000Z</published>
    <updated>2018-10-26T10:18:09.029Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊去中心化网页钱包开发系列，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/">创建钱包账号</a>、<a href="https://learnblockchain.cn/2018/10/25/2018/10/25/eth-web-wallet_2/">账号Keystore文件导入导出</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/">展示钱包信息及发起签名交易</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/">发送Token(代币）</a>，这是第三篇介绍使用ethers.js的钱包对象获取相关信息及发起你离线交易。</p><a id="more"></a><h2 id="使用-Provider-连接以太坊网络"><a href="#使用-Provider-连接以太坊网络" class="headerlink" title="使用 Provider 连接以太坊网络"></a>使用 Provider 连接以太坊网络</h2><p>我们前面两篇文章介绍创建（或导入）钱包账号的过程都是是离线的，即不需要依赖以太坊网络即可创建钱包账号，但如果想获取钱包账号的相关信息，比如余额、交易记录，发起交易的话，就需要让钱包连上以太坊的网络。</p><p>不管是在 Web3 中，还是Ethers.js 都是使用 Provider 来进行网络连接的，Ethers.js 提供了集成多种 Provider 的方式：</p><ul><li><p>Web3Provider: 使用一个已有的web3 兼容的Provider，如有MetaMask 或 Mist提供。</p></li><li><p>EtherscanProvider 及 InfuraProvider:  如果没有自己的节点，可以使用Etherscan 及 Infura 的Provider，他们都是以太坊的基础设施服务提供商，Ethers.js 还提供了一种更简单的方式：使用一个默认的provider, 他会自动帮我们连接Etherscan 及 Infura。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let defaultProvider = ethers.getDefaultProvider(&apos;ropsten&apos;);</span><br></pre></td></tr></table></figure><p>  连接Provider, 通常有一个参数network网络名称，取值有： <code>homestead</code>, <code>rinkeby</code>, <code>ropsten</code>,  <code>kovan</code>, 关于Provider的更多用法，可以参考<a href="https://docs.ethers.io/ethers.js/html/api-providers.html" target="_blank" rel="noopener">Ethers.js Provider</a>。</p></li><li><p>JsonRpcProvider 及 IpcProvider:  如果有自己的节点可以使用，可以连接主网，测试网络，私有网络或Ganache，这也是本系列文章使用的方式。</p></li></ul><p>使用钱包连接Provider的方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接本地的geth 节点，8545是geth 的端口</span></span><br><span class="line"><span class="keyword">var</span> provider = <span class="keyword">new</span> ethers.providers.JsonRpcProvider(<span class="string">"http://127.0.0.1:8545"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wallet 为前两篇文章中生成的钱包对象, activeWallet就是后面可以用来请求余额发送交易的对象</span></span><br><span class="line"><span class="keyword">var</span> activeWallet = wallet.connect(App.provider);</span><br></pre></td></tr></table></figure><blockquote><p>启动geth的需要注意一下，需要使用 <code>--rpc --rpccorsdomain</code> 开启 RPC通信及跨域，</p></blockquote><h2 id="展示钱包详情：查询余额及Nonce"><a href="#展示钱包详情：查询余额及Nonce" class="headerlink" title="展示钱包详情：查询余额及Nonce"></a>展示钱包详情：查询余额及Nonce</h2><p>连接到以太坊网络之后，就可以向网络请求余额以及获取账号交易数量，使用一下API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeWallet.getBalance().then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">activeWallet.getTransactionCount().then(<span class="function"><span class="keyword">function</span>(<span class="params">transactionCount</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>activeWallet就是后面可以用来请求发送交易的对象</p><p><img src="/media/15402868832290.jpg" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;钱包详情:<span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>地址:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> readonly=<span class="string">"readonly"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"readonly"</span> id=<span class="string">"wallet-address"</span> value=<span class="string">""</span> /&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>tr&gt;</span><br><span class="line">    &lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>余额:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> readonly=<span class="string">"readonly"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"readonly"</span> id=<span class="string">"wallet-balance"</span> value=<span class="string">"0.0"</span> /&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>tr&gt;</span><br><span class="line">    &lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Nonce:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> readonly=<span class="string">"readonly"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"readonly"</span> id=<span class="string">"wallet-transaction-count"</span> value=<span class="string">"0"</span> /&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>tr&gt;</span><br><span class="line">    &lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;div id=<span class="string">"wallet-submit-refresh"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"submit"</span>&gt;刷新&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>td&gt;</span><br><span class="line">    &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>table&gt;</span><br></pre></td></tr></table></figure><p>js处理的逻辑就是获取信息之后，填充相应的控件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputBalance = $(<span class="string">'#wallet-balance'</span>);</span><br><span class="line"><span class="keyword">var</span> inputTransactionCount = $(<span class="string">'#wallet-transaction-count'</span>);</span><br><span class="line">    </span><br><span class="line">$(<span class="string">"#wallet-submit-refresh"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取余额时， 包含当前正在打包的区块</span></span><br><span class="line">   activeWallet.getBalance(<span class="string">'pending'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 单位转换 wei -&gt; ether </span></span><br><span class="line">          inputBalance.val(ethers.utils.formatEther(balance, &#123; <span class="attr">commify</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   activeWallet.getTransactionCount(<span class="string">'pending'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">transactionCount</span>) </span>&#123;</span><br><span class="line">          inputTransactionCount.val(transactionCount);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      &#125;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一次点击获取数据</span></span><br><span class="line">$(<span class="string">"#wallet-submit-refresh"</span>).click();</span><br></pre></td></tr></table></figure><h2 id="发送签名交易"><a href="#发送签名交易" class="headerlink" title="发送签名交易"></a>发送签名交易</h2><p>之前我们有一篇文章：<a href="https://learnblockchain.cn//2018/09/12/web3-sendeth/">如何使用Web3.js API 在页面中进行转账</a>介绍过发起交易，不过当时的签名是利用MetaMask来完成的，现在我们要完成一个钱包，必须要发送一个签名交易，签名交易也称为离线交易（因为这个过程可以离线进行：在离线状态下对交易进行签名，然后把签名后的交易进行广播）。</p><p>尽管 Ethers.js 提供了非常简洁的API来发送签名交易，但是探究下简洁API背后的细节依然会对我们有帮助，这个过程大致可分为三步:</p><ol><li>构造交易</li><li>交易签名</li><li>发送（广播）交易</li></ol><h3 id="构造交易"><a href="#构造交易" class="headerlink" title="构造交易"></a>构造交易</h3><p>先来看看一个交易长什么样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> txParams = &#123;</span><br><span class="line">  nonce: <span class="string">'0x00'</span>,</span><br><span class="line">  gasPrice: <span class="string">'0x09184e72a000'</span>, </span><br><span class="line">  gasLimit: <span class="string">'0x2710'</span>,</span><br><span class="line">  to: <span class="string">'0x0000000000000000000000000000000000000000'</span>, </span><br><span class="line">  value: <span class="string">'0x00'</span>, </span><br><span class="line">  data: <span class="string">'0x7f7465737432000000000000000000000000000000000000000000000000000000600057'</span>,</span><br><span class="line">  <span class="comment">// EIP 155 chainId - mainnet: 1, ropsten: 3</span></span><br><span class="line">  chainId: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起交易的时候，就是需要填充每一个字段，构建这样一个交易结构。<br><code>to</code> 和 <code>value</code>: 很好理解，就是用户要转账的目标及金额。<br><code>data</code>: 是交易时附加的消息，如果是对合约地址发起交易，这会转化为对合约函数的执行，可参考：<a href="https://learnblockchain.cn/2018/08/09/understand-abi/">如何理解以太坊ABI</a><br><code>nonce</code>: 交易序列号<br><code>chainId</code>:  链id，用来去区分不同的链（分叉链）id可在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#specification" target="_blank" rel="noopener">EIP-55</a>查询。</p><blockquote><p><code>nonce</code> 和 <code>chainId</code> 有一个重要的作用就是防止重放攻击，如果没有nonce的活，收款人可能把这笔签名过的交易再次进行广播，没有chainId的话，以太坊上的交易可以拿到以太经典上再次进行广播。</p></blockquote><p><code>gasPrice</code>和<code>gasLimit</code>： Gas是以太坊的工作计费机制，是由交易发起者给矿工打包的费用。上面几个参数的设置比较固定，Gas的设置（尤其是gasPrice）则灵活的多。</p><p><code>gasLimit</code> 表示预计的指令和存储空间的工作量，如果工作量没有用完，会退回交易发起者，如果不够会发生<em>out-of-gas</em> 错误。<br><strong>一个普通转账的交易，工作量是固定的，gasLimit为21000</strong>，合约执行gasLimit则是变化的，也许有一些人会认为直接设置为高一点，反正会退回，但如果合约执行出错，就会吃掉所有的gas。幸运的是web3 和 ethers.js 都提供了测算Gas Limit的方法，下一遍<a href="https://learnblockchain.cn/2018/10/23/eth-web-wallet_4">发送代币</a></p><p><code>gasPrice</code>是交易发起者是愿意为工作量支付的<strong>单位</strong>费用，矿工在选择交易的时候，是按照gasPrice进行排序，先服务高出价者，因此如果出价过低会导致交易迟迟不能打包确认，出价过高对发起者又比较亏。</p><p>web3 和 ethers.js 提供一个方法 <strong>getGasPrice()</strong> 用来获取最近几个历史区块gas price的中位数，也有一些第三方提供预测gas price的接口，如：<a href="https://www.etherchain.org/tools/gasPriceOracle" target="_blank" rel="noopener">gasPriceOracle</a> 、 <a href="https://ethgasstation.info/json/ethgasAPI.json" target="_blank" rel="noopener">ethgasAPI</a>、 <a href="https://etherscan.io/gastracker" target="_blank" rel="noopener">etherscan gastracker</a>，这些服务通常还会参考当前交易池内交易数量及价格，可参考性更强，</p><p>常规的一个做法是利用这些接口给用户一个参考值，然后用户可以根据参考值进行微调。</p><h3 id="交易签名"><a href="#交易签名" class="headerlink" title="交易签名"></a>交易签名</h3><p>在构建交易之后，就是用私钥对其签名，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tx = <span class="keyword">new</span> EthereumTx(txParams)</span><br><span class="line">tx.sign(privateKey)</span><br><span class="line"><span class="keyword">const</span> serializedTx = tx.serialize()</span><br></pre></td></tr></table></figure><p>代码参考<a href="https://github.com/ethereumjs/ethereumjs-tx" target="_blank" rel="noopener">ethereumjs-tx</a></p><h3 id="发送（广播）交易"><a href="#发送（广播）交易" class="headerlink" title="发送（广播）交易"></a>发送（广播）交易</h3><p>然后就是发送（广播）交易，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendRawTransaction(serializedTx, <span class="function"><span class="keyword">function</span> (<span class="params">err, transactionHash</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(transactionHash);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这三步就完成了发送签名交易的过程，ethers.js 里提供了一个简洁的接口，来完成所有这三步操作(强调一下，签名已经在接口里帮我们完成了)，接口如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">activeWallet.sendTransaction(&#123;</span><br><span class="line">           to: targetAddress,</span><br><span class="line">           value: amountWei,</span><br><span class="line">           gasPrice: activeWallet.provider.getGasPrice(),</span><br><span class="line">           gasLimit: <span class="number">21000</span>,</span><br><span class="line">       &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>) </span>&#123;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h2 id="用ethers-js-实现发送交易"><a href="#用ethers-js-实现发送交易" class="headerlink" title="用ethers.js 实现发送交易"></a>用ethers.js 实现发送交易</h2><p>先来看看发送交易的UI界面：</p><p><img src="/media/15403685871339.jpg" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>以太转账:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>发送至:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(target address)"</span> <span class="attr">id</span>=<span class="string">"wallet-send-target-address"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>金额:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(amount)"</span> <span class="attr">id</span>=<span class="string">"wallet-send-amount"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wallet-submit-send"</span> <span class="attr">class</span>=<span class="string">"submit disable"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面主要定义了两个文本输入框及一个“发送“按钮，在点击发送时运行一下（关键）代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputTargetAddress = $(<span class="string">'#wallet-send-target-address'</span>);</span><br><span class="line"><span class="keyword">var</span> inputAmount = $(<span class="string">'#wallet-send-amount'</span>);</span><br><span class="line"><span class="keyword">var</span> submit = $(<span class="string">'#wallet-submit-send'</span>);</span><br><span class="line"></span><br><span class="line">submit.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 得到一个checksum 地址</span></span><br><span class="line">    <span class="keyword">var</span> targetAddress = ethers.utils.getAddress(inputTargetAddress.val());</span><br><span class="line"><span class="comment">// ether -&gt; wei</span></span><br><span class="line">    <span class="keyword">var</span> amountWei = ethers.utils.parseEther(inputAmount.val());</span><br><span class="line">    activeWallet.sendTransaction(&#123;</span><br><span class="line">        to: targetAddress,</span><br><span class="line">        value: amountWei,</span><br><span class="line">        <span class="comment">// gasPrice: activeWallet.provider.getGasPrice(),  (可用默认值)</span></span><br><span class="line">        <span class="comment">// gasLimit: 21000,</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(tx);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>哈哈哈~， 干活介绍到这里，现在夹带一点私货，有到了推广时间了，完整源码请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">深入浅出区块链技术小专栏</a>查看，赶紧订阅吧，走过路过，不容错过。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://github.com/ethereumjs/ethereumjs-tx" target="_blank" rel="noopener">ethereum-tx</a></li><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md" target="_blank" rel="noopener">EIP-55</a></li><li><a href="https://docs.ethers.io/ethers.js/html" target="_blank" rel="noopener">Ethers.js</a></li></ol><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><p><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链知识星球</a>最专业技术问答社区，加入社区还可以在微信群里和300多位区块链技术爱好者一起交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以太坊去中心化网页钱包开发系列，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/&quot;&gt;创建钱包账号&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/2018/10/25/eth-web-wallet_2/&quot;&gt;账号Keystore文件导入导出&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/&quot;&gt;展示钱包信息及发起签名交易&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/&quot;&gt;发送Token(代币）&lt;/a&gt;，这是第三篇介绍使用ethers.js的钱包对象获取相关信息及发起你离线交易。&lt;/p&gt;
    
    </summary>
    
      <category term="钱包" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/ethereum/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包开发系列2 - 账号Keystore文件导入导出</title>
    <link href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_2/"/>
    <id>https://learnblockchain.cn/2018/10/25/eth-web-wallet_2/</id>
    <published>2018-10-25T12:34:44.000Z</published>
    <updated>2018-10-26T10:18:44.242Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊去中心化网页钱包开发系列，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/">创建钱包账号</a>、<a href="https://learnblockchain.cn/2018/10/25/2018/10/25/eth-web-wallet_2/">账号Keystore文件导入导出</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/">展示钱包信息及发起签名交易</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/">发送Token(代币）</a>，这是第二篇，主要介绍钱包账号导出与导入，将对Keystore文件的生成的原理进行介绍。</p><a id="more"></a><h2 id="如何导入Geth创建的账号？"><a href="#如何导入Geth创建的账号？" class="headerlink" title="如何导入Geth创建的账号？"></a>如何导入Geth创建的账号？</h2><p>在<a href="https://learnblockchain.cn/2018/10/20/eth-web-wallet_1/">上一篇文章</a>，介绍了如何使用私钥及助记词来创建账号，如果是使用已有的私钥及助记词，这其实也是账号导入的过程。</p><p>有一些同学会问，我的账号是Geth生成的，如何导入到钱包呢？使用Geth的同学，应该知道Geth在创建账号时会生成一个对应keystore JSON文件，Keystore文件存储加密后的私钥信息，因此我们需要做的就是导入这个Keystore文件，这个文件通常在同步区块数据的目录下的keystore文件夹（如： ~/.ethereum/keystore）里。</p><p>尽管在ethers.js 中，简单的使用一个函数就可以完成keystore文件的导入，不过理解Keystore 文件的作用及原理还是非常有必要的，当然如果你是在没有兴趣，可以直接跳到本文最后一节：使用ethers.js 实现账号导出导入。</p><h2 id="详细解读-Keystore-文件"><a href="#详细解读-Keystore-文件" class="headerlink" title="详细解读 Keystore 文件"></a>详细解读 Keystore 文件</h2><h3 id="为什么需要-Keystore-文件"><a href="#为什么需要-Keystore-文件" class="headerlink" title="为什么需要 Keystore 文件"></a>为什么需要 Keystore 文件</h3><p>通过这篇文章<a href="https://learnblockchain.cn/2018/09/28/hdwallet/">理解开发HD 钱包涉及的 BIP32、BIP44、BIP39</a>，私钥其实就代表了一个账号，最简单的保管账号的方式就是直接把私钥保存起来，如果私钥文件被人盗取，我们的数字资产讲洗劫一空。</p><p>Keystore 文件就是一种以加密的方式存储密钥的文件，这样的发起交易的时候，先从Keystore 文件是使用密码解密出私钥，然后进行签名交易。这样做之后就会安全的多，因为只有黑客同时盗取 keystore 文件和密码才能盗取我们的数字资产。</p><h3 id="Keystore-文件如何生成的"><a href="#Keystore-文件如何生成的" class="headerlink" title="Keystore 文件如何生成的"></a>Keystore 文件如何生成的</h3><p> 以太坊是使用对称加密算法来加密私钥生成Keystore文件，因此对称加密秘钥(注意它其实也是发起交易时需要的解密秘钥)的选择就非常关键，这个秘钥是使用KDF算法推导派生而出。因此在完整介绍Keystore 文件如何生成前，有必要先介绍一下KDF。</p><h4 id="使用-KDF-生成秘钥"><a href="#使用-KDF-生成秘钥" class="headerlink" title="使用 KDF 生成秘钥"></a>使用 KDF 生成秘钥</h4><p>密码学KDF（key derivation functions），其作用是通过一个密码派生出一个或多个秘钥，即从 password 生成加密用的 key。</p><p>其实在<a href="https://learnblockchain.cn/2018/09/28/hdwallet/">理解开发HD 钱包涉及的 BIP32、BIP44、BIP39</a>中介绍助记词推导出种子的PBKDF2算法就是一种KDF函数，其原理是加盐以及增加哈希迭代次数。</p><p>而在Keystore中，是用的是<a href="https://tools.ietf.org/html/rfc7914" target="_blank" rel="noopener">Scrypt算法</a>，用一个公式来表示的话，派生的Key生成方程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DK = Scrypt(salt, dk_len, n, r, p)</span><br></pre></td></tr></table></figure><p>其中的 salt 是一段随机的盐，dk_len 是输出的哈希值的长度。n 是 CPU/Memory 开销值，越高的开销值，计算就越困难。r 表示块大小，p 表示并行度。</p><blockquote><p> Litecoin 就使用 scrypt 作为它的 POW 算法</p></blockquote><p>实际使用中，还会加上一个密码进行计算，用一张图来表示这个过程就是：</p><p><img src="media/15402189467872.png" alt=""></p><h4 id="对私钥进行对称加密"><a href="#对私钥进行对称加密" class="headerlink" title="对私钥进行对称加密"></a>对私钥进行对称加密</h4><p>上面已经用KDF算法生成了一个秘钥，这个秘钥就是接着进行对称加密的秘钥，这里使用的对称加密算法是  aes-128-ctr，aes-128-ctr 加密算法还需要用到一个参数初始化向量 iv。</p><h3 id="Keystore文件"><a href="#Keystore文件" class="headerlink" title="Keystore文件"></a>Keystore文件</h3><p>好了，我们现在结合具体 Keystore文件的内容，就很容易理解了Keystore 文件怎么产生的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="string">"address"</span>:<span class="string">"856e604698f79cef417aab..."</span>,</span><br><span class="line">   <span class="string">"crypto"</span>:&#123;  </span><br><span class="line">      <span class="string">"cipher"</span>:<span class="string">"aes-128-ctr"</span>,</span><br><span class="line">      <span class="string">"ciphertext"</span>:<span class="string">"13a3ad2135bef1ff228e399dfc8d7757eb4bb1a81d1b31...."</span>,</span><br><span class="line">      <span class="string">"cipherparams"</span>:&#123;  </span><br><span class="line">         <span class="string">"iv"</span>:<span class="string">"92e7468e8625653f85322fb3c..."</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"kdf"</span>:<span class="string">"scrypt"</span>,</span><br><span class="line">      <span class="string">"kdfparams"</span>:&#123;  </span><br><span class="line">         <span class="string">"dklen"</span>:<span class="number">32</span>,</span><br><span class="line">         <span class="string">"n"</span>:<span class="number">262144</span>,</span><br><span class="line">         <span class="string">"p"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="string">"r"</span>:<span class="number">8</span>,</span><br><span class="line">         <span class="string">"salt"</span>:<span class="string">"3ca198ce53513ce01bd651aee54b16b6a...."</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"mac"</span>:<span class="string">"10423d837830594c18a91097d09b7f2316..."</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"id"</span>:<span class="string">"5346bac5-0a6f-4ac6-baba-e2f3ad464f3f"</span>,</span><br><span class="line">   <span class="string">"version"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来解读一下各个字段：</p><ul><li>address: 账号地址</li><li>version: Keystore文件的版本，目前为第3版，也称为V3 KeyStore。</li><li>id : uuid </li><li>crypto: 加密推倒的相关配置.<ul><li>cipher 是用于加密以太坊私钥的对称加密算法。用的是 aes-128-ctr 。</li><li>cipherparams 是 aes-128-ctr 加密算法需要的参数。在这里，用到的唯一的参数 iv。</li><li>ciphertext 是加密算法输出的密文，也是将来解密时的需要的输入。</li><li>kdf: 指定使用哪一个算法，这里使用的是 scrypt。</li><li>kdfparams: scrypt函数需要的参数</li><li>mac: 用来校验密码的正确性， mac= sha3(DK[16:32], ciphertext) 下面一个小节单独分析。</li></ul></li></ul><p>我们来完整梳理一下 Keystore 文件的产生：</p><ol><li>使用scrypt函数 （根据密码 和 相应的参数） 生成秘钥</li><li>使用上一步生成的秘钥 + 账号私钥 + 参数 进行对称加密。</li><li>把相关的参数 和 输出的密文 保存为以上格式的 JSON 文件</li></ol><h3 id="如何确保密码是对的？"><a href="#如何确保密码是对的？" class="headerlink" title="如何确保密码是对的？"></a>如何确保密码是对的？</h3><p>当我们在使用Keystore文件来还原私钥时，依然是使用kdf生成一个秘钥，然后用秘钥对ciphertext进行解密，其过程如下： </p><p><img src="/media/15402194796574.png" alt=""></p><p>此时细心的同学会发现，无论使用说明密码，来进行这个操作，都会生成一个私钥，但是最终计算的以太坊私钥到底是不是正确的，却不得而知。</p><p>这就是 keystore 文件中 mac 值的作用。mac 值是 kdf输出 和 ciphertext 密文进行SHA3-256运算的结果，显然密码不同，计算的mac 值也不同，因此可以用来检验密码的正确性。检验过程用图表示如下：</p><p><img src="/media/15402227441945.png" alt=""></p><p>现在我们以解密的角度完整的梳理下流程，就可以得到以下图：</p><p><img src="/media/15402229547319.png" alt=""></p><h2 id="用ethers-js-实现账号导出导入"><a href="#用ethers-js-实现账号导出导入" class="headerlink" title="用ethers.js 实现账号导出导入"></a>用ethers.js 实现账号导出导入</h2><p>ethers.js 直接提供了加载keystore JSON来创建钱包对象以及加密生成keystore文件的方法，方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入keystore Json</span></span><br><span class="line">    ethers.Wallet.fromEncryptedJson(json, password, [progressCallback]).then(<span class="function"><span class="keyword">function</span>(<span class="params">wallet</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// wallet </span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用钱包对象 导出keystore Json</span></span><br><span class="line">    wallet.encrypt(pwd, [progressCallback].then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 保存json</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>现在结合界面来完整的实现账号导出及导入，先看看导出，UI图如下：</p><p><img src="media/15402637447655.jpg" alt=""></p><p>HTML 代码如下： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>KeyStore 导出:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(password)"</span> <span class="attr">id</span>=<span class="string">"save-keystore-file-pwd"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"save-keystore"</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span>导出<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面主要定义了一个密码输入框和一个导出按钮，点击“导出”后，处理逻辑代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "导出" 按钮，执行exportKeystore函数</span></span><br><span class="line">  $(<span class="string">'#save-keystore'</span>).click(exportKeystore);</span><br><span class="line"></span><br><span class="line">  exportKeystore: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取密码</span></span><br><span class="line">    <span class="keyword">var</span> pwd = $(<span class="string">'#save-keystore-file-pwd'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wallet 是上一篇文章中生成的钱包对象</span></span><br><span class="line">    wallet.encrypt(pwd.val()).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([json], &#123;<span class="attr">type</span>: <span class="string">"text/plain;charset=utf-8"</span>&#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 使用了FileSaver.js 进行文件保存</span></span><br><span class="line">      saveAs(blob, <span class="string">"keystore.json"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/eligrey/FileSaver.js" target="_blank" rel="noopener">FileSaver.js</a> 是可以用来在页面保存文件的一个库。</p><p>再来看看导入keystore 文件, UI图如下：</p><p><img src="/media/15402647159310.jpg" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">h2</span>&gt;</span>加载账号Keystore文件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Keystore:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"select-wallet-drop"</span>&gt;</span>把Json文件拖动到这里<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"select-wallet-file"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"(password)"</span> <span class="attr">id</span>=<span class="string">"select-wallet-password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"select-submit-wallet"</span> <span class="attr">class</span>=<span class="string">"submit disable"</span>&gt;</span>解密<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面主要定义了一个文件输入框、一个密码输入框及一个“解密“按钮，因此处理逻辑包含两部分，一是读取文件，二是解析加载账号，关键代码如下：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 使用FileReader读取文件，</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  fileReader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> json = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从加载</span></span><br><span class="line">    ethers.Wallet.fromEncryptedJson(json, password).then(<span class="function"><span class="keyword">function</span>(<span class="params">wallet</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;， <span class="function"><span class="keyword">function</span>（<span class="title">error</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">fileReader.readAsText(inputFile.files[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p> 哈哈哈，有到了推广时间了，完整源码请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">深入浅出区块链技术小专栏</a>查看，赶紧订阅吧，走过路过，不容错过。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://medium.com/@julien.maffre/what-is-an-ethereum-keystore-file-86c8c5917b97" target="_blank" rel="noopener">what-is-an-ethereum-keystore-file</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><p><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链知识星球</a>最专业技术问答社区，加入社区还可以在微信群里和300多位区块链技术爱好者一起交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以太坊去中心化网页钱包开发系列，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/&quot;&gt;创建钱包账号&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/2018/10/25/eth-web-wallet_2/&quot;&gt;账号Keystore文件导入导出&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/&quot;&gt;展示钱包信息及发起签名交易&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/&quot;&gt;发送Token(代币）&lt;/a&gt;，这是第二篇，主要介绍钱包账号导出与导入，将对Keystore文件的生成的原理进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="钱包" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/ethereum/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包开发系列1 - 创建钱包账号</title>
    <link href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/"/>
    <id>https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/</id>
    <published>2018-10-25T10:34:44.000Z</published>
    <updated>2018-10-26T10:19:56.648Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊去中心化网页钱包开发系列，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/">创建钱包账号</a>、<a href="https://learnblockchain.cn/2018/10/25/2018/10/25/eth-web-wallet_2/">账号Keystore文件导入导出</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/">展示钱包信息及发起签名交易</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/">发送Token(代币）</a>，这是第一篇，主要介绍钱包将实现哪些功能及怎么创建钱包账号，本钱包是基于<a href="https://docs.ethers.io/ethers.js/html" target="_blank" rel="noopener">ethers.js</a> 进行开发。</p><a id="more"></a><h2 id="去中心化网页钱包"><a href="#去中心化网页钱包" class="headerlink" title="去中心化网页钱包"></a>去中心化网页钱包</h2><p>先明确一下定义，什么是去中心化钱包，账号秘钥的管理，交易的签名，都是在客户端完成， 即私钥相关的信息都是在用户手中，钱包的开发者接触不到私钥信息。</p><blockquote><p>对应的中心化钱包则是私钥由中心服务器托管，如交易所的钱包就是这种。</p></blockquote><p>网页钱包，或者叫web钱包，是指钱包以网页的形式展现，去中心化网页钱包则交易的签名等操作是在浏览器里完成。<br>其他形式的钱包，如Android钱包或iOS钱包其开发思路和web钱包一样，因此文本对开发其他平台的钱包也有参考意义，不过本系列文章主要侧重在钱包功能的实现，并未过多考虑用户体验。</p><h2 id="钱包功能"><a href="#钱包功能" class="headerlink" title="钱包功能"></a>钱包功能</h2><p>一个钱包通常主要包含的功能有：</p><ul><li>账号管理（主要是私钥的管理）：创建账号、账号导入导出</li><li>账号信息展示：如以太币余额、Token（代币）余额。</li><li>转账功能：发送以太币及发送Token（代币）</li></ul><p>这些功能将基于 ethers.js 进行开发，   ethers.js 和web3.js 一样，也是一套和以太坊区块链进行交互的库，不仅如此，ethers.js 还对BIP 39等相关的提案进行了实现，可以在这个<a href="https://docs.ethers.io/ethers.js/html/" target="_blank" rel="noopener">链接</a>阅读其文档。</p><p>这些功能主要表现为钱包的两个界面，一个界面是：账号管理，一个界面是进行账号信息展示及转账。下面逐个进行介绍</p><h2 id="创建钱包账号"><a href="#创建钱包账号" class="headerlink" title="创建钱包账号"></a>创建钱包账号</h2><p>读过上一篇文章<a href="https://learnblockchain.cn/2018/09/28/hdwallet/">理解开发HD 钱包涉及的 BIP32、BIP44、BIP39</a>的同学，会知道创建账号，可以有两种方式：</p><ul><li>直接生成32个字节的数当成私钥</li><li>通过助记词进行确定性推导出私钥</li></ul><h3 id="使用随机数作为私钥创建钱包账号"><a href="#使用随机数作为私钥创建钱包账号" class="headerlink" title="使用随机数作为私钥创建钱包账号"></a>使用随机数作为私钥创建钱包账号</h3><p>即方式一，可以使用ethers.utils.randomBytes生成一个随机数，然后使用这个随机数来创建钱包，如代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> privateKey = ethers.utils.randomBytes(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">var</span> wallet = <span class="keyword">new</span> ethers.Wallet(privateKey);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"账号地址: "</span> + wallet.address);</span><br></pre></td></tr></table></figure><p>上面代码的 wallet 是 ethers 中的一个钱包对象，它除了有代码中出现的.address 属性之外，还有如 获取余额、发送交易等方法，在后面的文章会进行介绍。</p><p>注意ethers.utils.randomBytes 生成的是一个字节数组，如果想用十六进制数显示出来表示，需要转化为BigNumber代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keyNumber = ethers.utils.bigNumberify(privateKey);</span><br><span class="line"><span class="built_in">console</span>.log(randomNumber._hex);</span><br></pre></td></tr></table></figure><p>现在我们结合界面，完整的实现创建账号，其效果图如下，加载私钥时创建账号。</p><p><img src="media/15401942330046.jpg" alt=""></p><p>界面代码（HTML）代码如下（主要是在表格中定义个一个输入框及一个按钮）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>私钥:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(private key)"</span> <span class="attr">id</span>=<span class="string">"select-privatekey"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"select-submit-privatekey"</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span>加载私钥<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的逻辑代码(JavaScript)如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用JQuery获取两个UI标签</span></span><br><span class="line">    <span class="keyword">var</span> inputPrivatekey = $(<span class="string">'#select-privatekey'</span>);</span><br><span class="line">    <span class="keyword">var</span> submit = $(<span class="string">'#select-submit-privatekey'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个默认的私钥</span></span><br><span class="line">    <span class="keyword">let</span> randomNumber = ethers.utils.bigNumberify(ethers.utils.randomBytes(<span class="number">32</span>));</span><br><span class="line">    inputPrivatekey.val(randomNumber._hex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击“加载私钥”时， 创建对应的钱包</span></span><br><span class="line">    submit.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> privateKey = inputPrivatekey.val();</span><br><span class="line">        <span class="keyword">if</span> (privateKey.substring(<span class="number">0</span>, <span class="number">2</span>) !== <span class="string">'0x'</span>) &#123; privateKey = <span class="string">'0x'</span> + privateKey; &#125;</span><br><span class="line">       <span class="keyword">var</span> wallet = <span class="keyword">new</span> ethers.Wallet(privateKey));</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>如果用户提供一个已有账号的私钥，则会导入其原有账号。</p><h3 id="通过助记词方式创建钱包账号"><a href="#通过助记词方式创建钱包账号" class="headerlink" title="通过助记词方式创建钱包账号"></a>通过助记词方式创建钱包账号</h3><p>这是目前主流常见钱包的方式，关于助记词推导过程请阅读<a href="https://learnblockchain.cn/2018/09/28/hdwallet/">理解开发HD 钱包涉及的 BIP32、BIP44、BIP39</a>。</p><p>我们需要先生成一个随机数，然后用随机数生成助记词，随后用助记词创建钱包账号，设计到的API有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> rand = ethers.utils.randomBytes(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成助记词</span></span><br><span class="line"><span class="keyword">var</span> mnemonic = ethers.utils.HDNode.entropyToMnemonic(rand);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="string">"m/44'/60'/0'/0/0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过助记词创建钱包</span></span><br><span class="line">ethers.Wallet.fromMnemonic(mnemonic, path);</span><br></pre></td></tr></table></figure><p>现在我们结合界面来实现一下通过助记词方式创建钱包账号，其效果图如下：</p><p><img src="/media/15401977091699.jpg" alt=""></p><p>界面代码（HTML）代码如下（主要是在表格中定义个两个输入框及一个按钮）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>助记词:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(mnemonic phrase)"</span> <span class="attr">id</span>=<span class="string">"select-mnemonic-phrase"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Path:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(path)"</span> <span class="attr">id</span>=<span class="string">"select-mnemonic-path"</span> <span class="attr">value</span>=<span class="string">"m/44'/60'/0'/0/0"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"select-submit-mnemonic"</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span>推倒<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的逻辑代码(JavaScript)如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> inputPhrase = $(<span class="string">'#select-mnemonic-phrase'</span>);</span><br><span class="line">    <span class="keyword">var</span> inputPath = $(<span class="string">'#select-mnemonic-path'</span>);</span><br><span class="line">    <span class="keyword">var</span> submit = $(<span class="string">'#select-submit-mnemonic'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成助记词</span></span><br><span class="line">    <span class="keyword">var</span> mnemonic = ethers.utils.HDNode.entropyToMnemonic(ethers.utils.randomBytes(<span class="number">16</span>));</span><br><span class="line">    inputPhrase.val(mnemonic);</span><br><span class="line"></span><br><span class="line">    submit.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查助记词是否有效。</span></span><br><span class="line">        <span class="keyword">if</span> (!ethers.utils.HDNode.isValidMnemonic(inputPhrase.val())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过助记词创建钱包对象</span></span><br><span class="line">       <span class="keyword">var</span> wallet = ethers.Wallet.fromMnemonic(inputPhrase.val(), inputPath.val());</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>同样用户可以提供一个其保存的助记词来导入其钱包，有一些遗憾的是，ethers.js 暂时不支持通过添加密码作为Salt来保护种子（也可能是我没有找到，如果知道的同学，希望反馈下），如果需要此功能可以引入bip39 和 ethereumjs-wallet 库来实现，代码可参考<a href="https://learnblockchain.cn/2018/09/28/hdwallet/">理解开发HD 钱包涉及的 BIP32、BIP44、BIP39</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实 ethers 还提供了一个更简单的方法来创建钱包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接创建一个随机钱包</span></span><br><span class="line">ethers.Wallet.createRandom();</span><br></pre></td></tr></table></figure><p>完整源码请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">深入浅出区块链技术小专栏</a>查看， 哈哈，是不是有一点鸡贼，创作不易呀。</p><p>参考文档:<br><a href="https://docs.ethers.io/ethers.js/html" target="_blank" rel="noopener">ethers.js</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><p><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链知识星球</a>最专业技术问答社区，加入社区还可以在微信群里和300多位区块链技术爱好者一起交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以太坊去中心化网页钱包开发系列，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/&quot;&gt;创建钱包账号&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/2018/10/25/eth-web-wallet_2/&quot;&gt;账号Keystore文件导入导出&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/&quot;&gt;展示钱包信息及发起签名交易&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/&quot;&gt;发送Token(代币）&lt;/a&gt;，这是第一篇，主要介绍钱包将实现哪些功能及怎么创建钱包账号，本钱包是基于&lt;a href=&quot;https://docs.ethers.io/ethers.js/html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ethers.js&lt;/a&gt; 进行开发。&lt;/p&gt;
    
    </summary>
    
      <category term="钱包" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/ethereum/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Plasma（二）Plasma 细节</title>
    <link href="https://learnblockchain.cn/2018/10/24/plasma-in-detail/"/>
    <id>https://learnblockchain.cn/2018/10/24/plasma-in-detail/</id>
    <published>2018-10-24T12:54:17.000Z</published>
    <updated>2018-10-26T09:50:08.561Z</updated>
    
    <content type="html"><![CDATA[<p> 这一系列文章将围绕以太坊的二层扩容框架，介绍其基本运行原理，具体操作细节，安全性讨论以及未来研究方向等。本篇文章主要对 Plasma 一些关键操作的细节进行剖析。</p><a id="more"></a><p>在<a href="https://learnblockchain.cn/2018/10/20/plasma-framework/">上一篇</a>文章中我们已经理解了什么是 Plasma 框架以及它是如何运行的，这一篇文章将对其运行过程中的一些关键部分，包括 Plasma 提交区块的过程，当有恶意行为发生时如何构建防伪证明以及如何退出 Plasma 子链等进行剖析。需要注意的是，由于 Plasma 是一套框架，因此本文只剖析 Plasma 项目的共性，每一部分的实现细则还是需要参考实际的项目，例如 Plasma MVP（Minimal-Viable-Plasma）和 Plasma Cash 等。</p><h2 id="存款（Deposit）"><a href="#存款（Deposit）" class="headerlink" title="存款（Deposit）"></a>存款（Deposit）</h2><p>Plasma 的主要思想就是将大部分计算过程都转移到链下进行，用户只有在进入和退出 Plasma Chain 的时候需要跟主链上的智能合约交互，这也是所有 Plasma 应用的标准流程。</p><p>用户在将主链的资产（如以太币或者其它 ERC20 合约发布的 token）转移到 Plasma Chain 的过程称为存款（Deposit），具体做法是直接向主链上的 Plasma 合约发送以太币或 token。Plasma 合约收到 Deposit 交易后会在子链上创建跟 Deposit 数额一致的交易，并将其打包进区块中，作为存款确认的证明。这个过程如下图所示（来源自<a href="https://plasma.io/" target="_blank" rel="noopener">[1]</a>）。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/Deposit.png" width="400" height="360" alt="Blockchains of Blockchain"></p><p>当用户看到子链上自己之前存款的交易被确认后，就可以在子链上使用这笔资产（给子链上的其他用户发送交易或者退出子链等）。</p><h2 id="状态确认（State-Commitment）"><a href="#状态确认（State-Commitment）" class="headerlink" title="状态确认（State Commitment）"></a>状态确认（State Commitment）</h2><p>当大部分都转移到链下进行时，需要某种机制确保链下状态的更新得到确认，这样才能保证当有恶意行为发生时，主链可以保证用户不会受到损失。这就是为什么需要状态确认（State Commitment），即子链周期性地将状态更新情况提交到主链进行共识。</p><p>然而，将子链中的所有交易都同步到主链显然违反了 Plasma 的初衷，在 Plasma 中，实际向主链提交的是 Merkle Tree 的根哈希。因此子链中的实际交易情况被隐藏，在主链上只能看到子链区块的哈希值。</p><p>当有恶意行为发生时，子链网络中的所有用户都可以向主链提交防伪证明，证明成立后，含有恶意交易的区块将被回滚。</p><h2 id="防伪证明（Fraud-Proof）"><a href="#防伪证明（Fraud-Proof）" class="headerlink" title="防伪证明（Fraud Proof）"></a>防伪证明（Fraud Proof）</h2><p>Plasma 的一个关键设计之一就是允许用户构造防伪证明（Fraud Proof）。防伪证明的意义在于只要发布区块的节点构造了含有恶意交易的区块，那么就要承担被惩罚的风险。每当新的区块被提交到主链上时，会留出一段时间给用户提交防伪证明，如果在这段时间内没有证明被提交，则认为新的区块被验证合法。如果有防伪证明检测到区块中存在恶意交易，则该区块将被舍弃，回滚到上一个被验证合法的区块。Plasma 中的防伪证明主要有以下（但不限于）几种：</p><ul><li>资产可花费证明</li><li>交易签名有效性证明</li><li>存取款证明</li></ul><p>至于每种防伪证明的具体形式，则依赖于实际 Plasma 应用的实现细则。</p><p>如下图所示（来源自<a href="https://plasma.io/" target="_blank" rel="noopener">[1]</a>），子链中每个节点都存有 1-4 个区块的数据。假设区块 1-3 已经被验证合法，而区块 4 中存在恶意交易，那么每个节点都可以使用 1-4 个区块中的数据构造防伪证明提交到主链，主链验证后将子链中的状态回滚到区块 1-3。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/fraud-proofs.png" width="700" height="200" alt="Blockchains of Blockchain"></p><p>防伪证明还可以使用零知识证明（zk-SNARKs 或者 STARKs）来构造，但由于目前通过零知识证明生成证明的时间和空间还有待优化，目前设计的 Plasma 并不依赖零知识证明。零知识证明在 Plasma 中的应用是一个很有前景的研究方向，感兴趣的读者可以参考以太坊研究团队关于这方面的研究<a href="https://ethresear.ch/t/plasma-is-plasma/2195" target="_blank" rel="noopener">[2]</a>)。</p><h2 id="取款（Withdrawal）"><a href="#取款（Withdrawal）" class="headerlink" title="取款（Withdrawal）"></a>取款（Withdrawal）</h2><p>取款（Withdrawal），顾名思义，就是从子链中的资产取回到主链上，因此取款也被称为退出（Exit）。取款操作可以说是 Plasma 框架中最重要的一步，因为它确保用户可以安全地将子链上的资产转移到主链上。之前的存款以及状态确认步骤已经产生了一些交易数据，并在主链上得到同步，用户可以利用这些数据构造资产证明，之后执行简单取款（Simple Withdrawal）操作退出子链。当有扣留（Withholding）攻击发生（即子链上的矿工恶意扣留区块，意图双花攻击等）时，用户可能无法成功获取数据构造资产证明，这时需要执行批量取款（Mass Withdrawal）操作退出子链。</p><p>需要注意的是，当子链中有取款操作发生时，跟这个取款操作相关的账号或者交易都将被禁止。</p><h3 id="简单取款（Simple-Withdrawal）"><a href="#简单取款（Simple-Withdrawal）" class="headerlink" title="简单取款（Simple Withdrawal）"></a>简单取款（Simple Withdrawal）</h3><p>执行简单取款的条件是所要取回的资产已经在主链和子链上确认。</p><p>一个简单取款的执行主要有以下几个步骤：</p><ul><li>向主链上的 Plasma 智能合约发送已签名的取款交易。取款的数额可以包含多个输出（UTXO模型），但所有输出必须在同一个子链当中，而且每个输出的余额必须全部取出，不能只取出一部分。取款数额的一部分还需要被当作押金，作为恶意行为的惩罚。</li><li>当取款请求发送后，需要等待一段“争议期（Challenge Period）”，这期间其它节点可以构造证据证明该取款中的部分或全部数额已经被花费。如果争议期内有节点提供证明成功，那么取款被取消，而且押金被扣除。</li><li>接下来可能还要等待一段时间，直到所有区块高度较低的取款操作都完成。这是为了保证所有取款操作按照“先来后到”的顺序执行。</li><li>当争议期结束后，如果没有争议被提出，则认为取款操作成立，取款者将子链资产成功取回到主链。</li></ul><h3 id="快速取款（Fast-Withdrawal）"><a href="#快速取款（Fast-Withdrawal）" class="headerlink" title="快速取款（Fast Withdrawal）"></a>快速取款（Fast Withdrawal）</h3><p>快速取款（Fast Withdrawal）跟简单取款相比的差别主要是引入一个中间人，白皮书上称为 Liquidity Provider，这里简称为 LP。如果一个用户不想等待很长的争议期（目前的实现至少要一周），那么它可以选择从 LP 这里直接取款，只需要消耗一个交易确认的时间，代价是需要支付给 LP 一定的费用。由于 Plasma 白皮书上关于快速取款的描述太过晦涩，这里主要参考 kfichter 提出的 Simple Fast Withdrawal<a href="https://ethresear.ch/t/simple-fast-withdrawals/2128" target="_blank" rel="noopener">[3]</a> 来介绍快速取款是如何实现的。</p><p>为了实现快速取款，取款方和 LP 可以利用一个流动合约（liquidity contract）。假设取款方是 Alice，她想要执行快速取款将 10 以太币从子链转移到主链。她首先向流动合约发送 10 以太币，注意这里的交易是在子链上进行的。当这个交易被子链打包成区块后，Alice 可以调用合约中的某个退出函数，这时 Alice 将获取一个代表她这笔资产的 token。Bob 作为 LP，他检查了子链上数据之后证明 Alice 的取款没有问题之后愿意以 9 以太币的价格购买这个 token。Alice 将 token 卖给 Bob，获得了 9 以太币，Bob 赚取了 1 以太币。</p><p>需要注意的是，实现快速取款的前提条件是没有拜占庭行为发生，即没有扣留区块攻击发生，因为 LP 需要验证取款方的交易历史。</p><h3 id="批量取款（Mass-Withdrawal）"><a href="#批量取款（Mass-Withdrawal）" class="headerlink" title="批量取款（Mass Withdrawal）"></a>批量取款（Mass Withdrawal）</h3><p>当子链中有拜占庭行为（例如，区块扣留攻击）发生时，将会影响以后生成防伪证明，因此网络中的每个用户都有责任快速退出子链。虽然批量取款（Mass Withdrawal）操作不是必要选择，但当大量用户执行取款时很可能会造成主链拥塞，也会消耗更多的 gas，因此批量取款是当子链受到攻击时更好的选择。</p><p>批量取款操作由于所采用的模型（UTXO 模型或者账户模型）不同会有较大的差别，而且目前关于批量取款的操作细节也正在研讨当中，因此这里只对批量取款做简单介绍，想要了解目前研究状态可以参考<a href="https://ethresear.ch/t/basic-mass-exits-for-plasma-mvp/3316" target="_blank" rel="noopener">[4]</a>。</p><p>当子链中有拜占庭行为发生时，用户之间可以共同协作执行批量取款。这时会有一个节点扮演取款处理人（Exit Processor）的角色，简称为 EP，负责当前某个批量操作（可以同时有多个批量取款操作发生，但同一个取款申请不能存在于多个批量取款），并且可以收取服务费作为报酬。EP 将构造一个位图（bitmap，即一串0/1）记录哪些资产要执行取款。之后 EP 将利用现有的区块数据检查每个取款是否合法，之后将构造一个批量退出初始化交易（Mass Exit Initiation Transaction，MEIT），并将其发送到主链上。在 MEIT 被主链确认之前，每个用户都可以对这个交易提出异议。当争议期结束，MEIT 被主链确认，批量取款成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对 Plasma 框架中一些关键操作进行了比较详细的介绍，但如果不依托于某个实际的 Plasma 项目，对一些细节还是很难理解。因此在后面的文章中将会介绍 Plasma MVP 以及 Plasma Cash。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ol><li><a href="https://plasma.io/" target="_blank" rel="noopener">https://plasma.io/</a></li><li><a href="https://ethresear.ch/t/plasma-is-plasma/2195" target="_blank" rel="noopener">https://ethresear.ch/t/plasma-is-plasma/2195</a></li><li><a href="https://ethresear.ch/t/simple-fast-withdrawals/2128" target="_blank" rel="noopener">https://ethresear.ch/t/simple-fast-withdrawals/2128</a></li><li><a href="https://ethresear.ch/t/basic-mass-exits-for-plasma-mvp/3316" target="_blank" rel="noopener">https://ethresear.ch/t/basic-mass-exits-for-plasma-mvp/3316</a></li></ol><p>本文的作者是盖盖，他的微信公众号: chainlab</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这一系列文章将围绕以太坊的二层扩容框架，介绍其基本运行原理，具体操作细节，安全性讨论以及未来研究方向等。本篇文章主要对 Plasma 一些关键操作的细节进行剖析。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Plasma" scheme="https://learnblockchain.cn/categories/ethereum/Plasma/"/>
    
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Plasma" scheme="https://learnblockchain.cn/tags/Plasma/"/>
    
      <category term="扩容" scheme="https://learnblockchain.cn/tags/%E6%89%A9%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Plasma（一）Plasma 框架</title>
    <link href="https://learnblockchain.cn/2018/10/20/plasma-framework/"/>
    <id>https://learnblockchain.cn/2018/10/20/plasma-framework/</id>
    <published>2018-10-20T07:54:17.000Z</published>
    <updated>2018-10-20T08:00:51.699Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列文章将围绕以太坊的二层扩容框架，介绍其基本运行原理，具体操作细节，安全性讨论以及未来研究方向等。本篇文章作为开篇，主要目的是理解 Plasma 框架。</p><a id="more"></a><p>Plasma 作为以太坊的二层扩容框架，自从 2017 年被 Joseph Poon（Lightning Network 创始人）和 Vitalik Buterin （Ethereum 创始人）提出以来<a href="http://plasma.io/plasma.pdf" target="_blank" rel="noopener">[1]</a>，一直是区块链从业人员关注的焦点<a href="https://ethresear.ch/c/plasma" target="_blank" rel="noopener">[2]</a>。首先需要明确的是，Plasma 实质上是一套框架，而不是一个单独的项目，它为各种不同的项目实际项目提供链下（off-chain）解决方案。这也是为什么很多人对 Plasma 感到疑惑的一个重要原因，因为在缺乏实际应用场景的情况下很难将 Plasma 解释清楚。<br>因此，理解 Plasma 是一套框架是理解 Plasma 的关键。</p><h2 id="从区块链扩容谈起"><a href="#从区块链扩容谈起" class="headerlink" title="从区块链扩容谈起"></a>从区块链扩容谈起</h2><p>在介绍 Plasma 之前，不得不先介绍区块链扩容。我们都知道，比特币（Bitcoin）和以太坊（Ethereum）作为目前最广泛使用的区块链平台，面临的最大问题就是可扩展性（Scalability）。这里需要注意的是，区块链中的可扩展性问题并不是单独特指某个问题，而是区块链想要实现 Web3.0<a href="https://medium.com/l4-media/making-sense-of-web-3-c1a9e74dcae" target="_blank" rel="noopener">[3]</a> 的愿景，为亿万用户提供去中心化服务所要克服的一系列挑战。虽然以太坊号称是“世界计算机”，但这台“计算机”却是单线程的，每秒钟只能处理大约 15 条交易，与目前主流的 Visa 和 MasterCard 动辄每秒上万的吞吐量相比实在相形见绌。因此如何在保证区块链安全性的情况下，提高可扩展性是目前区块链发展亟待解决的问题之一。</p><p>目前关于区块链扩容的解决方案无外乎两个方向：一层（Layer 1）扩容和二层（Layer 2）扩容<a href="https://blog.ethereum.org/2018/01/02/ethereum-scalability-research-development-subsidy-programs/" target="_blank" rel="noopener">[4]</a>。一层扩容也被称为链上（on-chain）扩容，顾名思义，这类扩容方案需要更改区块链底层协议。但同时也意味着需要将区块链硬分叉。这类扩容方案就像将原来的单核 CPU 改装成多核 CPU，从而可以多线程处理计算任务，提高整个网络的吞吐量。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/layer1.jpg" width="320" height="150" alt="Layer 1 扩容"></p><p>目前最典型的一层扩容方案是 Vitalik 和他的研究团队提出的“Sharding（分片）”，也就是说将区块链划分成不同的部分（shards），每个部分独立处理交易。想要了解更多关于 Sharding 的信息，可以参考以太坊官方的 Wiki<a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQs" target="_blank" rel="noopener">[5]</a>。</p><p>二层扩容也称链下（off-chain）扩容，同样非常好理解，这种扩容方案不需要修改区块链底层协议，而是通过将大量、频繁的计算工作转移到“链下”完成，并定期或在需要时将链下的计算结果提交到“链上”保证其最终性（finality）。二层扩容的核心思想是将底层区块链作为共识基础，使用智能合约或者其它手段作为链下和链上沟通的桥梁，当有欺诈行为发生时链下的用户仍然可以回到链上的某一状态。虽然将计算转移到链下会在一段时间内损失最终性，但这个代价是值得的，因为这样做不止可以极大提高区块链的灵活性和可扩展性，也极大降低了用户进行交易所需要的代价。将计算转移到链下也并不意味着完全放弃安全性，因为最终的安全性还是由底层所依赖的区块链来保证，因此二层扩容主要关注的问题就在于如何保证链上链下切换过程的安全性。这种思想最早被用在闪电网络（Lightning Network）当中作为比特币的其中一个扩容方案，并取得了很好的效果。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/layer2.jpg" width="320" height="150" alt="Layer 2 扩容"></p><p>本文所要介绍的 Plasma 就属于基于以太坊二层扩容方案，类似的解决方案还有 <a href="https://medium.com/l4-media/generalized-state-channels-on-ethereum-de0357f5fb44" target="_blank" rel="noopener">State Channels</a> 和 <a href="https://truebit.io/" target="_blank" rel="noopener">Trubit</a>。这些方案虽然面向的问题有所区别，但基本思想都是将复杂的计算转移到链下进行。那么，接下来我们将进入 Plasma 的世界，一窥究竟！</p><h2 id="理解-Plasma"><a href="#理解-Plasma" class="headerlink" title="理解 Plasma"></a>理解 Plasma</h2><p>在前文中我们已经明白 Plasma 是一种二层扩容框架，那么该如何进一步理解 Plasma 是什么？它区别于其它二层扩容方案的地方在哪呢？</p><p>Plasma 也被称为“链中链（blockchains in blockchains）”。任何人都可以在底层区块链之上创建不同的 Plasma 支持不同的业务需求，例如分布式交易所、社交网络、游戏等。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/Blockchains-of-blockchain.png" width="600" height="230" alt="Blockchains of Blockchain"></p><p>这里可以举一个例子来理解 Plasma。假如企鹅公司创建了一个 Plasma Chain 叫作 Game Chain。用户通过向 Game Chain 发送一些以太币换取 Token，用于购买皮肤等游戏内的增值商品。加入 Game Chain 的操作是在链上进行的，以太坊区块链将这部分资产锁定，转移到 Game Chain 上。之后每次我们购买虚拟商品的交易就会转移到链下进行，由企鹅公司记账。这种方式几乎跟我们现实生活中游戏内购的体验一样，不仅结算迅速，而且手续费低廉（相比于以太坊之上需要给矿工支付的手续费）。那么问题来了，如果企鹅公司从中作祟，修改账本，恶意占有我们的资产怎么办？这时我们就可以提交之前每次交易的凭证到以太坊区块链上，如果确实是企鹅恶意篡改了账本，那么我们不但能够成功取回自己的资产，还能获得之前企鹅公司创建 Game Chain 存入的部分或全部押金。</p><p>通过上面这个例子是不是已经明白 Plasma 大致是如何工作的了？但上面这个例子还是过于简单，只涉及用户自己和企鹅公司。下面我们使用区块链的语言对上面的例子进行解析。</p><p>首先，企鹅公司在以太坊主链之上创建了一系列智能合约作为主链和子链 Game Chain 通信的媒介。这些智能合约中不仅规定了子链中的一些基本的状态转换规则（例如如何惩罚作恶的节点），也记录了子链中的状态（子链中区块的哈希值）。之后企鹅公司可以搭建自己的子链（可以用以太坊搭建一套私链）。子链实际上是一个完全独立的区块链，可以拥有专门的矿工，使用不同于主链的共识算法，例如 PoS（Proof of Stake）等。</p><p>当子链创建完毕后，企鹅公司可以使用 ERC721 合约创建 token 作为游戏内的商品（就像 Cryptokitty）。但这里需要注意的是，所有数字资产必须在以太坊主链上创建，并通过 Plasma 子链的智能合约转移到子链中。用户也需要在主链上购买数字资产后转移到子链上。在上面这个例子中，Game Chain 的智能合约将主链上的资产锁定，之后在子链上生成等值的资产。之后用户就可以完全脱离主链，在子链上进行交易。企鹅公司在子链上扮演 operator 的角色，如果一切运行正常，子链中的矿工会正常打包区块，并在需要时由 operator 将区块的哈希值提交到主链作为子链的状态更新证明。在这个过程中，用户完全不需要和主链交互。</p><p>我们可以看到，将复杂的计算操作转移到链下确实使得整个交易过程变得简单。但没有强大的共识算法和庞大的参与者，资产在子链上是很不安全的。Plasma 给了我们一种避险机制，即使 operator 作恶，我们也能取回属于自己的资产。下图（来源自<a href="https://plasma.io/" target="_blank" rel="noopener">[1]</a>）简单说明了这个过程。图中，在第 4 个区块中的交易被篡改。由于 Alice 本地保存有 Plasma Chain 中所有的区块数据，因此她可以向主链提交一个含有“防伪证明（Fraud Proof）”的交易。如果证明生效，那么主链将状态从 4 号区块回滚到 3 号区块，一切恢复正常。Plasmas Chain 中的参与者也可以随时提交资产证明，返回到主链。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/Fraud-proof.png" width="700" height="350" alt="Blockchains of Blockchain"></p><p>到这里我们应该已经理解了，<strong>Plasma 所要做的工作并不是保护子链的安全，而是当有安全事故发生时，保证用户可以安全地取回自己的资产，并返回到主链上。并且采用一系列经济激励的方式减少作恶情况的发生</strong>。</p><p>下一篇文章将对 Plasma 运行过程的细节进行剖析。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ol><li><a href="https://plasma.io/" target="_blank" rel="noopener">https://plasma.io/</a></li><li><a href="https://ethresear.ch/c/plasma" target="_blank" rel="noopener">https://ethresear.ch/c/plasma</a></li><li><a href="https://medium.com/l4-media/making-sense-of-web-3-c1a9e74dcae" target="_blank" rel="noopener">https://medium.com/l4-media/making-sense-of-web-3-c1a9e74dcae</a></li><li><a href="https://blog.ethereum.org/2018/01/02/ethereum-scalability-research-development-subsidy-programs/" target="_blank" rel="noopener">https://blog.ethereum.org/2018/01/02/ethereum-scalability-research-development-subsidy-programs/</a></li><li><a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQs" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/Sharding-FAQs</a></li><li><a href="https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4" target="_blank" rel="noopener">https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4</a></li><li><a href="https://medium.com/@argongroup/ethereum-plasma-explained-608720d3c60e" target="_blank" rel="noopener">https://medium.com/@argongroup/ethereum-plasma-explained-608720d3c60e</a></li></ol><p>本文的作者是盖盖，他的微信公众号: chainlab</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列文章将围绕以太坊的二层扩容框架，介绍其基本运行原理，具体操作细节，安全性讨论以及未来研究方向等。本篇文章作为开篇，主要目的是理解 Plasma 框架。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Plasma" scheme="https://learnblockchain.cn/categories/ethereum/Plasma/"/>
    
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Plasma" scheme="https://learnblockchain.cn/tags/Plasma/"/>
    
      <category term="扩容" scheme="https://learnblockchain.cn/tags/%E6%89%A9%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>理解开发HD 钱包涉及的 BIP32、BIP44、BIP39</title>
    <link href="https://learnblockchain.cn/2018/09/28/hdwallet/"/>
    <id>https://learnblockchain.cn/2018/09/28/hdwallet/</id>
    <published>2018-09-28T08:17:41.000Z</published>
    <updated>2018-10-22T09:09:19.570Z</updated>
    
    <content type="html"><![CDATA[<p>如果你还在被HD钱包、BIP32、BIP44、BIP39搞的一头雾水，来看看这边文章吧。</p><a id="more"></a><h2 id="数字钱包概念"><a href="#数字钱包概念" class="headerlink" title="数字钱包概念"></a>数字钱包概念</h2><p>钱包用来存钱的，在区块链中，我们的数字资产都会对应到一个账户地址上， 只有拥有账户的钥匙（私钥）才可以对资产进行消费（用私钥对消费交易签名）。<br>私钥和地址的关系如下：<img src="/images/9efa20eff737374479d9c6bb86db82b3.png" alt=""><br>（图来自精通比特币）<br>一句话概括下就是：<strong>私钥通过椭圆曲线生成公钥， 公钥通过哈希函数生成地址，这两个过程都是单向的。</strong></p><p>因此实际上，数字钱包实际是一个管理私钥（生成、存储、签名）的工具，注意钱包并不保存资产，资产是在链上的。</p><h2 id="如何创建账号"><a href="#如何创建账号" class="headerlink" title="如何创建账号"></a>如何创建账号</h2><p>创建账号关键是生成一个私钥， 私钥是一个32个字节的数， <strong>生成一个私钥在本质上在1到2^256之间选一个数字</strong>。<br>因此生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源，只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。</p><p>比如可以掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为钱包的私钥。</p><p>从编程的角度来看，一般是通过在一个密码学安全的随机源(不建议大家自己去写一个随机数)中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。</p><blockquote><p>实际过程需要比较下是否小于n-1（n = 1.158 * 10^77, 略小于2^256），我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。这样得到的私钥就可以根据上面的方法进一步生成公钥及地址。</p></blockquote><h2 id="BIP32"><a href="#BIP32" class="headerlink" title="BIP32"></a>BIP32</h2><p>钱包也是一个私钥的容器，按照上面的方法，我们可以生成一堆私钥（一个人也有很多账号的需求，可以更好保护隐私），而每个私钥都需要备份就特别麻烦的。</p><blockquote><p>最早期的比特币钱包就是就是这样，还有一个昵称：“Just a Bunch Of Keys(一堆私钥)“</p></blockquote><p>为了解决这种麻烦，就有了<a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener">BIP32 提议</a>： 根据一个随机数种子通过分层确定性推导的方式得到n个私钥，这样保存的时候，只需要保存一个种子就可以，私钥可以推导出来，如图：</p><p><img src="/images/450b5358b96ef5b32ec775efed901f2a.png" alt=""><br>（图来自精通比特币）上图中的孙秘钥就可以用来签发交易。</p><blockquote><p>补充说明下 BIP: Bitcoin Improvement Proposals 比特币改进建议, bip32是第32个改进建议。<br>BIP32提案的名字是：Hierarchical Deterministic Wallets， 就是我们所说的HD钱包。</p></blockquote><p>来分析下这个分层推导的过程，第一步推导主秘钥的过程：<br><img src="/images/3ec7468aa49d907b0ec66b5d8b41a0a1.png" alt=""></p><p>根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造主私钥(m) 和 一个主链编码（ a master chain code)这一步生成的秘钥（由私钥或公钥）及主链编码再加上一个索引号，将作为HMAC-SHA512算法的输入继续衍生出下一层的私钥及链编码，如下图：<img src="/images/a9a6e6a31f39e812f579a4c8bdf09347.png" alt=""></p><blockquote><p>衍生推导的方案其实有两个：一个用父私钥推导（称为强化衍生方程），一个用父公钥推导。同时为了区分这两种不同的衍生，在索引号也进行了区分，索引号小于2^31用于常规衍生，而2^31到2^32-1之间用于强化衍生，为了方便表示索引号i’，表示2^31+i。</p></blockquote><p>因此增加索引（水平扩展）及 通过子秘钥向下一层（深度扩展）可以无限生成私钥。</p><p>注意， 这个推导过程是确定（相同的输入，总是有相同的输出）也是单向的，子密钥不能推导出同层级的兄弟密钥，也不能推出父密钥。如果没有子链码也不能推导出孙密钥。现在我们已经对分层推导有了认识。</p><p>一句话概括下BIP32就是：<strong>为了避免管理一堆私钥的麻烦提出的分层推导方案。</strong></p><h3 id="秘钥路径及BIP44"><a href="#秘钥路径及BIP44" class="headerlink" title="秘钥路径及BIP44"></a>秘钥路径及BIP44</h3><p>通过这种分层（树状结构）推导出来的秘钥，通常用路径来表示，每个级别之间用斜杠 / 来表示，由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m/0。第一个公共钥匙是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。</p><p>BIP44则是为这个路径约定了一个规范的含义(也扩展了对多币种的支持)，BIP0044指定了包含5个预定义树状层级的结构：<br><code>m / purpose&#39; / coin&#39; / account&#39; / change / address_index</code><br>m是固定的, Purpose也是固定的，值为44（或者 0x8000002C）<br><strong>Coin type</strong><br>这个代表的是币种，0代表比特币，1代表比特币测试链，60代表以太坊<br>完整的币种列表地址：<a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md" target="_blank" rel="noopener">https://github.com/satoshilabs/slips/blob/master/slip-0044.md</a><br><strong>Account</strong><br>代表这个币的账户索引，从0开始<br><strong>Change</strong><br>常量0用于外部链，常量1用于内部链（也称为更改地址）。外部链用于在钱包外可见的地址（例如，用于接收付款）。内部链用于在钱包外部不可见的地址，用于返回交易变更。 (所以一般使用0)<br><strong>address_index</strong><br>这就是地址索引，从0开始，代表生成第几个地址，官方建议，每个account下的address_index不要超过20</p><p>根据 <a href="https://github.com/ethereum/EIPs/issues/85" target="_blank" rel="noopener">EIP85提议的讨论</a>以太坊钱包也遵循BIP44标准，确定路径是<code>m/44&#39;/60&#39;/a&#39;/0/n</code><br>a 表示帐号，n 是第 n 生成的地址，60 是在 <a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md" target="_blank" rel="noopener">SLIP44 提案</a>中确定的以太坊的编码。所以我们要开发以太坊钱包同样需要对比特币的钱包提案BIP32、BIP39有所了解。</p><p>一句话概括下BIP44就是：<strong>给BIP32的分层路径定义规范</strong></p><h2 id="BIP39"><a href="#BIP39" class="headerlink" title="BIP39"></a>BIP39</h2><p>BIP32 提案可以让我们保存一个随机数种子（通常16进制数表示），而不是一堆秘钥，确实方便一些，不过用户使用起来(比如冷备份)也比较繁琐，这就出现了<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="noopener">BIP39</a>，它是使用助记词的方式，生成种子的，这样用户只需要记住12（或24）个单词，单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子作为 BIP32 的种子。</p><p>可以简单的做一个对比，下面那一种备份起来更友好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 随机数种子</span><br><span class="line">090ABCB3A6e1400e9345bC60c78a8BE7  </span><br><span class="line">// 助记词种子</span><br><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p><p>使用助记词作为种子其实包含2个部分：助记词生成及助记词推导出随机种子，下面分析下这个过程。</p><h3 id="生成助记词"><a href="#生成助记词" class="headerlink" title="生成助记词"></a>生成助记词</h3><p>助记词生成的过程是这样的：先生成一个128位随机数，再加上对随机数做的校验4位，得到132位的一个数，然后按每11位做切分，这样就有了12个二进制数，然后用每个数去查<a href="https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md" target="_blank" rel="noopener">BIP39定义的单词表</a>，这样就得到12个助记词，这个过程图示如下：</p><p><img src="/images/71c0af9474a51296096c3c806ca8f1a1.png" alt=""><br>（图来源于网络）</p><p>下面是使用bip39生成生成助记词的一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bip39 = <span class="built_in">require</span>(<span class="string">'bip39'</span>)</span><br><span class="line"><span class="comment">// 生成助记词</span></span><br><span class="line"><span class="keyword">var</span> mnemonic = bip39.generateMnemonic()</span><br><span class="line"><span class="built_in">console</span>.log(mnemonic)</span><br></pre></td></tr></table></figure><h3 id="助记词推导出种子"><a href="#助记词推导出种子" class="headerlink" title="助记词推导出种子"></a>助记词推导出种子</h3><p>这个过程使用密钥拉伸（Key stretching）函数，被用来增强弱密钥的安全性，PBKDF2是常用的密钥拉伸算法中的一种。<br>PBKDF2基本原理是通过一个为随机函数(例如 HMAC 函数)，把助记词明文和盐值作为输入参数，然后重复进行运算最终产生生成一个更长的（512 位）密钥种子。这个种子再构建一个确定性钱包并派生出它的密钥。</p><p>密钥拉伸函数需要两个参数：助记词和盐。盐可以提高暴力破解的难度。 盐由常量字符串 “mnemonic” 及一个可选的密码组成，注意使用不同密码，则拉伸函数在使用同一个助记词的情况下会产生一个不同的种子，这个过程图示图下:</p><p><img src="/images/d37f78f8f2d859369d99fc5e0a76c184.png" alt=""><br>（图来源于网络）</p><p>同样代码来表示一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hdkey = <span class="built_in">require</span>(<span class="string">'ethereumjs-wallet/hdkey'</span>)</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'ethereumjs-util'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seed = bip39.mnemonicToSeed(mnemonic, <span class="string">"pwd"</span>);</span><br><span class="line"><span class="keyword">var</span> hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key1 = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"私钥："</span>+util.bufferToHex(key1._hdkey._privateKey));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> address1 = util.pubToAddress(key1._hdkey._publicKey, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"地址："</span>+util.bufferToHex(address1));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"校验和地址："</span>+ util.toChecksumAddress(address1.toString(<span class="string">'hex'</span>)));</span><br></pre></td></tr></table></figure><p>校验和地址是<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank" rel="noopener">EIP-55</a>中定义的对大小写有要求的一种地址形式。</p><p>密码可以作为一个额外的安全因子来保护种子，即使助记词的备份被窃取，也可以保证钱包的安全（也要求密码拥有足够的复杂度和长度），不过另外一方面，如果我们忘记密码，那么将无法恢复我们的数字资产。</p><p>一句话概括下BIP39就是：<strong>通过定义助记词让种子的备份更友好</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>HD钱包（Hierarchical Deterministic Wallets）是在BIP32中提出的为了避免管理一堆私钥的麻烦提出的分层推导方案。<br>而BIP44是给BIP32的分层增强了路径定义规范，同时增加了对多币种的支持。<br>BIP39则通过定义助记词让种子的备份更友好。</p><p>目前我们的市面上单到的以太币、比特币钱包基本都遵循这些标准。</p><p>最后推荐一个<a href="https://iancoleman.io/bip39/" target="_blank" rel="noopener">助记词秘钥生成器网站</a></p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你还在被HD钱包、BIP32、BIP44、BIP39搞的一头雾水，来看看这边文章吧。&lt;/p&gt;
    
    </summary>
    
      <category term="钱包" scheme="https://learnblockchain.cn/categories/%E9%92%B1%E5%8C%85/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Web3.js API 在页面中进行转账</title>
    <link href="https://learnblockchain.cn/2018/09/12/web3-sendeth/"/>
    <id>https://learnblockchain.cn/2018/09/12/web3-sendeth/</id>
    <published>2018-09-12T09:22:34.000Z</published>
    <updated>2018-09-13T10:55:47.417Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何使用Web3.js API 在页面中进行转账，是我翻译的文档<a href="https://web3.learnblockchain.cn/0.2x.x/" target="_blank" rel="noopener">Web3.js 0.2x 中文版</a> 及 <a href="https://wiki.learnblockchain.cn/course/dapp.html" target="_blank" rel="noopener">区块链全栈-以太坊DAPP开发实战</a> 中Demo的文章说明。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约、钱包的概念有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a><br>除此之外，你最好还了解一些HTML及JavaScript知识。</p><h2 id="转账UI-页面的编写"><a href="#转账UI-页面的编写" class="headerlink" title="转账UI 页面的编写"></a>转账UI 页面的编写</h2><p>转账UI主体的界面如图：<br><img src="/images/web3_sendeth_ui.jpg" alt=""></p><p>实现这个界面很简单，这里就不代码了。大家可以打开<a href="https://web3.learnblockchain.cn/transDemo.html" target="_blank" rel="noopener">Demo</a>，右击查看页面源码。</p><h2 id="用户环境检查"><a href="#用户环境检查" class="headerlink" title="用户环境检查"></a>用户环境检查</h2><p>既然需要使用Web3.js API 在页面中进行转账， 首先应该检查在浏览器环境有没有安装好钱包，并且钱包应该是解锁状态。</p><ol><li>先检查是否安装了MetaMask钱包：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">            <span class="keyword">if</span> (web3.currentProvider.isMetaMask == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// "MetaMask可用"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// "非MetaMask环境"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $(<span class="string">"#env"</span>).html(<span class="string">"No web3? 需要安装&lt;a href='https://metamask.io/'&gt;MetaMask&lt;/a&gt;!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MetaMask推荐在window加载时，进行MetaMask的检查，当然在没有安装MetaMask时，也可以指定一个节点Provider来创建web3，可以参考<a href="https://web3.learnblockchain.cn/0.2x.x/#web3" target="_blank" rel="noopener">Web3.js 文档引入web3</a></p><ol><li>检查是否钱包已经解锁：<br>我们在发送交易之前应该先首先检查一下当前钱包的一个状态，检查钱包是否解锁(是否输入了密码进入了MetaMask)，通常使用eth下面的getAccounts来进行检查，getAccounts是会返回账号的一个列表，如果当前账号列表里面有数据的话，说明钱包已经解锁可以获得到账号，如果账号拿到的列表是空的话，那么说明钱包没有解锁。</li></ol><p>可以把下面的代码加到上面的监听函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getAccounts(<span class="function"><span class="keyword">function</span> (<span class="params">err, accounts</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (accounts.length == <span class="number">0</span>) &#123;</span><br><span class="line">                $(<span class="string">"#account"</span>).html(<span class="string">"请检查钱包是否解锁"</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h2><p>如果MetaMask钱包是解锁的，我们就可以来发送交易，发送交易使用<a href="https://web3.learnblockchain.cn/0.2x.x/web3.eth/#web3ethsendtransaction" target="_blank" rel="noopener">sendtransaction</a>这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(transactionObject [, callback])</span><br></pre></td></tr></table></figure><p>第二个参数是回调函数用来获得发送交易的Hash值。</p><p>第一个参数是一个交易对象，交易对象里面有几个字段：</p><ul><li>from : 就是从哪个账号发送金额</li><li>to : 发动到到哪个账号</li><li>value 是发送的金额</li><li>gas: 设置gas limit</li><li>gasPrice: 设置gas 价格</li></ul><p>如果from没有的话，他就会用当前的默认账号， 如果是转账to和value是必选的两个字段。<br>在发送交易的时候弹出来MetaMask的一个授权的窗口，如果我们gas和gasPrice没有设置的话，就可以在MetaMask里面去设置。如果这两个gas和gas Price设置了的话，MetaMask就会使用我们设置的gas。</p><p>因此在发送交易的时候，关键是构造这样一个交易对象，JavaScrpt代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  这里使用Metamask 给的gas Limit 及 gas 价</span></span><br><span class="line"><span class="keyword">var</span> fromAccount = $(<span class="string">'#fromAccount'</span>).val();</span><br><span class="line"><span class="keyword">var</span> toAccount = $(<span class="string">'#toAccount'</span>).val();</span><br><span class="line"><span class="keyword">var</span> amount = $(<span class="string">'#amount'</span>).val();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入的数字做一个检查</span></span><br><span class="line"><span class="keyword">if</span> (web3.isAddress(fromAccount) &amp;&amp;</span><br><span class="line">            web3.isAddress(toAccount) &amp;&amp;</span><br><span class="line">            amount != <span class="literal">null</span> &amp;&amp; amount.length &gt; <span class="number">0</span>） &#123;</span><br><span class="line">    <span class="keyword">var</span> message = &#123;<span class="attr">from</span>: fromAccount, <span class="attr">to</span>:toAccount, <span class="attr">value</span>: web3.toWei(amount, <span class="string">'ether'</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    web3.eth.sendTransaction(message, (err, res) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> output = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">            output += res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            output = <span class="string">"Error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充说明：<code>$(&#39;#fromAccount&#39;).val()</code>是使用JQuery用来获取用户输入内容，其次应该在实际构造发送交易之前对输入的参数做一个判断，<code>web3.isAddress</code>用来检查字符串是不是地址。另外对于一个向普通外部地址账号的转账，消耗的gas 是固定的21000。</p><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>需要注意一点的是，由于安全原因，MetaMask只支持站点方式访问的页面，即通过http:// 来访问页面，在浏览器中通过file:// + 文件地址的方式是不行的。<br>因此需要把编写的代码放置到web服务器的目录下，自己试验下。</p><p>线上的Demo地址为<a href="https://web3.learnblockchain.cn/transDemo.html" target="_blank" rel="noopener">https://web3.learnblockchain.cn/transDemo.html</a></p><p>想好好系统学习以太坊DApp开发，这门视频课程<a href="https://wiki.learnblockchain.cn/course/dapp.html" target="_blank" rel="noopener">以太坊DAPP开发实战</a>不容错过。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>深入浅出区块链<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>，最专业的区块链问题技术社区，欢迎加入，作为星友福利，星友还可以加入我创建优质区块链技术群，群内聚集了300多位区块链技术大牛和爱好者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍如何使用Web3.js API 在页面中进行转账，是我翻译的文档&lt;a href=&quot;https://web3.learnblockchain.cn/0.2x.x/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web3.js 0.2x 中文版&lt;/a&gt; 及 &lt;a href=&quot;https://wiki.learnblockchain.cn/course/dapp.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区块链全栈-以太坊DAPP开发实战&lt;/a&gt; 中Demo的文章说明。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Dapp" scheme="https://learnblockchain.cn/categories/ethereum/Dapp/"/>
    
    
      <category term="Web3.js" scheme="https://learnblockchain.cn/tags/Web3-js/"/>
    
      <category term="Dapp入门" scheme="https://learnblockchain.cn/tags/Dapp%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>程序员如何切入区块链去中心化应用开发</title>
    <link href="https://learnblockchain.cn/2018/08/31/devDapp/"/>
    <id>https://learnblockchain.cn/2018/08/31/devDapp/</id>
    <published>2018-08-31T03:30:55.000Z</published>
    <updated>2018-09-04T07:05:51.785Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间一个以太坊游戏应用：<a href="http://exitscam.me/play" target="_blank" rel="noopener">Fomo3D</a>异常火爆，在短短的几天内就吸引了几万的以太币投入游戏，第一轮游戏一个“黑客”用了一个非常巧妙的利用以太坊规则成为了最终赢家，拿走了1万多以太币奖金。</p><p>区块链应用的价值由这个游戏反映的淋漓尽致，Fomo3D游戏能够成功核心所依赖的是以太坊提供的一个可信、不可篡改平台。当游戏的规则确定之后，一切都按规则运行，无人可干预。今天这篇就来介绍一下程序员如何切入去中心化应用开发。</p><a id="more"></a><h2 id="中心化应用"><a href="#中心化应用" class="headerlink" title="中心化应用"></a>中心化应用</h2><p>作为对比，先来看看中心化应用，其实就是现有的互联网应用，为什么它是中心化应用，看看它的架构图：<br><img src="/images/capp.jpg" alt=""></p><p>平时我们接触的是应用的前端（或称客户端），前端可以是HTML5的web页面、 小程序、APP， 在前端展现的内容通常发送一个请求到服务器，服务器返回相应的内容给前端。在前端的动作同样也会转化请求发送到服务器，服务器处理之后返回数据到前端。也就是说我们所有看到的内容或者操作都是中心化的服务器控制，因此说是中心化应用。</p><h2 id="去中心化应用DAPP"><a href="#去中心化应用DAPP" class="headerlink" title="去中心化应用DAPP"></a>去中心化应用DAPP</h2><p>而去中心化应用有什么不同呢？ 看看它的架构图：<br><img src="/images/dapp.jpg" alt=""><br>前端的表现上是一样的， 还是H5页面、 小程序、APP，DAPP和传统App关键是后端部分不同，是后端不再是一个中心化的服务器，而是分布式网络上任意节点，注意可以是 <strong>任意一个节点</strong>，在应用中给节点发送的请求通常称为 <strong>交易</strong>，交易和中心化下的请求有几个很大的不同是：交易的数据经过用户个人签名之后发送到节点，节点收到交易请求之后，会把 <strong>请求广播到整个网络</strong>，交易在网络达成共识之后，才算是真正的执行（真正其作用的执行不一是连接的后端节点，尽管后端也会执行）。以及中心化下的请求大多数都是同步的（及时拿到结果）， 而交易大多数是异步的，这也是在开发去中心应用时需要注意的地方，</p><p>从节点上获得数据状态（比如交易的结果），一般是通过事件回调来获得。</p><h2 id="如何开发"><a href="#如何开发" class="headerlink" title="如何开发"></a>如何开发</h2><p>在开发中心化应用最重要两部分是 <strong>客户端UI表现</strong>和 <strong>后端服务程序</strong>， UI表现通过HTTP请求连接到后端服务程序，后端服务程序运行在服务器上，比如Nginx Apached等等。</p><p>开发一个去中心化应用最重要也是两部分： <strong>客户端UI表现</strong>及 <strong>智能合约</strong>，智能合约的作用就像后端服务程序，智能合约是运行在节点的EVM上， 客户端调用智能合约，是通过向节点发起RPC请求完成。</p><p>下面是一个对比：</p><pre><code>     客户端UI &lt;=&gt; 客户端UI         HTTP &lt;=&gt; RPC  后端服务程序 &lt;=&gt; 智能合约Nginx/Apache &lt;=&gt; 节点</code></pre><p>因此对于去中心化应用来说，程序员可以从两个方面切入:</p><p>一个是 <strong>去中心化应用的客户端开发</strong>， 熟悉已经熟悉客户端软件（如Web\APP等）开发的同学，只需要了解一下客户端跟区块链节点通信的API接口，如果是在当前应用最广泛的区块链平台以太坊上开发去中心化应用，那么需要了解Web3<br>这个库，Web3对节点暴露出来的JSON-RPC接口进行了封装，比如Web3提供的功能有：获取节点状态，获取账号信息，调用合约、监听合约事件等等。</p><p>目前的主流语言都有Web3的实现，列举一些实现给大家参考：</p><ul><li><a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">JavaScript Web3.js</a></li><li><a href="https://github.com/ethereum/web3.py" target="_blank" rel="noopener">Python Web3.py</a></li><li><a href="https://github.com/airalab/hs-web3" target="_blank" rel="noopener">Haskell hs-web3</a></li><li><a href="https://github.com/web3j/web3j" target="_blank" rel="noopener">Java web3j</a></li><li><a href="https://github.com/mslinn/web3j-scala" target="_blank" rel="noopener">Scala web3j-scala</a></li><li><a href="https://github.com/f-o-a-m/purescript-web3" target="_blank" rel="noopener">Purescript purescript-web3</a></li><li><a href="https://github.com/sc0Vu/web3.php" target="_blank" rel="noopener">PHP web3.php</a></li><li><a href="https://github.com/digitaldonkey/ethereum-php" target="_blank" rel="noopener">PHP ethereum-php</a></li></ul><p>另一个切入点是 <strong>智能合约的开发</strong>，在以太坊现在推荐的语言是Solidity，有一些同学对新学一门语言有一些畏惧，Solidity的语法其实很简洁，有过一两门其他语言基础（开发经验）的同学三五天就可以学会，我也录制了一个视频课程：<a href="https://wiki.learnblockchain.cn/course/solidity.html" target="_blank" rel="noopener">深入详解以太坊智能合约语言Solidity</a>。</p><p>下面用一个Hello合约，体会下Solidity的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Hello &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"Hello World"</span>; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把上面的contract关键字更改为class，就和其他语言定义一个类一样。</p><p>有兴趣的同学可以进一步学习一下这个DApp开发案例<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>，</p><p>在DAPP的开发过程中，一些开发工具可以帮助我们事半功倍，如：Truffle开发框架以及Ganache工具来模拟节点等，这篇文章<a href="https://learnblockchain.cn/2018/01/12/first-dapp/">一步步教你开发、部署第一个去中心化应用</a></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对于想切入到去中心化应用开发的同学，对区块链运行的原理了解肯定会是加分项，尤其是各类共识机制（<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">POW</a>，POS，DPOS等）的理解，P2P网络的理解，以及各类加密和Hash算法的运用。有一些同学想做区块链底层开发，对区块链运行的原理则是必须项。</p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间一个以太坊游戏应用：&lt;a href=&quot;http://exitscam.me/play&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fomo3D&lt;/a&gt;异常火爆，在短短的几天内就吸引了几万的以太币投入游戏，第一轮游戏一个“黑客”用了一个非常巧妙的利用以太坊规则成为了最终赢家，拿走了1万多以太币奖金。&lt;/p&gt;
&lt;p&gt;区块链应用的价值由这个游戏反映的淋漓尽致，Fomo3D游戏能够成功核心所依赖的是以太坊提供的一个可信、不可篡改平台。当游戏的规则确定之后，一切都按规则运行，无人可干预。今天这篇就来介绍一下程序员如何切入去中心化应用开发。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Dapp" scheme="https://learnblockchain.cn/categories/ethereum/Dapp/"/>
    
    
      <category term="Dapp入门" scheme="https://learnblockchain.cn/tags/Dapp%E5%85%A5%E9%97%A8/"/>
    
      <category term="以太坊概念" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>如何理解以太坊ABI - 应用程序二进制接口</title>
    <link href="https://learnblockchain.cn/2018/08/09/understand-abi/"/>
    <id>https://learnblockchain.cn/2018/08/09/understand-abi/</id>
    <published>2018-08-09T09:08:39.000Z</published>
    <updated>2018-09-04T07:57:04.364Z</updated>
    
    <content type="html"><![CDATA[<p>很多同学不是很明白以太坊ABI是什么，他的作用是什么，读完本文就明白了。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>，也可以观看我们的视频：<a href="https://wiki.learnblockchain.cn/course/beginner.html" target="_blank" rel="noopener">零基础搞懂区块链</a>和<a href="https://wiki.learnblockchain.cn/course/solidity.html" target="_blank" rel="noopener">深入详解以太坊智能合约语言Solidity</a>, 可以系统全面学习理解以太坊、智能合约。</p><h2 id="ABI-是什么"><a href="#ABI-是什么" class="headerlink" title="ABI 是什么"></a>ABI 是什么</h2><p>ABI 全称是 Application Binary Interface，翻译过来就是：应用程序二进制接口，简单来说就是 以太坊的调用合约时的接口说明。还不是很理解，没关系。</p><h2 id="调用合约函数发生了什么"><a href="#调用合约函数发生了什么" class="headerlink" title="调用合约函数发生了什么"></a>调用合约函数发生了什么</h2><p>从外部施加给以太坊的行为都称之为向以太坊网络提交了一个交易， 调用合约函数其实是向合约地址（账户）提交了一个交易，这个交易有一个附加数据，这个附加的数据就是ABI的编码数据。<br><img src="/images/abi1.jpg" alt=""></p><blockquote><p>比特币的交易也可以附加数据，以太坊革命性的地方就是能把附加数据转化为都函数的执行。</p></blockquote><p>因此要想和合约交互，就离不开ABI数据。</p><h3 id="演示调用函数"><a href="#演示调用函数" class="headerlink" title="演示调用函数"></a>演示调用函数</h3><p>以下面以个最简单的合约为例，我们看看用参数 1 调用<code>set(uint x)</code>，这个交易附带的数据是什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    </span><br><span class="line">    uint storedData;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然第一步需要先把合约部署到以太坊网络（其实部署也是一个）上，然后用 “1” 作为参数调用set，如下图:<br><img src="/images/abi2.jpg" alt=""></p><p>然后我们打开etherscan查看<a href="https://ropsten.etherscan.io/tx/0xd773a6909808f99c5a26c0c890af8b0bb6d784f29a3af55e04fa35d44d7716e2" target="_blank" rel="noopener">交易详情数据</a>, 可以看到其附加数据如下图：<br><img src="/images/abi3.jpg" alt=""></p><p>这个数据就是ABI的编码数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x60fe47b10000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure></p><h2 id="ABI-编码分析"><a href="#ABI-编码分析" class="headerlink" title="ABI 编码分析"></a>ABI 编码分析</h2><p>我把上面交易的附加数据拷贝出来分析一下，这个数据可以分成两个子部分：</p><ul><li><p>函数选择器(4字节)<br>0x60fe47b1</p></li><li><p>第一个参数(32字节)<br>00000000000000000000000000000000000000000000000000000000000000001</p></li></ul><p>函数选择器值 实际是对函数签名字符串进行sha3（keccak256）哈希运算之后，取前4个字节，用代码表示就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes4(sha3(“set(uint256)”)) == <span class="number">0x60fe47b1</span></span><br></pre></td></tr></table></figure><p>参数部分则是使用对应的16进制数。</p><p>现在就好理解 附加数据怎么转化为对应的函数调用。</p><h2 id="ABI-编码函数"><a href="#ABI-编码函数" class="headerlink" title="ABI 编码函数"></a>ABI 编码函数</h2><p>那么怎么获得函数对应的ABI 数据呢， 有两种方法：</p><h3 id="Solidity-ABI-编码函数"><a href="#Solidity-ABI-编码函数" class="headerlink" title="Solidity ABI 编码函数"></a>Solidity ABI 编码函数</h3><p>一个是 solidity 提供了ABI的相关<a href="https://learnblockchain.cn/2018/03/14/solidity-api/">API</a>， 用来直接得到ABI编码信息，这些函数有：</p><ul><li>abi.encode(…) returns (bytes)：计算参数的ABI编码。</li><li>abi.encodePacked(…) returns (bytes)：计算参数的紧密打包编码</li><li>abi. encodeWithSelector(bytes4 selector, …) returns (bytes)： 计算函数选择器和参数的ABI编码</li><li>abi.encodeWithSignature(string signature, …) returns (bytes): 等价于* abi.encodeWithSelector(bytes4(keccak256(signature), …)</li></ul><p>通过ABI编码函数可以在不用调用函数的情况下，获得ABI编码值，下面通过一段代码来看看这些方法的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line"></span><br><span class="line">contract testABI &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abiEncode</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">        abi.encode(<span class="number">1</span>);  <span class="comment">// 计算1的ABI编码</span></span><br><span class="line">        <span class="keyword">return</span> abi.encodeWithSignature(<span class="string">"set(uint256)"</span>, <span class="number">1</span>); <span class="comment">//计算函数set(uint256) 及参数1 的ABI 编码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以运行运行下<code>abiEncode</code>函数，它的输出其实就是前面调用的附加数据。</p><h3 id="Web3-ABI-编码函数"><a href="#Web3-ABI-编码函数" class="headerlink" title="Web3 ABI 编码函数"></a>Web3 ABI 编码函数</h3><p>另一个web3提供相应的API，例如使用web3计算函数选择器的方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.abi.encodeFunctionSignature(<span class="string">'myMethod(uint256,string)'</span>);</span><br></pre></td></tr></table></figure><p>其完整的文档在<a href="http://web3js.readthedocs.io/en/1.0/web3-eth-abi.html" target="_blank" rel="noopener">这里</a>，这里不一一演示。</p><p>如果你想学习以太坊DApp开发，这门视频课程<a href="https://wiki.learnblockchain.cn/course/dapp.html" target="_blank" rel="noopener">以太坊DAPP开发实战</a>是你不错的选择。</p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多同学不是很明白以太坊ABI是什么，他的作用是什么，读完本文就明白了。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="ABI" scheme="https://learnblockchain.cn/tags/ABI/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列13 -  函数调用</title>
    <link href="https://learnblockchain.cn/2018/08/09/solidity-callfun/"/>
    <id>https://learnblockchain.cn/2018/08/09/solidity-callfun/</id>
    <published>2018-08-09T03:17:17.000Z</published>
    <updated>2018-08-09T03:25:59.523Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第13篇介绍函数调用， 本文会介绍函数使用元组返回多个值，通过命名方式进行参数调用以及如何省略函数参数名称。</p><p>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="函数调用及参数"><a href="#函数调用及参数" class="headerlink" title="函数调用及参数"></a>函数调用及参数</h2><p>在<a href="https://xiaozhuanlan.com/topic/1293405678" target="_blank" rel="noopener">函数类型</a>一节中，我们介绍过Solidity 中有两种函数调用方式：内部函数调用和外部函数调用，这一节我们进一步介绍。</p><h2 id="内部函数调用（Internal-Function-Calls）"><a href="#内部函数调用（Internal-Function-Calls）" class="headerlink" title="内部函数调用（Internal Function Calls）"></a>内部函数调用（Internal Function Calls）</h2><p>内部调用，不会创建一个EVM消息调用。而是直接调用当前合约的函数，也可以递归调用。<br>如下面这个的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint a</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f();       <span class="comment">// 直接调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> g(<span class="number">7</span>) + f();    <span class="comment">// 直接调用及递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些函数调用被转换为EVM内部的简单指令跳转（jumps）。 这样带来的一个好处是，当前的内存不会被回收。在一个内部调用时传递一个内存型引用效率将非常高的。当然，仅仅是同一个合约的函数之间才可通过内部的方式进行调用。</p><h2 id="外部函数调用-External-Function-Calls"><a href="#外部函数调用-External-Function-Calls" class="headerlink" title="外部函数调用(External Function Calls)"></a>外部函数调用(External Function Calls)</h2><p>外部调用，会创建EVM<strong>消息调用</strong>。<br>表达式this.g(8);和c.g(2)（这里的c是一个合约实例）是外部调用函数的方式，它会发起一个消息调用，而不是EVM的指令跳转。需要注意的是，在合约的构造器中，不能使用this调用函数，因为当前合约还没有创建完成。</p><p>其它合约的函数必须通过外部的方式调用。对于一个外部调用，所有函数的参数必须要拷贝到内存中。</p><p>当调用其它合约的函数时，可以通过选项<strong>.value()</strong>，和<strong>.gas()</strong>来分别指定要发送的以太币（以wei为单位）和gas值，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFeed</span>(<span class="params">address addr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">      feed = InfoFeed(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callFeed</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">      feed.info.value(<span class="number">10</span>).gas(<span class="number">800</span>)();  <span class="comment">// 附加以太币及gas来调用info</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>info()函数，必须使用payable关键字，否则不能通过value()来接收以太币。</p><p>表达式InfoFeed(addr)进行了一个显示的类型转换，表示给定的地址是合约InfoFeed类型，这里并不会执行构造器的初始化。<br>在进行显式的类型强制转换时需要非常小心，不要调用一个我们不知道类型的合约函数。</p><p>我们也可以使用<strong>function setFeed(InfoFeed _feed) { feed = _feed; }</strong>来直接进行赋值。<br>注意<strong>feed.info.value(10).gas(800)</strong>仅仅是对发送的以太币和gas值进行了设置，真正的调用是后面的括号()。<br>调用callFeed时，需要预先存入一定量的以太币，要不能会因余额不足报错。</p><blockquote><p>如果我们不知道被调用的合约源代码，和它们交互会有潜在的风险，即便被调用的合约继承自一个已知的父合约（继承仅仅要求正确实现接口，而不关注实现的内容）。<br>因为和他们交互，相当于把自己控制权交给被调用的合约，对方几乎可以利用它做任何事。<br>此外, 被调用的合约可以改变调用合约的状态变量，在编写函数时需要注意可重入性漏洞问题（可查看安全建议）。</p></blockquote><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>与其他语言一样，函数可以提供参数作为输入（函数类型本身也可以作为参数）; 与Javascript和C不同的是，solidity还可以返回任意数量的参数作为输出。</p><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>输入参数的声明方式与变量相同， 未使用的参数可以省略变量名称。假设我们希望合约接受一种带有两个整数参数的外部调用，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">taker</span>(<span class="params">uint _a, uint _b</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 _a  _b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>输出参数的声明和输入参数一样，只不过它接在returns 之后，假设我们希望返回两个结果：两个给定整数的和及积，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arithmetics</span>(<span class="params">uint _a, uint _b</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">pure</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint o_sum, uint o_product</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以省略输出参数的名称，也可以使用return语句指定输出值，return可以返回多个值（见下文）。<br>返回一个没有赋值的参数，则默认为0。</p><p>输入参数和输出参数可以在函数内表达式中使用，也可以作为被赋值的对象， 如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">taker</span>(<span class="params">uint _a, uint _b</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint _c</span>) </span>&#123;</span><br><span class="line">        _a = <span class="number">1</span>;</span><br><span class="line">        _b = <span class="number">2</span>;</span><br><span class="line">        _c = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>当一个函数有多个输出参数时, 可以使用元组(tuple)来返回多个值。元组(tuple)是一个数量固定，类型可以不同的元素组成的一个列表（用小括号表示），使用return (v0, v1, …, vn) 语句，就可以返回多个值，返回值的数量需要和输出参数声明的数量一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint, bool, uint</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用元组返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">7</span>, <span class="literal">true</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callf</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    uint x;</span><br><span class="line">    bool y;</span><br><span class="line">    uint z;</span><br><span class="line">    <span class="comment">// 使用元组给多个变量赋值</span></span><br><span class="line">    (x, y , z)  = f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充关于元组的介绍"><a href="#补充关于元组的介绍" class="headerlink" title="补充关于元组的介绍"></a>补充关于元组的介绍</h4><p>上面的代码中，使用了元组返回多个值及使用元组给多个变量赋值，给多个变量赋值通常也称为解构（解构的概念在函数式语言中较为常见），再来看看元组的一些用法，比如元组可以交换变量值，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) = (y, x);</span><br></pre></td></tr></table></figure><p>元组支持省略一些元素， 如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y, ) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>开头的元素也可以省略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(, y, ) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>注意 (1,) 是一个一个元素的元组， (1) 只是1。</p><h3 id="使用命名参数调用"><a href="#使用命名参数调用" class="headerlink" title="使用命名参数调用"></a>使用命名参数调用</h3><p>函数调用的参数，可以通过指定名称的方式调用，使用花括号{} 包起来，参数顺序任意，但参数的类型和数量要与定义一致。<br>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint key, uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        f(&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">key</span>: <span class="number">3</span>&#125;);  <span class="comment">// 命名参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="省略函数参数名称"><a href="#省略函数参数名称" class="headerlink" title="省略函数参数名称"></a>省略函数参数名称</h3><p>没有使用的参数名称可以省略(一般常见于返回值)。这些参数依然在栈(stack)上存在，但不可访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="comment">// omitted name for parameter</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">uint k, uint</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第13篇介绍函数调用， 本文会介绍函数使用元组返回多个值，通过命名方式进行参数调用以及如何省略函数参数名称。&lt;/p&gt;
&lt;p&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列12 -  库的使用</title>
    <link href="https://learnblockchain.cn/2018/08/09/solidity-library/"/>
    <id>https://learnblockchain.cn/2018/08/09/solidity-library/</id>
    <published>2018-08-09T02:40:56.000Z</published>
    <updated>2018-08-09T03:12:58.810Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第12篇介绍库的使用：库与合约的不同，使用库的正姿势。</p><p>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>库与合约类似，它也部署在一个指定的地址上（仅被部署一次，当代码在不同的合约可反复使用），然后通过EVM的特性DELEGATECALL (Homestead之前是用CALLCODE)来复用代码。库函数在被调用时，库代码是在发起合约（下文称<strong>主调合约</strong>：主动发起DELEGATECALL调用的合约）的上下文中执行的，使用this将会指向到主调合约，而且库代码可以访问主调合约的存储(storage)。</p><p>因为库合约是一个独立的代码，它仅可以访问主调合约明确提供的状态变量，否则，没办法法去知道这些状态变量。</p><p>对比普通合约来说，库存在以下的限制（这些限制将来也可能在将来的版本被解除）：</p><ol><li>无状态变量(state variables)。</li><li>不能继承或被继承</li><li>不能接收以太币</li><li>不能销毁一个库</li></ol><p>不会修改状态变量（例如被声明<strong>view</strong>或<strong>pure</strong>）库函数只能通过直接调用（如不用<strong>DELEGATECALL</strong>），是因为其被认为是状态无关的。</p><p>库有许多使用场景。两个主要的场景如下：</p><ol><li><p>如果有许多合约，它们有一些共同代码，则可以把共同代码部署成一个库。这将节省gas，因为gas也依赖于合约的规模。因此，可以把库想象成使用其合约的父合约。使用父合约（而非库）切分共同代码不会节省gas，因为在Solidity中，继承通过复制代码工作。</p></li><li><p>库可用于给数据类型添加成员函数。（参见下一节Using for）</p></li></ol><p>由于库被当作隐式的父合约（不过它们不会显式的出现在继承关系中，但调用库函数和调用父合约的方式是非常类似的，如库L有函数f()，使用L.f()即可访问）。库里面的内部（internal）函数被复制给使用它的合约；<br>同样按调用内部函数的调用方式，这意味着所有内部类型可以传进去，memory类型则通过引用传递，而不是拷贝的方式。 同样库里面的结构体structs和枚举enums也会被复制给使用它的合约。<br>因此，如果一个库里只包含内部函数或结构体或枚举，则不需要部署库，因为库里面的所有内容都被复制给使用它的合约。</p><p>下面的例子展示了如何使用库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">library <span class="built_in">Set</span> &#123;</span><br><span class="line">  <span class="comment">// 定义了一个结构体，保存主调函数的数据（本身并未实际存储的数据）。</span></span><br><span class="line">  struct Data &#123; mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// self是一个存储类型的引用（传入的会是一个引用，而不是拷贝的值），这是库函数的特点。</span></span><br><span class="line">  <span class="comment">// 参数名定为self 也是一个惯例，就像调用一个对象的方法一样.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已存在</span></span><br><span class="line">      self.flags[value] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">      self.flags[value] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">view</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="built_in">Set</span>.Data knownValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 库函数不需要实例化就可以调用，因为实例就是当前的合约</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="built_in">Set</span>.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这个合约中，如果需要的话可以直接访问knownValues.flags，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以不按上面的方式来使用库函数，可以不定义结构体，可以不使用storage类型引用的参数，还可以在任何位置有多个storage的引用类型的参数。</p><p>调用<strong>Set.contains</strong>，<strong>Set.remove</strong>，<strong>Set.insert</strong>都会编译为以DELEGATECALL的方式调用外部合约和库。如果使用库，需要注意的是一个真实的外部函数调用发生了。尽管msg.sender，msg.value，this还会保持它们在主调合约中的值（在Homestead之前，由于实际使用的是CALLCODE，msg.sender，msg.value会变化）。</p><p>下面的例子演示了在库中如何使用memory类型和内部函数(inernal function)来实现一个自定义类型，而不会用到外部函数调用(external function)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fromUint</span>(<span class="params">uint x</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bigint r</span>) </span>&#123;</span><br><span class="line">        r.limbs = <span class="keyword">new</span> uint[](<span class="number">1</span>);</span><br><span class="line">        r.limbs[<span class="number">0</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">bigint _a, bigint _b</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bigint r</span>) </span>&#123;</span><br><span class="line">        r.limbs = <span class="keyword">new</span> uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            <span class="keyword">if</span> (a + b &lt; a || (a + b == uint(<span class="number">-1</span>) &amp;&amp; carry &gt; <span class="number">0</span>))</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// too bad, we have to add a limb</span></span><br><span class="line">            uint[] memory newLimbs = <span class="keyword">new</span> uint[](r.limbs.length + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">limb</span>(<span class="params">bigint _a, uint _limb</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _limb &lt; _a.limbs.length ? _a.limbs[_limb] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">uint a, uint b</span>) <span class="title">private</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt <span class="keyword">for</span> BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = BigInt.fromUint(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">var</span> y = BigInt.fromUint(uint(<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">var</span> z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约的源码中不能添加库地址，它是在编译时向编译器以参数形式提供的（这些地址须由链接器（linker）填进最终的字节码中，使用命令行编译器来进行联接 TODO）。如果地址没有以参数的方式正确给到编译器，编译后的字节码将会仍包含一个这样格式的占们符<em>Set__</em>(其中Set是库的名称)。可以通过手动将所有的40个符号替换为库的十六进制地址。</p><h2 id="Using-for-指令"><a href="#Using-for-指令" class="headerlink" title="Using for 指令"></a>Using for 指令</h2><p>指令<strong>using A for B;</strong>用来把库函数(从库A)关联到类型B。这些函数将会把调用函数的实例作为第一个参数。语法类似，python中的self变量一样。例如：A库有函数 <strong>add(B b1, B b2)</strong>，则使用<strong>Using A for B</strong>指令后，如果有B b1就可以使用<strong>b1.add(b2)</strong>。</p><p>using A for *  表示库A中的函数可以关联到任意的类型上。</p><p>在这两种情形中，所有函数，即使第一个参数的类型与调用函数的对象类型不匹配的，也会被关联上。类型检查是在函数被调用时执行，以及函数重载是也会执行检查。</p><p><strong>using A for B;</strong> 指令仅在当前的作用域有效，且暂时仅仅支持当前的合约这个作用域，后续也非常有可能解除这个限制，允许作用到全局范围。如果能作用到全局范围，通过引入一些模块(module)，数据类型将能通过库函数扩展功能，而不需要每个地方都得写一遍类似的代码了。</p><p>下面我们使用Using for 指令方式重写上一节Set的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库合约代码和上一节一样</span></span><br><span class="line">library <span class="built_in">Set</span> &#123;</span><br><span class="line">  struct Data &#123; mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.flags[value])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// already there</span></span><br><span class="line">      self.flags[value] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// not there</span></span><br><span class="line">      self.flags[value] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">view</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using <span class="built_in">Set</span> <span class="keyword">for</span> <span class="built_in">Set</span>.Data; <span class="comment">// 这是一个关键的变化</span></span><br><span class="line">    <span class="built_in">Set</span>.Data knownValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 现在 Set.Data都对应的成员方法</span></span><br><span class="line">        <span class="comment">// 效果和Set.insert(knownValues, value)相同</span></span><br><span class="line">        <span class="built_in">require</span>(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以使用Using for的方式来对基本类型（elementary types）进行扩展： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">uint[] storage self, uint value</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">view</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; self.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (self[i] == value) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> uint(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search <span class="keyword">for</span> uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">uint _old, uint _new</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进行库调用</span></span><br><span class="line">        uint index = data.indexOf(_old);</span><br><span class="line">        <span class="keyword">if</span> (index == uint(<span class="number">-1</span>))</span><br><span class="line">            data.push(_new);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data[index] = _new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是所有库调用都实际上是EVM函数调用。这意味着，如果传的是memory类型的，或者是值类型，那么进行一次拷贝，即使是self变量，解决方法是使用存储(storage)类型的引用来避免拷贝内容。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第12篇介绍库的使用：库与合约的不同，使用库的正姿势。&lt;/p&gt;
&lt;p&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>Python实现一条基于POS算法的区块链</title>
    <link href="https://learnblockchain.cn/2018/08/07/python-blockchain-with-pos/"/>
    <id>https://learnblockchain.cn/2018/08/07/python-blockchain-with-pos/</id>
    <published>2018-08-07T12:44:00.000Z</published>
    <updated>2018-08-07T02:29:06.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链中的共识算法"><a href="#区块链中的共识算法" class="headerlink" title="区块链中的共识算法"></a>区块链中的共识算法</h1><p>在比特币公链架构解析中，就曾提到过为了实现去中介化的设计，比特币设计了一套共识协议，并通过此协议来保证系统的稳定性和防攻击性。 并且我们知道，截止目前使用最广泛，也是最被大家接受的共识算法，是我们先前介绍过的POW(proof of work)<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">工作量证明算法</a>。目前市值排名前二的比特币和以太坊也是采用的此算法。</p><a id="more"></a><p>虽然POW共识算法取得了巨大的成功，但对它的质疑也从来未曾停止过。 其中最主要的一个原因就是电力消耗。据不完全统计，基于POW的挖矿机制所消耗的电量是非常巨大的，甚至比绝大多数国家耗电量还要多。这对我们的资源造成了极大的浪费，此外随着比特大陆等公司的强势崛起，造成了算力的高度集中。</p><p>基于以上种种原因，更多的共识算法被提出来 POS、DPOS、BPFT等等。 今天我们就来认识POS(proof of stake)算法。</p><p>Proof of stake，译为权益证明。你可能已经猜到了，权益证明简单理解就是拥有更多token的人，有更大的概率获得记账权利，然后获得奖励。 这个概率具体有多大呢？ 下面我们在代码实现中会展示，分析也放在后面。 当然，POS是会比POW更好吗？ 会更去中心化吗？ 现在看来未必，所以我们这里也不去对比谁优谁劣。 我们站在中立的角度，单纯的来讨论讨论POS这种算法。</p><h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><h2 id="生成一个Block"><a href="#生成一个Block" class="headerlink" title="生成一个Block"></a>生成一个Block</h2><p>既然要实现POS算法，那么就难免要生成一条链，链又是由一个个Block生成的，所以下面我们首先来看看如何生成Block，当然在前面的内容里面，关于如何生成Block，以及交易、UTXO等等都已经介绍过了。由于今天我们的核心是实现POS，所以关于Block的生成，我们就用最简单的实现方式，好让大家把目光聚焦在核心的内容上面。</p><p>我们用三个方法来实现生成一个合法的区块</p><ul><li>calculate_hash  计算区块的hash值</li><li>is_block_valid  校验区块是否合法</li><li>generate_block  生成一个区块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_block</span><span class="params">(oldblock, bpm, address)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param oldblock:</span></span><br><span class="line"><span class="string">    :param bpm:</span></span><br><span class="line"><span class="string">    :param address:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    newblock = &#123;</span><br><span class="line">        <span class="string">"Index"</span>: oldblock[<span class="string">"Index"</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">"BPM"</span>: bpm,</span><br><span class="line">        <span class="string">"Timestamp"</span>: str(datetime.now()),</span><br><span class="line">        <span class="string">"PrevHash"</span>: oldblock[<span class="string">"Hash"</span>],</span><br><span class="line">        <span class="string">"Validator"</span>: address</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newblock[<span class="string">"Hash"</span>] = calculate_hash(newblock)</span><br><span class="line">    <span class="keyword">return</span> newblock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_hash</span><span class="params">(block)</span>:</span></span><br><span class="line">    record = <span class="string">""</span>.join([</span><br><span class="line">        str(block[<span class="string">"Index"</span>]),</span><br><span class="line">        str(block[<span class="string">"BPM"</span>]),</span><br><span class="line">        block[<span class="string">"Timestamp"</span>],</span><br><span class="line">        block[<span class="string">"PrevHash"</span>]</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sha256(record.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_block_valid</span><span class="params">(newblock, oldblock)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param newblock:</span></span><br><span class="line"><span class="string">    :param oldblock:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldblock[<span class="string">"Index"</span>] + <span class="number">1</span> != newblock[<span class="string">"Index"</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldblock[<span class="string">"Hash"</span>] != newblock[<span class="string">"PrevHash"</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> calculate_hash(newblock) != newblock[<span class="string">"Hash"</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>这里为了更灵活，我们没有用类的实现方式，直接采用函数来实现了Block生成，相信很容易看懂。</p><h2 id="创建一个TCP服务器"><a href="#创建一个TCP服务器" class="headerlink" title="创建一个TCP服务器"></a>创建一个TCP服务器</h2><p>由于我们需要用权益证明算法来选择记账人，所以需要从很多Node(节点)中选择记账人，也就是需要一个server让节点链接上来，同时要同步信息给节点。因此需要一个TCP长链接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> BaseRequestHandler, ThreadingTCPServer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># start a tcp server</span></span><br><span class="line">    serv = ThreadingTCPServer((<span class="string">''</span>, <span class="number">9090</span>), HandleConn)</span><br><span class="line">    serv.serve_forever()</span><br></pre></td></tr></table></figure><p>在这里我们用了python内库socketserver来创建了一个TCPServer。 需要注意的是，这里我们是采用的多线程的创建方式，这样可以保证有多个客户端同时连接上来，而不至于被阻塞。当然，这里这个server也是存在问题的，那就是有多少个客户端连接，就会创建多少个线程，更好的方式是创建一个线程池。由于这里是测试，所以就采用更简单的方式了。</p><p>相信大家已经看到了，在我们创建TCPServer的时候，使用到了HandleConn，但是我们还没有定义，所以接下来我们就来定义一个HandleConn</p><p>##消息处理器<br>下面我们来实现Handler函数，Handler函数在跟Client Node通信的时候，需要我们的Node实现下面的功能</p><ul><li>Node可以输入balance（token数量）  也就是股权数目</li><li>Node需要能够接收广播，方便Server同步区块以及记账人信息</li><li>添加自己到候选人名单 （候选人为持有token的人）</li><li>输入BPM生成Block</li><li>验证一个区块的合法性</li></ul><p>感觉任务还是蛮多的，接下来我们看代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue, Empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">block_chain = []</span><br><span class="line">temp_blocks = []</span><br><span class="line">candidate_blocks = Queue()  <span class="comment"># 创建队列，用于线程间通信</span></span><br><span class="line">announcements = Queue()</span><br><span class="line">validators = &#123;&#125;</span><br><span class="line"></span><br><span class="line">My_Lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleConn</span><span class="params">(BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Got connection from"</span>, self.client_address)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># validator address</span></span><br><span class="line">        self.request.send(<span class="string">b"Enter token balance:"</span>)</span><br><span class="line">        balance = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            balance = int(balance)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line">        t = str(datetime.now())</span><br><span class="line">        address = sha256(t.encode()).hexdigest()</span><br><span class="line">        validators[address] = balance</span><br><span class="line">        print(validators)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            announce_winner_t = threading.Thread(target=annouce_winner, args=(announcements, self.request,),</span><br><span class="line">                                                 daemon=<span class="keyword">True</span>)</span><br><span class="line">            announce_winner_t.start()</span><br><span class="line"></span><br><span class="line">            self.request.send(<span class="string">b"\nEnter a new BPM:"</span>)</span><br><span class="line">            bpm = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                bpm = int(bpm)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">del</span> validators[address]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># with My_Lock:</span></span><br><span class="line">            last_block = block_chain[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            new_block = generate_block(last_block, bpm, address)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_block_valid(new_block, last_block):</span><br><span class="line">                print(<span class="string">"new block is valid!"</span>)</span><br><span class="line">                candidate_blocks.put(new_block)</span><br><span class="line"></span><br><span class="line">            self.request.send(<span class="string">b"\nEnter a new BPM:\n"</span>)</span><br><span class="line"></span><br><span class="line">            annouce_blockchain_t = threading.Thread(target=annouce_blockchain, args=(self.request,), daemon=<span class="keyword">True</span>)</span><br><span class="line">            annouce_blockchain_t.start()</span><br></pre></td></tr></table></figure><p>这段代码，可能对大多数同学来说是有难度的，在这里我们采用了多线程的方式，同时为了能够让消息在线程间通信，我们使用了队列。 这里使用队列，也是为了我们的系统可以更好的拓展，后面如果可能，这一节的程序很容易拓展为分布式系统。 将多线程里面处理的任务拆分出去成独立的服务，然后用消息队列进行通信，就是一个简单的分布式系统啦。（是不是很激动？）</p><p>由于这里有难度，所以代码还是讲一讲吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># validator address</span></span><br><span class="line">    self.request.send(<span class="string">b"Enter token balance:"</span>)</span><br><span class="line">    balance = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        balance = int(balance)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line">    t = str(datetime.now())</span><br><span class="line">    address = sha256(t.encode()).hexdigest()</span><br><span class="line">    validators[address] = balance</span><br><span class="line">    print(validators)</span><br></pre></td></tr></table></figure><p>这一段就是我们提到的Node 客户端添加自己到候选人的代码，每链接一个客户端，就会添加一个候选人。 这里我们用添加的时间戳的hash来记录候选人。 当然也可以用其他的方式，比如我们代码里面的client_address </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">announce_winner_t = threading.Thread(target=annouce_winner, args=(announcements, self.request,),</span><br><span class="line">                                                daemon=<span class="keyword">True</span>)</span><br><span class="line">        announce_winner_t.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annouce_winner</span><span class="params">(announcements, request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param announcements:</span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg = announcements.get(block=<span class="keyword">False</span>)</span><br><span class="line">            request.send(msg.encode())</span><br><span class="line">            request.send(<span class="string">b'\n'</span>)</span><br><span class="line">        <span class="keyword">except</span> Empty:</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>然后接下来我们起了一个线程去广播获得记账权的节点信息到所有节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.request.send(<span class="string">b"\nEnter a new BPM:"</span>)</span><br><span class="line">            bpm = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                bpm = int(bpm)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">del</span> validators[address]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># with My_Lock:</span></span><br><span class="line">            last_block = block_chain[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            new_block = generate_block(last_block, bpm, address)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_block_valid(new_block, last_block):</span><br><span class="line">                print(<span class="string">"new block is valid!"</span>)</span><br><span class="line">                candidate_blocks.put(new_block)</span><br></pre></td></tr></table></figure><p>根据节点输入的BPM值生成一个区块，并校验区块的有效性。 将有效的区块放到候选区块当中，等待记账人将区块添加到链上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">annouce_blockchain_t = threading.Thread(target=annouce_blockchain, args=(self.request,), daemon=<span class="keyword">True</span>)</span><br><span class="line">        annouce_blockchain_t.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annouce_blockchain</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        time.sleep(<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">with</span> My_Lock:</span><br><span class="line">            output = json.dumps(block_chain)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request.send(output.encode())</span><br><span class="line">            request.send(<span class="string">b'\n'</span>)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后起一个线程，同步区块链到所有节点。</p><p>看完了，节点跟Server交互的部分，接下来是最重要的部分，</p><h2 id="POS算法实现"><a href="#POS算法实现" class="headerlink" title="POS算法实现"></a>POS算法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick_winner</span><span class="params">(announcements)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择记账人</span></span><br><span class="line"><span class="string">    :param announcements:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">with</span> My_Lock:</span><br><span class="line">            temp = temp_blocks</span><br><span class="line"></span><br><span class="line">        lottery_pool = []  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> temp:</span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> temp:</span><br><span class="line">                <span class="keyword">if</span> block[<span class="string">"Validator"</span>] <span class="keyword">not</span> <span class="keyword">in</span> lottery_pool:</span><br><span class="line">                    set_validators = validators</span><br><span class="line">                    k = set_validators.get(block[<span class="string">"Validator"</span>])</span><br><span class="line">                    <span class="keyword">if</span> k:</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                            lottery_pool.append(block[<span class="string">"Validator"</span>])</span><br><span class="line"></span><br><span class="line">            lottery_winner = choice(lottery_pool)</span><br><span class="line">            print(lottery_winner)</span><br><span class="line">            <span class="comment"># add block of winner to blockchain and let all the other nodes known</span></span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> temp:</span><br><span class="line">                <span class="keyword">if</span> block[<span class="string">"Validator"</span>] == lottery_winner:</span><br><span class="line">                    <span class="keyword">with</span> My_Lock:</span><br><span class="line">                        block_chain.append(block)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># write message in queue.</span></span><br><span class="line">                    msg = <span class="string">"\n&#123;0&#125; 赢得了记账权利\n"</span>.format(lottery_winner)</span><br><span class="line">                    announcements.put(msg)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> My_Lock:</span><br><span class="line">            temp_blocks.clear()</span><br></pre></td></tr></table></figure><p>这里我们用pick_winner 来选择记账权利，我们根据token数量构造了一个列表。 一个人获得记账权利的概率为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = mount[&apos;NodeA&apos;]/mount[&apos;All&apos;]</span><br></pre></td></tr></table></figure></p><p>文字描述就是其token数目在总数中的占比。 比如总数有100个，他有10个，那么其获得记账权的概率就是0.1， 到这里核心的部分就写的差不多了，接下来，我们来添加节点，开始测试吧 </p><h1 id="测试POS的记账方式"><a href="#测试POS的记账方式" class="headerlink" title="测试POS的记账方式"></a>测试POS的记账方式</h1><p>在测试之前，起始还有一部分工作要做，前面我们的run方法需要完善下，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># create a genesis block</span></span><br><span class="line">    t = str(datetime.now())</span><br><span class="line">    genesis_block = &#123;</span><br><span class="line">        <span class="string">"Index"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"Timestamp"</span>: t,</span><br><span class="line">        <span class="string">"BPM"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"PrevHash"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"Validator"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    genesis_block[<span class="string">"Hash"</span>] = calculate_hash(genesis_block)</span><br><span class="line">    print(genesis_block)</span><br><span class="line">    block_chain.append(genesis_block)</span><br><span class="line"></span><br><span class="line">    thread_canditate = threading.Thread(target=candidate, args=(candidate_blocks,), daemon=<span class="keyword">True</span>)</span><br><span class="line">    thread_pick = threading.Thread(target=pick_winner, args=(announcements,), daemon=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    thread_canditate.start()</span><br><span class="line">    thread_pick.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># start a tcp server</span></span><br><span class="line">    serv = ThreadingTCPServer((<span class="string">''</span>, <span class="number">9090</span>), HandleConn)</span><br><span class="line">    serv.serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">candidate</span><span class="params">(candidate_blocks)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param candidate_blocks:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            candi = candidate_blocks.get(block=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">except</span> Empty:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp_blocks.append(candi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><h1 id="添加节点连接到TCPServer"><a href="#添加节点连接到TCPServer" class="headerlink" title="添加节点连接到TCPServer"></a>添加节点连接到TCPServer</h1><p>为了充分减少程序的复杂性，tcp client我们这里就不实现了，可以放在后面拓展部分。 毕竟我们这个系统是很容易扩展的，后面我们拆分了多线程的部分，在实现tcp client就是一个完整的分布式系统了。</p><p>所以，我们这里用linux自带的命令 nc，不知道nc怎么用的同学可以google或者 man nc<br><img src="https://diycode.b0.upaiyun.com/photo/2018/de1ec95397b1f627c1ded8fc3ac256e1.png" alt=""></p><ul><li>启动服务    运行 python pos.py  </li><li>打开3个终端</li><li>分别输入下面命令<ul><li>nc localhost 9090</li></ul></li></ul><p>终端如果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter token balance:</span><br></pre></td></tr></table></figure></p><p>说明你client已经链接服务器ok啦.</p><h1 id="测试POS的记账方式-1"><a href="#测试POS的记账方式-1" class="headerlink" title="测试POS的记账方式"></a>测试POS的记账方式</h1><p>接下来依次按照提示操作。 balance可以按心情来操作，因为这里是测试，我们输入100，<br>紧接着会提示输入BPM，我们前面提到过，输入BPM是为了生成Block，那么就输入吧，随便输入个9. ok， 接下来就稍等片刻，等待记账。<br>输出如同所示<br><img src="https://diycode.b0.upaiyun.com/photo/2018/4eee010dfd46e7672d48d063b08cae47.png" alt=""><br>依次在不同的终端，根据提示输入数字，等待消息同步。</p><h1 id="生成区块链"><a href="#生成区块链" class="headerlink" title="生成区块链"></a>生成区块链</h1><p>下面是我这边获得的3个block信息。<br><img src="https://diycode.b0.upaiyun.com/photo/2018/1e5f93c93cc2bc5443902b89abd4ac02.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在上面的代码中，我们实现了一个完整的基于POS算法记账的链，当然这里有许多值得扩展与改进的地方。</p><ul><li>python中多线程开销比较大，可以改成协程的方式</li><li>TCP建立的长链接是基于TCPServer，是中心化的方式，可以改成P2P对等网络</li><li>链的信息不够完整</li><li>系统可以拓展成分布式，让其更健壮</li></ul><p>大概列了以上几点，其他还有很多可以拓展的地方，感兴趣的朋友可以先玩玩， 后者等到我们后面的教程。 （广告打的措手不及，哈哈）</p><p>当然了，语言不是重点，所以在这里，我也实现了go语言的版本<a href="https://github.com/csunny/argo/tree/master/src/pos" target="_blank" rel="noopener">源码地址</a></p><p>go语言的实现感觉要更好理解一点，也显得要优雅一点。这也是为什么go语言在分布式领域要更抢手的原因之一吧！</p><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><ul><li><a href="https://github.com/csunny/py-bitcoin/" target="_blank" rel="noopener">https://github.com/csunny/py-bitcoin/</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://medium.com/@mycoralhealth/code-your-own-proof-of-stake-blockchain-in-go-610cd99aa658" target="_blank" rel="noopener">https://medium.com/@mycoralhealth/code-your-own-proof-of-stake-blockchain-in-go-610cd99aa658</a></li></ul><p>我的<strong><a href="https://xiaozhuanlan.com/eosio" target="_blank" rel="noopener">专栏</a></strong>专注区块链底层技术开发，P2P网络、加密技术、MerkleTree、DAG、DHT等等，另外对于分布式系统的学习也很有帮助。欢迎大家交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区块链中的共识算法&quot;&gt;&lt;a href=&quot;#区块链中的共识算法&quot; class=&quot;headerlink&quot; title=&quot;区块链中的共识算法&quot;&gt;&lt;/a&gt;区块链中的共识算法&lt;/h1&gt;&lt;p&gt;在比特币公链架构解析中，就曾提到过为了实现去中介化的设计，比特币设计了一套共识协议，并通过此协议来保证系统的稳定性和防攻击性。 并且我们知道，截止目前使用最广泛，也是最被大家接受的共识算法，是我们先前介绍过的POW(proof of work)&lt;a href=&quot;https://learnblockchain.cn/2017/11/04/bitcoin-pow/&quot;&gt;工作量证明算法&lt;/a&gt;。目前市值排名前二的比特币和以太坊也是采用的此算法。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://learnblockchain.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/bitcoin/"/>
    
    
      <category term="区块链" scheme="https://learnblockchain.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="权益证明" scheme="https://learnblockchain.cn/tags/%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/"/>
    
      <category term="Python" scheme="https://learnblockchain.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>什么是EOS（柚子）</title>
    <link href="https://learnblockchain.cn/2018/07/17/whatiseos/"/>
    <id>https://learnblockchain.cn/2018/07/17/whatiseos/</id>
    <published>2018-07-17T06:25:44.000Z</published>
    <updated>2018-07-31T02:40:09.016Z</updated>
    
    <content type="html"><![CDATA[<p>是时候给写写EOS了，现在EOS主网已经上线，尽管我个人不是很喜欢EOS项目（不过也一直在关注EOS），但是不可否认EOS这个争议性很大的项目给区块链世界带来的变化。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，如果了解过比特币及以太坊，可以更好的理解本文。欢迎订阅专栏：<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a><br>指引你从头开始学区块链技术。</p><p>本文出现EOS是指EOS.io公链项目，不是指以太坊上的EOS Token。</p><h2 id="EOS-简介"><a href="#EOS-简介" class="headerlink" title="EOS 简介"></a>EOS 简介</h2><p>EOS: Enterprise Operation System 中文意思为：商业级区块链操作系统。</p><p>尽管以太坊创造性引入智能合约概念，极大的简化了区块链应用的开发，但以太坊平台依然有一个很大的限制，就是交易确认时间及交易吞吐量比较小，从而严重影响了以太坊进行商业应用。</p><blockquote><p>交易吞吐量有一个专门的词：TPS （transaction per second 每秒的交易量） 比特币的TPS 是大概7，并且最少几十分钟交易才能被确认，以太坊的TPS大概是20左右，交易的确认一般需要几分钟的时间。<br>不过比特币以太坊也在不断进化以提高TPS，比如比特币的闪电网络，以太坊的Sharding技术（分片）以及Plasma技术（分层）。</p></blockquote><p>EOS 项目的目标是建立可以承载商业级智能合约与应用的区块链基础设施，成为区块链世界的“底层操作系统”。<br>EOS通过<strong>石墨烯技术</strong>解决延迟和数据吞吐量问题，TPS可达到数千，交易的确认时间也只有数秒。同时声称未来使用并行链的方式，最高可以达到数百万TPS。</p><p>EOS 设计了一套账户权限管理系统，EOS不再使用的地址作为账户，可以直接使用字符作为账户名，并设计了一套的账户权限体系。</p><p>此外，在 EOS 上转账交易及运行智能合约不需要消耗 EOS代币。而是EOS 系统当中，抵押代币获取对应的资源，来执行相应交易，在EOS运行程序完全免费的说是不准确的。</p><blockquote><p>值的一提的是EOS项目其ICO也是基于以太坊<a href="https://learnblockchain.cn/2018/01/12/create_token/">ERC20 Token</a>进行的，其ICO 时间长达355天，作为一个当时还未上线的项目，融资额达到40亿美元是前所未有。</p></blockquote><h3 id="充满争议的技术天才BM"><a href="#充满争议的技术天才BM" class="headerlink" title="充满争议的技术天才BM"></a>充满争议的技术天才BM</h3><p>EOS的主要开发者为丹尼尔·拉瑞莫（Daniel Larimer）, 绰号BM(GitHub的昵称：ByteMaster), 它是EOS的项目方，BlockOne公司的CTO。<br>和V神一样，也是一个神奇的人物，网络上两人因理念不合有多次论战。BM有一句牛B 轰轰的话：我终生的使命，是致力于找到一些加密经济的解决方案，给所有人的财产、自由、平等带来保障。</p><p>BM成功创立过三个区块链项目：BitShares、Steem 以及EOS，是一个技术天才，也是一个多变的人。<br>2009年的BM也准备的数字货币一展身手，在其研究比特币之后，2010年BM提出了一些比特币的问题，并想要改进，结果比特币的创始人中本聪（Satoshi Nakamoto）怼会了他“If you don’t believe me or don’t get it, I don’t have time to try to convince you, sorry.”（懂不懂随你，我可没时间理你）。<br>于是BM开始着手创建自己的区块链项目，这就是2013年发布的 BitShares 比特股，世界上第一个数字货币去中心化交易所。</p><p>BitShares在2014年上线时，是当时的明星项目，也由于bug太多、糟糕的体验以及BM在进行个别版本升级的时候都不提供向下兼容，用户逐渐流失，更要命的是，BM利用自己超过1/3的记账节点，在没有达成社区共识的情况下，强行分叉增发了BitShares发行总量。尽管BM在技术提供了改进，发布了石墨烯工具集，不过最终社区投票决定让BM离开了BitShares。</p><p>离开BitShares的BM，于2016年创立了区块链项目Steem，去中心化社交网站Steemit就是基于Steem创建，在Steemit的运营期间，BM和Steemit的CEO Ned有过多次口水战。<br>在2017年，BM离开了自己创建的Steem项目（也许除了BM自己，没有人能知道他离开Steem的真实原因），选择与布鲁默联合创办了BlockOne公司打造EOS项目。</p><h2 id="石墨烯（Graphene）与-DPOS"><a href="#石墨烯（Graphene）与-DPOS" class="headerlink" title="石墨烯（Graphene）与 DPOS"></a>石墨烯（Graphene）与 DPOS</h2><p>和BitShares、Steem 一样，EOS底层使用的也是石墨烯技术，石墨烯是一个开源的区块链底层库，也出自BM之手，它采用的是 DPOS（Delegated Proof-of-Stake 股份授权证明机制 ）的共识机制。<br>在比特币及以太坊网络中，任何人都可以参与记账，而DPOS为了提高出块速度TPS，限制了参与记账了人数，在DPOS中，记账者不在称为矿工，而是改称为见证人 Witness，现在EOS中，又有一个新词：Block Producer，简称BP，大家翻译为超级节点（本文中依旧会使用见证人这个词，超级节点更像是一个市场营销用词）。</p><p>在EOS中，见证人的个数是21个，BitShares中是101个，BitShares的出块时间打开是 1.5秒，在EOS中，出块时间提高到了0.5秒。</p><p>和Pow及Pos共识机制矿工可以自由选择参与挖矿不同，DPOS下节点需要参与见证人选举，只有赢得选举的节点才能负责出块，在EOS中，赢得选举21个节点见证人轮流出块。<br>另外还有100个备用见证人（候选节点），在21个见证人出现问题后做替补。EOS的发行总量是10亿， 见证人在完成打包交易区块后，可以领取到区块的奖励，区块的奖励来自对发行量的通胀增发，通胀率每年接近5%。</p><h2 id="BM特色的去中心化"><a href="#BM特色的去中心化" class="headerlink" title="BM特色的去中心化"></a>BM特色的去中心化</h2><p>我个人理解的区块链，它最大的革命性就是他的中立性，其运行不应该受到任何人的干扰，在POW共识中，矿工、项目方（开发者）以及交易方他们是相互独立的存在。</p><p>在EOS中，BM本人拥有巨量的选票，他可以在一定程度上左右见证人的选举，同时BM还为EOS制定了宪法，要求所有的见证人必须遵照宪法。因此BM某种程度上可以左右EOS系统的运行。</p><p>本文是个人对EOS的理解，受我自己视野局限也许理解有偏差，欢迎大家批准指正，我的微信： xlbxiong。</p><h2 id="EOS相关资料："><a href="#EOS相关资料：" class="headerlink" title="EOS相关资料："></a>EOS相关资料：</h2><ul><li><a href="https://developers.eos.io/" target="_blank" rel="noopener">EOS开发者资源</a></li><li><a href="https://eos.io" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://github.com/EOSIO" target="_blank" rel="noopener">Github 代码</a></li></ul><p>我们为区块链爱者这提供了系统的区块链视频教程，觉得文章学习不过瘾的同学可以戳<a href="https://learnblockchain.cn/course/">区块链视频教程</a>。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是时候给写写EOS了，现在EOS主网已经上线，尽管我个人不是很喜欢EOS项目（不过也一直在关注EOS），但是不可否认EOS这个争议性很大的项目给区块链世界带来的变化。&lt;/p&gt;
    
    </summary>
    
      <category term="EOS" scheme="https://learnblockchain.cn/categories/EOS/"/>
    
    
      <category term="EOS入门" scheme="https://learnblockchain.cn/tags/EOS%E5%85%A5%E9%97%A8/"/>
    
      <category term="柚子" scheme="https://learnblockchain.cn/tags/%E6%9F%9A%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>搭建智能合约开发环境Remix IDE及使用</title>
    <link href="https://learnblockchain.cn/2018/06/07/remix-ide/"/>
    <id>https://learnblockchain.cn/2018/06/07/remix-ide/</id>
    <published>2018-06-07T02:56:04.000Z</published>
    <updated>2018-07-31T02:39:48.191Z</updated>
    
    <content type="html"><![CDATA[<p>目前开发智能的IDE， 首推还是Remix, 而Remix<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a>, 总是由于各种各样的（网络）原因无法使用，本文就来介绍一下如何在本地搭建智能合约开发环境remix-ide并介绍Remix的使用。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Remix 是以太坊智能合约编程语言Solidity IDE，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果还不了解，建议先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>。</p><h2 id="Remix-IDE-介绍"><a href="#Remix-IDE-介绍" class="headerlink" title="Remix IDE 介绍"></a>Remix IDE 介绍</h2><p>Remix IDE 是一款基于浏览器的IDE，跟有些开发聊的时候，发现有一些同学对浏览器的IDE，有一些偏见，其实Atom编辑器就是基于web技术开发的一款编辑器（Atom可以看做一个没有地址栏的浏览器），其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。</p><p>Remix IDE的功能全面（传统IDE有的功能这里都有），比如：</p><ol><li>代码提示补全，代码高亮</li><li>代码警告、错误提示</li><li>运行日志输出</li><li>代码调试</li><li>…</li></ol><h2 id="Remix-IDE-安装"><a href="#Remix-IDE-安装" class="headerlink" title="Remix IDE 安装"></a>Remix IDE 安装</h2><blockquote><p>更新： Remix 现在提供了一个APP, 叫Remix APP， 如果是Mac 电脑，可以直接使用其提供的发布包，地址为：<a href="https://github.com/horizon-games/remix-app/releases" target="_blank" rel="noopener">https://github.com/horizon-games/remix-app/releases</a></p></blockquote><p>如果你有很好的网络环境，可以直接访问Remix<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a>。<br>要不能还是还是像我一样老老实实把Remix IDE安装在本地，我发现要想成功安装选择对应的版本很关键，具体的版本要求如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node --version</span><br><span class="line">v7<span class="number">.10</span><span class="number">.1</span></span><br><span class="line">$ npm --version</span><br><span class="line"><span class="number">4.2</span><span class="number">.0</span></span><br><span class="line">$ nvm --version</span><br><span class="line"><span class="number">0.33</span><span class="number">.11</span></span><br></pre></td></tr></table></figure><h3 id="nvm-安装"><a href="#nvm-安装" class="headerlink" title="nvm 安装"></a>nvm 安装</h3><p>nvm 是一个node 版本工具，我们可以使用nvm来安装不同版本的node。<br>nvm 官方<a href="https://github.com/creationix/nvm/blob/master/README.md" target="_blank" rel="noopener">安装方法</a>如下：</p><ol><li><p>命令行中输入：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br></pre></td></tr></table></figure></li><li><p>在当前用户profile文件，如（~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc）添加加载nvm的脚本：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span><br></pre></td></tr></table></figure></li><li><p>重启下命令行，输入nvm 试试，应该可以看到 nvm 命令的帮助</p></li></ol><h3 id="使用nvm-安装node"><a href="#使用nvm-安装node" class="headerlink" title="使用nvm 安装node"></a>使用nvm 安装node</h3><p>因为Remix IDE 要求使用node 7.10.1, 命令行输入一下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 7</span><br></pre></td></tr></table></figure><p>安装完成之后，使用node –version 和 npm –version检查下版本号，是否和刚刚列出版本要求一致，在版本一值的qing</p><h3 id="命令行安装Remix-ide"><a href="#命令行安装Remix-ide" class="headerlink" title="命令行安装Remix ide"></a>命令行安装Remix ide</h3><p><strong>方法1</strong><br>直接使用npm安装，这也是我安装使用的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install remix-ide -g</span><br><span class="line">remix-ide</span><br></pre></td></tr></table></figure></p><p>如果出现错误：<br>Error: EACCES: permission denied, access ‘/usr/local/lib/node_modules’<br>可以尝试用以下方法解决：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们使用的是正确的node 和npm 版本的话，应该都可以安装成功，安装成功之后，remix-ide命令用来启动ide.</p><p><strong>方法2</strong><br>remix-ide的github 上还提供了另一个方法进行安装，通过clone 代码来安装，方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ethereum/remix-ide.git</span><br><span class="line"><span class="built_in">cd</span> remix-ide</span><br><span class="line">npm install</span><br><span class="line">npm run setupremix  <span class="comment"># this will clone https://github.com/ethereum/remix for you and link it to remix-ide</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h2 id="Remix-ide-使用"><a href="#Remix-ide-使用" class="headerlink" title="Remix ide 使用"></a>Remix ide 使用</h2><p>Remix IDE 默认是使用8080端口启动的，启动之后在浏览器打开：<code>http://localhost:8080/</code>, 如图：</p><p><img src="/images/remix-setup.jpg" alt=""></p><p>和大多数IDE一样，最左边是文件浏览，中间是代码编辑区域，右边是功能区域，下边是日志区域。<br>在右侧的功能区域，常用的是<code>Compile</code>、<code>Run</code>及<code>Debuger</code>几个标签页（Tab）。</p><p>在<code>Compile</code>页，会动态的显示当前编辑区域合约的编译信息，如显示错误和警告。编译的直接码信息及ABI接口可以通过点击<code>Details</code>查看到。<br>在<a href="https://learnblockchain.cn/2017/11/24/init-env/">这篇文章里</a> 也有截图说明。<br>在<code>Run</code>页，可以部署合约，以及调用合约函数等，使用非常简单，我们前面也有多篇文章讲解。<br><code>Debuger</code>页在下面调试一节单独讲解。</p><h3 id="Remix-ide-加载本地磁盘文件"><a href="#Remix-ide-加载本地磁盘文件" class="headerlink" title="Remix ide 加载本地磁盘文件"></a>Remix ide 加载本地磁盘文件</h3><p>这是一个非常用的功能，但发现使用的人非常少，通过加载本地磁盘文件，就可以方便代码管理工具（如 git）管理我们的合约代码。<br>我详细介绍下如何这个功能怎么使用？</p><blockquote><p>使用在线版本的Remix可以使用这个功能， 不过需要安装一下<a href="https://github.com/ethereum/remixd" target="_blank" rel="noopener">remixd</a>, 安装使用命令<code>npm install -g remixd</code>。</p></blockquote><ol><li><p>在需要的本地合约代码的目录下启动<code>remix-ide</code>, Remix IDE 会自动把当前目录做为共享目录。如果是使用在线的Remix，需要使用命令<code>remixd -s shared-folder</code> 来指定共享目录。</p></li><li><p>加载共享目录，在文件浏览区域上有，有这样一个图标，他用来加载本地共享目录，如图：<br><img src="https://learnblockchain.cn/images/remixd_connectionok.png" alt=""></p></li></ol><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在合约编写过程中，合约调试是必不可少的一部分，为了模拟调试的过程，我故意在代码中加入一ge错误的逻辑代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line">​</span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    </span><br><span class="line">    uint storedData;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData += x;    <span class="comment">// 错误的，多加了一个加号</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入了错误的逻辑之后，我第2次调用set函数，合约状态变量的值，可能会出错（如果第一次不是用参数0去调用的话）。<br>注意如果需要调试合约，在部署合约的环境应该选择：JavaScript VM。</p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>在我们每次执行一个交易（不管是方式调用还是函数执行）的时候，在日志都会输出一条记录，如图：<br><img src="https://learnblockchain.cn/images/remix-debug-console.png" alt=""></p><p>点击上图中的“Debug”按钮，在Remix右侧的功能区域会切换到调试面板，如下图：<br><img src="/images/remix-debug-panel.png" alt=""><br>调试过程过程中，有下面几项需要重点关注：</p><ul><li><p>Transactions: 可以查看交易及交易的执行过程，并且提供了7个调试的按钮，如下图：<br><img src="https://learnblockchain.cn/images/remix-debug-buttons.png" alt=""></p><p>  为了方便介绍，我为每个按钮编了号，每个按钮的含义是：</p><ol><li>后退一步（不进入函数内部）</li><li>后退一步（进入函数内部）</li><li>前进一步（进入函数内部）</li><li>前进一步（不进入函数内部）</li><li>跳到上一个断点</li><li>跳出当前调用</li><li>跳到下一个断点</li></ol></li><li>Solidity Locals：显示当前上下文的局部变量的值， 如图：</li></ul><p><img src="https://learnblockchain.cn/images/remix-debug-locals.png" alt=""></p><ul><li>Solidity State： 显示当前执行合约的状态变量，如下图:<br><img src="https://learnblockchain.cn/images/remix-debug-state.png" alt=""></li></ul><p>在本例中，我们跟踪运行步骤的时候，可以看到局部变量的值为2，赋值给状态变量之后，状态变量的值更改为了3，所以可以判断运行当前语句的时候出错了。</p><ul><li>Step detail： 显示当前步骤的gas详情等，如下图:<br><img src="https://learnblockchain.cn/images/remix-debug-gas.png" alt=""></li></ul><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>这部分为小专栏读者准备，欢迎订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/ethereum/remix-ide" target="_blank" rel="noopener">remix-ide github</a></li><li><a href="http://remix.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Remix Document</a></li></ol><p>我们还为区块链技术爱好者提供了系统的区块链视频教程，觉得文章学习不过瘾的同学可以戳<a href="https://wiki.learnblockchain.cn/course/beginner.html" target="_blank" rel="noopener">入门视频教程</a>及<a href="https://wiki.learnblockchain.cn/course/solidity.html" target="_blank" rel="noopener">以太坊智能合约开发</a>。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你学习区块链中遇到问题，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>问答社区，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了300多位区块链技术牛人和爱好者。</p><!---在本例中，我们的代码比较简单，执行的不多，可以不用设置断点，如果代码比较多，这可以设置断点，利用上面介绍的第7个按钮快速的调转到断点处，设置断点的方法很简单，在编辑区域，点击代码的行号，就可以在当前行设置一个断点，如下图：![](/images/remix-debug-break.png)上图在第8行出设置了一个断点，成功设置断点会在行号处，加上一个色块来标示断点。取消断点的方式是，再次点击断点处。有一点需要注意一下，如果在声明变量的地方设置断点，这断点可能会触发两次，第一次是初始化为0，第二次是赋实际的值。-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前开发智能的IDE， 首推还是Remix, 而Remix&lt;a href=&quot;https://remix.ethereum.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;, 总是由于各种各样的（网络）原因无法使用，本文就来介绍一下如何在本地搭建智能合约开发环境remix-ide并介绍Remix的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="IDE" scheme="https://learnblockchain.cn/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Solidity 教程系列11 - 视图函数、虚函数讲解</title>
    <link href="https://learnblockchain.cn/2018/05/17/solidity-functions/"/>
    <id>https://learnblockchain.cn/2018/05/17/solidity-functions/</id>
    <published>2018-05-17T14:16:29.000Z</published>
    <updated>2018-08-09T02:58:50.242Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第11篇 - Solidity 视图函数、虚函数讲解。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="视图函数（View-Functions）"><a href="#视图函数（View-Functions）" class="headerlink" title="视图函数（View Functions）"></a>视图函数（View Functions）</h2><p>一个函数如果它不修改状态变量，应该声明为<strong>view</strong>函数，不过下面几种情况认为是修改了状态：</p><ol><li>写状态变量</li><li>触发事件（events）</li><li>创建其他的合约</li><li>call调用附加了以太币</li><li>调用了任何没有<strong>view</strong>或<strong>pure</strong>修饰的函数</li><li>使用了低级别的调用（low-level calls）</li><li>使用了包含特定操作符的内联汇编</li></ol><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>) + now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误做法，虽然可以编译通过</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">df</span>(<span class="params">uint a</span>) <span class="title">public</span> <span class="title">view</span>  </span>&#123;</span><br><span class="line">        data = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个地方需要注意一下：</p><ol><li>声明为<strong>view</strong> 和声明为<strong>constant</strong>是等价的，constant是view的别名，constant在计划Solidity 0.5.0版本之后会弃用（constant这个词有歧义，view 也更能表达返回值可视）。</li><li>访问函数都被标记为view。</li></ol><p>当前编译器并未强制要求声明为view，但建议大家对于不会修改状态的函数的标记为view。</p><h2 id="纯函数（Pure-Functions）"><a href="#纯函数（Pure-Functions）" class="headerlink" title="纯函数（Pure Functions）"></a>纯函数（Pure Functions）</h2><p>函数可以声明为<strong>view</strong>，表示它即不读取状态，也不修改状态，除了上一节介绍的几种修改状态的情况，以下几种情况被认为是读取了状态：</p><ol><li>读状态变量</li><li>访问了 <strong>this.balance</strong> 或 <strong>\<address>.balance</address></strong></li><li>访问了<strong>block</strong>, <strong>tx</strong>, <strong>msg</strong> 的成员 (msg.sig 和 msg.data除外).</li><li>调用了任何没有<strong>pure</strong>修饰的函数</li><li>使用了包含特定操作符的内联汇编</li></ol><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管view 和 pure 修饰符编译器并未强制要求使用，view 和 pure 修饰也不会带来gas 消耗的改变，但是更好的编码习惯让我们跟容易发现智能合约中的错误。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/develop/contracts.html#functions" target="_blank" rel="noopener">官方文档-函数</a></p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第11篇 - Solidity 视图函数、虚函数讲解。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/Solidity/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>详解 Solidity 事件Event - 完全搞懂事件的使用</title>
    <link href="https://learnblockchain.cn/2018/05/09/solidity-event/"/>
    <id>https://learnblockchain.cn/2018/05/09/solidity-event/</id>
    <published>2018-05-09T12:37:03.000Z</published>
    <updated>2018-09-04T07:57:23.027Z</updated>
    
    <content type="html"><![CDATA[<p>很多同学对Solidity 中的Event有疑问，这篇文章就来详细的看看Solidity 中Event到底有什么用？</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>，另外<br>本文在监听合约事件是对上一篇<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>进行补充，如果阅读了上一篇可以更好的理解本文。</p><h2 id="什么是事件Evnet"><a href="#什么是事件Evnet" class="headerlink" title="什么是事件Evnet"></a>什么是事件Evnet</h2><p>事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并记录到区块链中.<br>来捋这个关系：区块链是打包一系列交易的区块组成的链条，每一个交易“收据”会包含0到多个日志记录，日志代表着智能合约所触发的事件。</p><p><strong>在DAPP的应用中，如果监听了某事件，当事件发生时，会进行回调。</strong><br>不过要注意：日志和事件在合约内是无法被访问的，即使是创建日志的合约。</p><p>在Solidity 代码中，使用event 关键字来定义一个事件，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event EventName(address bidder, uint amount);</span><br></pre></td></tr></table></figure><p>这个用法和定义函数式一样的，并且事件在合约中同样可以被继承。触发一个事件使用emit(说明，之前的版本里并不需要使用emit)，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emit EventName(msg.sender, msg.value);</span><br></pre></td></tr></table></figure><p>触发事件可以在任何函数中调用，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testEvent</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发一个事件</span></span><br><span class="line">     emit EventName(msg.sender, msg.value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>通过上面的介绍，可能大家还是不清楚事件有什么作用，如果你跟过<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>这篇文章，你会发现点击”Updata Info”按钮之后，虽然调用智能合约成功，但是当前的界面并没有得到更新。<br>使用事件监听，就可以很好的解决这个问题，让看看如何实现。</p><h3 id="修改合约，定义事件及触发事件"><a href="#修改合约，定义事件及触发事件" class="headerlink" title="修改合约，定义事件及触发事件"></a>修改合约，定义事件及触发事件</h3><p>先回顾一下合约代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract InfoContract &#123;</span><br><span class="line">    </span><br><span class="line">   string fName;</span><br><span class="line">   uint age;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">       fName = _fName;</span><br><span class="line">       age = _age;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">string, uint</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (fName, age);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，需要定义一个事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">event Instructor(</span><br><span class="line">      string name,</span><br><span class="line">      uint age</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>这个事件中，会接受两个参数：name 和  age , 也就是需要跟踪的两个信息。</p><p>然后，需要在setInfo函数中，触发Instructor事件，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    fName = _fName;</span><br><span class="line">    age = _age;</span><br><span class="line">    emit Instructor(_fName, _age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>, 点击”Updata Info”按钮之后，会调用setInfo函数，函数时触发Instructor事件。</p><h3 id="使用Web3监听事件，刷新UI"><a href="#使用Web3监听事件，刷新UI" class="headerlink" title="使用Web3监听事件，刷新UI"></a>使用Web3监听事件，刷新UI</h3><p>现在需要使用Web3监听事件，刷新UI。<br>先回顾下之前的使用Web3和智能合约交互的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">"http://localhost:7545"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> infoContract = web3.eth.contract(ABI INFO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> info = infoContract.at(<span class="string">'CONTRACT ADDRESS'</span>);</span><br><span class="line"></span><br><span class="line">    info.getInfo(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!error)</span><br><span class="line">            &#123;</span><br><span class="line">                $(<span class="string">"#info"</span>).html(result[<span class="number">0</span>]+<span class="string">' ('</span>+result[<span class="number">1</span>]+<span class="string">' years old)'</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(result);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">"#button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        info.setInfo($(<span class="string">"#name"</span>).val(), $(<span class="string">"#age"</span>).val());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>现在可以不需要 info.getInfo()来获取信息，而改用监听事件获取信息，先定义一个变量引用事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor();</span><br></pre></td></tr></table></figure><p>然后使用<strong>.watch()</strong>方法来添加一个回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">instructorEvent.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            &#123;</span><br><span class="line">                $(<span class="string">"#info"</span>).html(result.args.name + <span class="string">' ('</span> + result.args.age + <span class="string">' years old)'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(error);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>代码更新之后，可以在浏览器查看效果，这是点击”Updata Info”按钮之后，会及时更新界面，如图：<br><img src="/images/solidity_event.jpg" alt=""></p><p>完整的代码请订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="事件高级用法-过滤器"><a href="#事件高级用法-过滤器" class="headerlink" title="事件高级用法-过滤器"></a>事件高级用法-过滤器</h2><p>有时我们会有这样的需求：获取当前所有姓名及年龄记录，或者是，要过滤出年龄28岁的记录，应该如何做呢？<br>以及另外一个常见的场景：想要获取到代币合约中所有的转账记录，也同样需要使用事件过滤器功能，这部分内容请大家订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>阅读。</p><p>如果你想学习以太坊DApp开发，这门视频课程<a href="https://wiki.learnblockchain.cn/course/dapp.html" target="_blank" rel="noopener">以太坊DAPP开发实战</a>是你不错的选择。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://coursetro.com/posts/code/100/Solidity-Events-Tutorial---Using-Web3.js-to-Listen-for-Smart-Contract-Events" target="_blank" rel="noopener">https://coursetro.com/posts/code/100/Solidity-Events-Tutorial---Using-Web3.js-to-Listen-for-Smart-Contract-Events</a><br><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了300多位区块链技术牛人和爱好者。</p><!-- 有时我们会有这样的需求：获取当前所有姓名及年龄记录，应该如何做呢？实际上事件支持过滤器，可以从所有的区块中过滤出符合要求的事件，如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor(&#123;&#125;, &#123;<span class="attr">fromBlock</span>: <span class="number">0</span>, <span class="attr">toBlock</span>: <span class="string">'latest'</span>&#125;);</span><br></pre></td></tr></table></figure><p>或者是，要过滤出年龄28岁的记录，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor(&#123; <span class="string">'age'</span>: <span class="number">28</span>&#125;);</span><br></pre></td></tr></table></figure><p>比如，我们要获取到代币合约中，所有的转账记录， 就可以使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transferEvent = token.Transfer(&#123;&#125;, &#123;<span class="attr">fromBlock</span>: <span class="number">0</span>, <span class="attr">toBlock</span>: <span class="string">'latest'</span>&#125;)</span><br><span class="line"><span class="keyword">var</span> transferEvent.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// handle result.args.from  result.args.to</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> –&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多同学对Solidity 中的Event有疑问，这篇文章就来详细的看看Solidity 中Event到底有什么用？&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
      <category term="Event" scheme="https://learnblockchain.cn/tags/Event/"/>
    
      <category term="web3" scheme="https://learnblockchain.cn/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>智能合约最佳实践 之 Solidity 编码规范</title>
    <link href="https://learnblockchain.cn/2018/05/04/solidity-style-guide/"/>
    <id>https://learnblockchain.cn/2018/05/04/solidity-style-guide/</id>
    <published>2018-05-04T02:22:08.000Z</published>
    <updated>2018-05-07T06:42:11.127Z</updated>
    
    <content type="html"><![CDATA[<p>每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。</p><a id="more"></a><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="避免使用"><a href="#避免使用" class="headerlink" title="避免使用"></a>避免使用</h3><p>小写的l，大写的I，大写的O 应该避免在命名中单独出现，因为很容易产生混淆。</p><h3 id="合约、库、事件、枚举及结构体命名"><a href="#合约、库、事件、枚举及结构体命名" class="headerlink" title="合约、库、事件、枚举及结构体命名"></a>合约、库、事件、枚举及结构体命名</h3><p>  合约、库、事件及结构体命名应该使用单词首字母大写的方式，这个方式也称为：帕斯卡命名法或大驼峰式命名法，比如：SimpleToken， SmartBank， CertificateHashRepository，Player。</p><h3 id="函数、参数、变量及修饰器"><a href="#函数、参数、变量及修饰器" class="headerlink" title="函数、参数、变量及修饰器"></a>函数、参数、变量及修饰器</h3><p>函数、参数、变量及修饰器应该使用首单词小写后面单词大写的方式，这个方式也称为：（小）驼峰式命名法，是一种混合大小写的方式，如：</p><ul><li>函数名应该如：getBalance，transfer，verifyOwner，addMember。</li><li>参数和变量应该如：initialSupply，senderAddress，account，isPreSale。</li><li>修饰器应该如：onlyAfter，onlyOwner。</li></ul><h2 id="代码格式相关"><a href="#代码格式相关" class="headerlink" title="代码格式相关"></a>代码格式相关</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>使用空格（spaces）而不是Tab, 缩进应该是4个空格</p><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>合约之间应该有空行，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数之间应该有空行，例如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有实现的话，空行可以省去，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左括号应该跟定义在一行"><a href="#左括号应该跟定义在一行" class="headerlink" title="左括号应该跟定义在一行"></a>左括号应该跟定义在一行</h3><p>定义包括合约定义、函数定义、库定义、结构体定义等等，例如推荐使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> contract Coin &#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Coin</span><br><span class="line">&#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左括号应该跟条件控制在一行"><a href="#左括号应该跟条件控制在一行" class="headerlink" title="左括号应该跟条件控制在一行"></a>左括号应该跟条件控制在一行</h3><p>在使用if, else, while, for 时，推荐的写法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    ...;&#125;</span><br></pre></td></tr></table></figure><p>如果控制语句内只有一行，括号可省略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">    x += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但像下面一个语句有多方就不能省略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">    someArray.push(Coin(&#123;</span><br><span class="line">        name: <span class="string">'spam'</span>,</span><br><span class="line">        value: <span class="number">42</span></span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure><h3 id="表达式内的空格"><a href="#表达式内的空格" class="headerlink" title="表达式内的空格"></a>表达式内的空格</h3><ul><li><p>一个单行的表达里，在小括号、中括号、大括号里应该避免不必要的空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam(ham[<span class="number">1</span>], Coin(&#123;<span class="attr">name</span>: <span class="string">"ham"</span>&#125;));</span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam( ham[ <span class="number">1</span> ], Coin( &#123; <span class="attr">name</span>: <span class="string">"ham"</span> &#125; ) );</span><br></pre></td></tr></table></figure>有一种例外是，结尾的括号跟在结束的分号后面， 应该加一个空格，如下面的方式也是推荐的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleLine</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123; spam(); &#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>分号；前不应该有空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params">uint i, Coin coin</span>) <span class="title">public</span>;</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params">uint i , Coin coin</span>) <span class="title">public</span> ;</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p>不要为对齐添加不必要的空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line">long_variable = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x             = <span class="number">1</span>;</span><br><span class="line">y             = <span class="number">2</span>;</span><br><span class="line">long_variable = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>回退函数不应该有空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而不是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="控制每一行长度"><a href="#控制每一行长度" class="headerlink" title="控制每一行长度"></a>控制每一行长度</h3><p>每行不应该太长，最好在79（或99）个字符以内，函数的参数应该是单独的行，且只有一个缩进，例如推荐的方式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">                              longArgument2,</span><br><span class="line">                              longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1, longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">longArgument1,</span><br><span class="line">longArgument2,</span><br><span class="line">longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3);</span><br></pre></td></tr></table></figure><p>对应的赋值语句应该是这样写：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> thisIsALongNestedMapping[being][set][to_some_value] = someFunction(</span><br><span class="line">    argument1,</span><br><span class="line">    argument2,</span><br><span class="line">    argument3,</span><br><span class="line">    argument4</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1,</span><br><span class="line">                                                                   argument2,</span><br><span class="line">                                                                   argument3,</span><br><span class="line">                                                                   argument4);</span><br></pre></td></tr></table></figure><p>事件定义也应该遵循同样的原则，例如应该使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(</span><br><span class="line">    adress sender,</span><br><span class="line">    adress recipient,</span><br><span class="line">    uint256 publicKey,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes32[] options</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(</span><br><span class="line">    sender,</span><br><span class="line">    recipient,</span><br><span class="line">    publicKey,</span><br><span class="line">    amount,</span><br><span class="line">    options</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(adress sender,</span><br><span class="line">                        adress recipient,</span><br><span class="line">                        uint256 publicKey,</span><br><span class="line">                        uint256 amount,</span><br><span class="line">                        bytes32[] options);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(sender,</span><br><span class="line">                  recipient,</span><br><span class="line">                  publicKey,</span><br><span class="line">                  amount,</span><br><span class="line">                  options);</span><br></pre></td></tr></table></figure><h3 id="文件编码格式"><a href="#文件编码格式" class="headerlink" title="文件编码格式"></a>文件编码格式</h3><p>推荐使用utf-8 及 ASCII 编码</p><h3 id="引入文件应该在最上方"><a href="#引入文件应该在最上方" class="headerlink" title="引入文件应该在最上方"></a>引入文件应该在最上方</h3><p>建议使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"owned"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"owned"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数编写规范"><a href="#函数编写规范" class="headerlink" title="函数编写规范"></a>函数编写规范</h2><h3 id="函数的顺序"><a href="#函数的顺序" class="headerlink" title="函数的顺序"></a>函数的顺序</h3><p>在编写函数的时候，应该让大家容易找到构造函数，回退函数，官方推荐的的函数顺序是：</p><ol><li>构造函数</li><li>回退函数 (如果有)</li><li>外部函数（external）</li><li>公有函数(public)</li><li>内部函数(internal)</li><li>私有函数（private）</li></ol><p>同一类函数时，constant函数放在后面， 例如推荐方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> contract A &#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回退函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带有constant 外部函数 </span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是下面的函数顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> contract A &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="明确函数的可见性"><a href="#明确函数的可见性" class="headerlink" title="明确函数的可见性"></a>明确函数的可见性</h3><p>所有的函数（包括构造函数）应该在定义的时候明确函数的可见性，例如应该使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">explicitlyPublic</span>(<span class="params">uint val</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">implicitlyPublic</span>(<span class="params">uint val</span>) </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可见性应该在修饰符前面"><a href="#可见性应该在修饰符前面" class="headerlink" title="可见性应该在修饰符前面"></a>可见性应该在修饰符前面</h3><p>函数的可见性应该写在自定义的函数修饰符前面，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyowner</span> </span>&#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) <span class="title">onlyowner</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区分函数和事件"><a href="#区分函数和事件" class="headerlink" title="区分函数和事件"></a>区分函数和事件</h3><p>为了防止函数和事件（Event）产生混淆，声明一个事件使用大写并加入前缀（可使用LOG）。对于函数， 始终以小写字母开头，构造函数除外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议</span></span><br><span class="line">event Transfer() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议</span></span><br><span class="line">event LogTransfer() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量应该使用全大写及下划线分割大词的方式，如：MAX_BLOCKS，TOKEN_NAME， CONTRACT_VERSION。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/v0.4.23/style-guide.html" target="_blank" rel="noopener">Solidity style-guide</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>美链BEC合约漏洞技术分析</title>
    <link href="https://learnblockchain.cn/2018/04/25/bec-overflow/"/>
    <id>https://learnblockchain.cn/2018/04/25/bec-overflow/</id>
    <published>2018-04-25T02:13:07.000Z</published>
    <updated>2018-04-26T01:49:16.484Z</updated>
    
    <content type="html"><![CDATA[<p>这两天币圈链圈被美链BEC智能合约的漏洞导致代币价值几乎归零的事件刷遍朋友圈。这篇文章就来分析下BEC智能合约的漏洞</p><a id="more"></a><h2 id="漏洞攻击交易"><a href="#漏洞攻击交易" class="headerlink" title="漏洞攻击交易"></a>漏洞攻击交易</h2><p>我们先来还原下攻击交易，这个交易可以在这个<a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f" target="_blank" rel="noopener">链接</a>查询到。<br>我截图给大家看一下：<br><img src="https://learnblockchain.cn/images/BEC_transfer.jpg" alt=""></p><p>攻击者向两个账号转移57896044618…000.792003956564819968个BEC，相当于BEC凭空进行了一个巨大的增发，几乎导致BEC价格瞬间归零。<br>下面我们来分析下这个攻击过程。</p><h2 id="合约漏洞分析"><a href="#合约漏洞分析" class="headerlink" title="合约漏洞分析"></a>合约漏洞分析</h2><p>我们先来看看<a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" target="_blank" rel="noopener">BEC智能合约的代码</a>，<br>BEC在合约中加入一个批量转账的函数，它的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchTransfer</span>(<span class="params">address[] _receivers, uint256 _value</span>) <span class="title">public</span> <span class="title">whenNotPaused</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    uint cnt = _receivers.length;</span><br><span class="line">    uint256 amount = uint256(cnt) * _value;</span><br><span class="line">    <span class="built_in">require</span>(cnt &gt; <span class="number">0</span> &amp;&amp; cnt &lt;= <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">require</span>(_value &gt; <span class="number">0</span> &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(amount);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        balances[_receivers[i]] = balances[_receivers[i]].add(_value);</span><br><span class="line">        Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是，调用者传入若干个地址和转账金额，在经过一些条件检查之后，对msg.sender的余额进行减操作，对每一个对每一个传入的地址进行加操作，以实现BEC的转移。<br>问题出在 <code>uint256 amount = uint256(cnt) * _value;</code> 这句代码，当传入值<code>_value</code>过大时（接近uint256的取值范围的最大值），<code>uint256 amount = uint256(cnt) * _value</code>计算时会发生溢出，导致amount实际的值是一个非常小的数（此时amount不再是<code>cnt * _value</code>的实际值），amount很小，也使得后面对调用者余额校验可正常通过（即<code>require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount)</code>语句通过）。</p><p>我们来结合实际攻击交易使用的参数来分析一下：</p><p><img src="https://learnblockchain.cn/images/BEC_transfer_params.jpg" alt=""></p><p><code>batchTransfer</code>的参数<code>_value</code>值为16进制的<code>800000000000000000000...</code>，参数<code>_receivers</code>数组的大小为2，相乘之后刚好可超过uint256所能表示的整数大小上限，引发溢出问题<code>amount</code>实际的值为0，后面的转账操作实际上msg.sender的余额减0， 而对两个账号进行了加16进制的<code>800000000000000000000...</code>，最终的结果是相当于增发了2 * 16进制的<code>800000000000000000000...</code>。</p><p>实际上对于这种整数溢出漏洞，最简单的方法是采用 SafeMath 数学计算库来避免。有趣的是BEC智能合约代码中，其实其他的都使用了SafeMath， 而关键的<code>uint256 amount = uint256(cnt) * _value</code>却没有使用。<br>心痛程序员，也心痛韭菜。这句代码改为<code>uint256 amount = _value.mul(uint256(cnt));</code>就可以防止溢出问题</p><p>所以在做加减乘除的时候请记得一定使用：SafeMath，代码在<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" target="_blank" rel="noopener">这里</a></p><h2 id="溢出补充说明"><a href="#溢出补充说明" class="headerlink" title="溢出补充说明"></a>溢出补充说明</h2><p>溢出补充说明为小专栏订阅用户福利，小专栏的文章内介绍了什么时候会发生上溢，什么时候会发生下溢，并且给出了代码事例。<br>大家可请前往我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>阅读。</p><p>知识星球<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a></strong>做好的区块链技术问答社区，欢迎来提问，作为星球成员福利，成员可加入区块链技术付费交流群。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><!--Solidity最大可以处理256位数字, 最大值为 `2**256 - 1`, 对(`2**256 - 1`) 加1的结果会溢出归0。`2**255` 乘2也同样会溢出归0。对无符号类型最小值是零，对零做减1会得到 (`2**256 - 1`)。我们用一段代码验证一下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity <span class="number">0.4</span><span class="number">.20</span>;</span><br><span class="line">contract TestFlow &#123;</span><br><span class="line">    uint256 public zero = <span class="number">0</span>;</span><br><span class="line">    uint256 public max = <span class="number">2</span>**<span class="number">256</span> - <span class="number">1</span>;</span><br><span class="line">    uint256 public mm = <span class="number">2</span>**<span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subUnderFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  zero - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addOverFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  max + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mulOverFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  mm * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约部署和运行，之前已经经过很多次，我直接贴运行结果：<br><img src="https://learnblockchain.cn/images/BEC_transfer_flow.jpg" alt=""></p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天币圈链圈被美链BEC智能合约的漏洞导致代币价值几乎归零的事件刷遍朋友圈。这篇文章就来分析下BEC智能合约的漏洞&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Web3与智能合约交互实战</title>
    <link href="https://learnblockchain.cn/2018/04/15/web3-html/"/>
    <id>https://learnblockchain.cn/2018/04/15/web3-html/</id>
    <published>2018-04-15T13:24:16.000Z</published>
    <updated>2018-09-04T07:56:48.612Z</updated>
    
    <content type="html"><![CDATA[<p>Web3与智能合约交互实战</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在最初学习以太坊的时候，很多人都是自己创建以太坊节点后，使用geth与之交互。这种使用命令行交互的方法虽然让很多程序员感到兴奋（黑客帝国的既视感？），但不可能指望普通用户通过命令行使用Dapp。因此，我们需要一种友好的方式（比如一个web页面）来与智能合约交互，于是问题的答案就是<code>web3.js</code>。</p><h2 id="Web3-js"><a href="#Web3-js" class="headerlink" title="Web3.js"></a>Web3.js</h2><p><a href="https://web3js.readthedocs.io/en/1.0/" target="_blank" rel="noopener">Web3.js</a>是以太坊官方的Javascript API，可以帮助智能合约开发者使用HTTP或者IPC与本地的或者远程的以太坊节点交互。实际上就是一个库的集合，主要包括下面几个库：</p><ul><li><code>web3-eth</code>用来与以太坊区块链和智能合约交互</li><li><code>web3-shh</code>用来控制whisper协议与p2p通信以及广播</li><li><code>web3-bzz</code>用来与swarm协议交互</li><li><code>web3-utils</code>包含了一些Dapp开发有用的功能</li></ul><p>Web3与geth通信使用的是 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON-RPC</a> ，这是一种轻量级的RPC（Remote Procedure Call）协议，整个通信的模型可以抽象为下图。</p><p><img src="/images/Communication_Model.jpg" alt="Web3 Communication Model"></p><h2 id="搭建测试链"><a href="#搭建测试链" class="headerlink" title="搭建测试链"></a>搭建测试链</h2><p>在开发初期，我们并没有必要使用真实的公链，为了开发效率，一般选择在本地搭建测试链。在本文我们选择的<a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a>（在此之前使用的是testrpc，Ganache属于它的升级版），一个图形化测试软件（也有命令行版本），可以一键在本地搭建以太坊区块链测试环境，并且将区块链的状态通过图形界面显示出来，Ganache的运行界面如下图所示。</p><p><img src="/images/Ganache.png" alt="Ganache"></p><p>从图中可以看到Ganache会默认创建10个账户，监听地址是<code>http://127.0.0.1:7545</code>，可以实时看到<code>Current Block</code>、<code>Gas Price</code>、<code>Gas Limit</code>等信息。</p><h2 id="创建智能合约"><a href="#创建智能合约" class="headerlink" title="创建智能合约"></a>创建智能合约</h2><p>目前以太坊官方全力支持的智能合约开发环境是<a href="https://remix.ethereum.org" target="_blank" rel="noopener">Remix IDE</a>，我们在合约编辑页面编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract InfoContract &#123;</span><br><span class="line">    </span><br><span class="line">   string fName;</span><br><span class="line">   uint age;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">       fName = _fName;</span><br><span class="line">       age = _age;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">string, uint</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (fName, age);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，就是简单的给<code>name</code>和<code>age</code>变量赋值与读取，接下来切换到 run 的 tab 下，将<code>Environment</code>切换成<code>Web3 Provider</code>，并输入我们的测试链的地址<code>http://127.0.0.1:7545</code>，这里对这三个选项做一简单说明：</p><ul><li><code>Javascript VM</code>：简单的Javascript虚拟机环境，纯粹练习智能合约编写的时候可以选择</li><li><code>Injected Web3</code>：连接到嵌入到页面的Web3，比如连接到MetaMask</li><li><code>Web3 Provider</code>：连接到自定义的节点，如私有的测试网络。</li></ul><p>如果连接成功，那么在下面的<code>Account</code>的选项会默认选择 Ganache 创建的第一个账户地址。接下来我们点击<code>Create</code>就会将我们的智能合约部署到我们的测试网中。接下来 Remix 的页面不要关闭，在后面编写前端代码时还要用到合约的地址以及<code>ABI</code>信息。</p><h2 id="安装Web3"><a href="#安装Web3" class="headerlink" title="安装Web3"></a>安装Web3</h2><p>在这之前，先在终端创建我们的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir info</span><br><span class="line">&gt; <span class="built_in">cd</span> info</span><br></pre></td></tr></table></figure><p>接下来使用 node.js 的包管理工具 npm 初始化项目，创建<code>package.json</code> 文件，其中保存了项目需要的相关依赖环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm init</span><br></pre></td></tr></table></figure><p>一路按回车直到项目创建完成。最后，运行下面命令安装web.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm install web3</span><br></pre></td></tr></table></figure><blockquote><p>   <em>注意：</em> 在实际安装过程中我发现web3在安装完成后并没有 <code>/node_modules/web3/dist/we3.min.js</code> 文件，这个问题在 <a href="https://github.com/ethereum/web3.js/issues/1041" target="_blank" rel="noopener">issue#1041</a>中有体现，但官方好像一直没解决。不过可以在这里<a href="https://codeload.github.com/ethereum/web3.js/zip/develop" target="_blank" rel="noopener">下载</a>所需的文件，解压后将<code>dist</code>文件夹的内容拷贝到 <code>/node_modules/web3</code>路径下。</p></blockquote><h2 id="创建-UI"><a href="#创建-UI" class="headerlink" title="创建 UI"></a>创建 UI</h2><p>在项目目录下创建<code>index.html</code>，在这里我们将创建基础的 UI，功能包括<code>name</code>和<code>age</code>的输入框，以及一个按钮，这些将通过 jQuery 实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"main.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/web3/dist/web3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Info Contract<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"info"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span> <span class="attr">class</span>=<span class="string">"col-lg-2 control-label"</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span> <span class="attr">class</span>=<span class="string">"col-lg-2 control-label"</span>&gt;</span>Age<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>Update Info<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.slim.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">       <span class="comment">// Our future code here..</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来需要编写<code>main.css</code>文件设定基本的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#F0F0F0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Raleway'</span>,<span class="string">'Source Sans Pro'</span>, <span class="string">'Arial'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2em</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#info</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##使用Web3与智能合约交互<br>UI 创建好之后，在<code>&lt;script&gt;</code>标签中间编写<code>web.js</code>的代码与智能合约交互。首先创建<code>web3</code>实例，并与我们的测试环境连接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">"http://localhost:7545"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码是<a href="https://github.com/ethereum/web3.js/" target="_blank" rel="noopener">web3.js Github</a>提供的样例，意思是如果<code>web3</code>已经被定义，那么就可以直接当作我们的 provider 使用。如果没有定义，则我们手动指定 provider。</p><blockquote><p>这里可能会存在疑问：为什么 web3 会被事先定义呢？实际上，如果你使用类似 <a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>（一个 Chrome 上的插件，迷你型以太坊钱包）这样的软件，provider 就会被自动植入。</p></blockquote><p>在上面代码的基础上，接下来设置默认的以太坊账户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>在上文中我们使用 Ganache 已经创建了 10 个账户了，这里我们选择第一个账户当作默认账户。</p><p>接下来需要让我们的<code>web3</code>知道我们的合约是什么样的，这里需要用到合约的 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">ABI（Application Binary Interface）</a>。<code>ABI</code>可以使我们调用合约的函数，并且从合约中获取数据。</p><p>在上文中我们已经在 Remix 中创建了我们的合约，这时重新回到 Remix，在 Compile 的 tab 下我们点击<code>Details</code> 出现的页面中我们可以拷贝合约的<code>ABI</code>，如下图所示。<br><img src="/images/ABI.png" alt=""><br>将其复制到代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> infoContract = web3.eth.contract(PASTE ABI HERE!);</span><br></pre></td></tr></table></figure><p>接下来转到 run 的tab，拷贝合约的地址，将其复制到下面的代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info = InfoContract.at(<span class="string">'PASTE CONTRACT ADDRESS HERE'</span>);</span><br></pre></td></tr></table></figure><p>完成这些我们就可以调用合约中的函数了，下面我们使用 jQuery 与我们的合约进行交互：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">info.getInfo(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)</span><br><span class="line">        &#123;</span><br><span class="line">            $(<span class="string">"#info"</span>).html(result[<span class="number">0</span>]+<span class="string">' ('</span>+result[<span class="number">1</span>]+<span class="string">' years old)'</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(result);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    info.setInfo($(<span class="string">"#name"</span>).val(), $(<span class="string">"#age"</span>).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上的代码就简单地实现了对合约中两个函数的调用，分别读取和显示<code>name</code>和<code>age</code>变量。</p><p>到此我们就完成了全部的代码，完整代码可以在 <a href="https://github.com/xilibi2003/InfoContract" target="_blank" rel="noopener">InfoContract</a> 中找到。在浏览器中打开<code>index.html</code>测试效果如下图（输入名字和年龄后刷新）。</p><p><img src="/images/page.png" alt=""></p><p>本文中点击”Updata Info”按钮之后，虽然调用智能合约成功，但是当前的界面并没有得到更新，下一篇文章会介绍<a href="https://learnblockchain.cn/2018/05/09/solidity-event/">Web3监听合约事件更新界面</a>。</p><p>本文的作者是盖盖，他的微信公众号: chainlab</p><p>如果你想学习以太坊DApp开发，这门视频课程<a href="https://wiki.learnblockchain.cn/course/dapp.html" target="_blank" rel="noopener">以太坊DAPP开发实战</a>是你不错的选择。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://coursetro.com/posts/code/99/Interacting-with-a-Smart-Contract-through-Web3.js-(Tutorial" target="_blank" rel="noopener">Interacting with a Smart Contract through Web3.js (Tutorial)</a>)</li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了300多位区块链技术牛人和爱好者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web3与智能合约交互实战&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Web3" scheme="https://learnblockchain.cn/tags/Web3/"/>
    
  </entry>
  
</feed>
