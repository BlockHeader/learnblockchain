<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深入浅出区块链</title>
  
  <subtitle>系统学习区块链技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://learnblockchain.cn/"/>
  <updated>2019-01-18T02:33:31.334Z</updated>
  <id>https://learnblockchain.cn/</id>
  
  <author>
    <name>Tiny熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第10期 - 区块链安全的至暗时刻</title>
    <link href="https://learnblockchain.cn/2019/01/18/dev_meeting_10/"/>
    <id>https://learnblockchain.cn/2019/01/18/dev_meeting_10/</id>
    <published>2019-01-18T02:47:23.000Z</published>
    <updated>2019-01-18T02:33:31.334Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分享嘉宾：邓永凯-零时科技-CEO"><a href="#分享嘉宾：邓永凯-零时科技-CEO" class="headerlink" title="分享嘉宾：邓永凯 零时科技 CEO"></a>分享嘉宾：邓永凯 零时科技 CEO</h4><p>话题简介：区块链安全的至暗时刻</p><p>活动大纲：</p><p>一、区块链安全现状<br>二、交易平台安全<br>三、智能合约安全<br>四、共识安全<br>五、区块链安全解决方案</p><p><a href="https://learnblockchain.cn//pdf/10_blockchain_serurity.pdf">点击下载PPT</a><br>因可能涉及的某些安全问题可能对一些项目产生影响，本期的视频暂不公开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;分享嘉宾：邓永凯-零时科技-CEO&quot;&gt;&lt;a href=&quot;#分享嘉宾：邓永凯-零时科技-CEO&quot; class=&quot;headerlink&quot; title=&quot;分享嘉宾：邓永凯 零时科技 CEO&quot;&gt;&lt;/a&gt;分享嘉宾：邓永凯 零时科技 CEO&lt;/h4&gt;&lt;p&gt;话题简介：区块链安全
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>第9期 - 漫谈区块图技术之XDAG和Conflux</title>
    <link href="https://learnblockchain.cn/2019/01/11/dev_meeting_9/"/>
    <id>https://learnblockchain.cn/2019/01/11/dev_meeting_9/</id>
    <published>2019-01-11T02:47:23.000Z</published>
    <updated>2019-01-11T03:36:48.808Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分享嘉宾：以太零-高级工程师-苏显华"><a href="#分享嘉宾：以太零-高级工程师-苏显华" class="headerlink" title="分享嘉宾：以太零 高级工程师 苏显华"></a>分享嘉宾：以太零 高级工程师 苏显华</h4><p>话题：漫谈区块图技术之XDAG和Conflux</p><p>1、区块图技术重量级区块链项目-conflux<br>2、图灵奖姚教授发明的Conflux是什么？<br>3、XDAG的工作量证明和区块图算法<br>4、XDAG现存问题和未来改进<br>5、Conflux特性和发布时间</p><p><a href="https://wiki.learnblockchain.cn/pdf/xdag_conflux.pdf" target="_blank" rel="noopener">点击下载PPT</a> 及 <a href="https://m.qlchat.com/live/channel/channelPage/2000003282116880.htm" target="_blank" rel="noopener">现场视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;分享嘉宾：以太零-高级工程师-苏显华&quot;&gt;&lt;a href=&quot;#分享嘉宾：以太零-高级工程师-苏显华&quot; class=&quot;headerlink&quot; title=&quot;分享嘉宾：以太零 高级工程师 苏显华&quot;&gt;&lt;/a&gt;分享嘉宾：以太零 高级工程师 苏显华&lt;/h4&gt;&lt;p&gt;话题：漫谈区
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>第8期 - 大白话区块链共识机制算法</title>
    <link href="https://learnblockchain.cn/2019/01/04/dev_meeting_8/"/>
    <id>https://learnblockchain.cn/2019/01/04/dev_meeting_8/</id>
    <published>2019-01-04T02:47:23.000Z</published>
    <updated>2019-01-04T02:52:27.560Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分享嘉宾：Nerthus-CTO-虞双齐"><a href="#分享嘉宾：Nerthus-CTO-虞双齐" class="headerlink" title="分享嘉宾：Nerthus CTO 虞双齐"></a>分享嘉宾：Nerthus CTO 虞双齐</h4><p>力求用最普通的话语讲解区块链共识机制。</p><p>话题大纲：</p><ol><li><p>区块链史前文明</p></li><li><p>工作量证明(PoW)共识机制算法与分析、以及算力和区块难度等区块链概念。</p></li><li><p>权益证明(PoS)共识机制、各种优化版的Pos介绍与分析。</p></li></ol><p><a href="https://wiki.learnblockchain.cn/pdf/meetup_8.pdf" target="_blank" rel="noopener">点击下载PPT</a> 及 <a href="https://m.qlchat.com/wechat/page/channel-intro?channelId=2000003201470300" target="_blank" rel="noopener">现场视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;分享嘉宾：Nerthus-CTO-虞双齐&quot;&gt;&lt;a href=&quot;#分享嘉宾：Nerthus-CTO-虞双齐&quot; class=&quot;headerlink&quot; title=&quot;分享嘉宾：Nerthus CTO 虞双齐&quot;&gt;&lt;/a&gt;分享嘉宾：Nerthus CTO 虞双齐&lt;/h4&gt;&lt;
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>第7期 - 选对赛道，穿越凛冬：区块链的设计思想和演化逻辑</title>
    <link href="https://learnblockchain.cn/2018/12/28/dev_meeting_7/"/>
    <id>https://learnblockchain.cn/2018/12/28/dev_meeting_7/</id>
    <published>2018-12-28T03:41:23.000Z</published>
    <updated>2018-12-28T00:55:57.446Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讲师：AMT社区共建者-Jason"><a href="#讲师：AMT社区共建者-Jason" class="headerlink" title="讲师：AMT社区共建者 Jason"></a>讲师：AMT社区共建者 Jason</h4><p>分享大纲:</p><p>一、 伟大变革or旁氏泡沫：谁需要区块链，需要什么样的区块链？</p><p>二 、区块链对现实世界的依赖性：虚生于实，依于实。</p><p>三、 几大公链设计思想对比：面对不可能三角时各公链的取舍和结果</p><p>  1）TPS:BTC,LTC,ETH的出块时间对比说明了什么<br>  2)  去中心化: 如何面对用去中心化换TPS<br>  3）安全：没有绝对，只有相对</p><p>四、 发展焦点：</p><p>   1）协议共识 VS 社会共识 谁将获胜？<br>   2）分裂是好是坏 ：BTC分裂BCH, BCH分裂BSV<br>   3）智能合约：新经济的核心</p><p>五、 下一跳去到哪里：TPS、新共识、跨链、应用落地（IBO STO等)</p><p>六 、匿名技术公链：最后的保留地</p><p>七 、前路展望：符合社会需要，百花迎春</p><p><a href="https://wiki.learnblockchain.cn/pdf/meetup_7.pdf" target="_blank" rel="noopener">点击下载PPT</a> 及 <a href="https://m.qlchat.com/live/channel/channelPage/2000003125933455.htm" target="_blank" rel="noopener">现场视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;讲师：AMT社区共建者-Jason&quot;&gt;&lt;a href=&quot;#讲师：AMT社区共建者-Jason&quot; class=&quot;headerlink&quot; title=&quot;讲师：AMT社区共建者 Jason&quot;&gt;&lt;/a&gt;讲师：AMT社区共建者 Jason&lt;/h4&gt;&lt;p&gt;分享大纲:&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>IPFS 使用入门</title>
    <link href="https://learnblockchain.cn/2018/12/25/use-ipfs/"/>
    <id>https://learnblockchain.cn/2018/12/25/use-ipfs/</id>
    <published>2018-12-25T11:16:27.000Z</published>
    <updated>2018-12-27T08:25:22.807Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://learnblockchain.cn/2018/12/12/what-is-ipfs/">上一篇文章</a>介绍了IPFS要做什么， 本篇文章介绍下IPFS怎么用， 按照本站的风格，我不会仅仅把一个个命令列出来，同时会说明命令在后面为我们做了什么。</p><a id="more"></a><h2 id="IPFS-安装"><a href="#IPFS-安装" class="headerlink" title="IPFS 安装"></a>IPFS 安装</h2><p>要使用IPFS， 第一步肯定是先把IPFS安装好，IPFS在Mac OS X 、Linux及Window平台均有提供， 可以通过这个<a href="https://dist.ipfs.io/#go-ipfs" target="_blank" rel="noopener">链接</a>下载对应平台可执行文件的压缩包。</p><p>对于Mac OS X 及 Linux 平台，使用一下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvfz go-ipfs.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> go-ipfs</span><br><span class="line">$ ./install.sh</span><br></pre></td></tr></table></figure><p>上面先使用tar 对压缩包进行解压，然后执行install.sh 进行安装，安装脚本install.sh其实就是把可执行文件<code>ipfs</code>移动到<code>$PATH</code>目录下。安装完成之后，可以在命令行终端敲入<code>ipfs</code>试试看，如果显示一堆命令说明，则说明IPFS安装成功。</p><p>在Windows平台也是类似，把<code>ipfs.exe</code>移动到环境变量<code>%PATH%</code>指定的目录下。</p><h2 id="IPFS-基本用法"><a href="#IPFS-基本用法" class="headerlink" title="IPFS 基本用法"></a>IPFS 基本用法</h2><h3 id="IPFS初始化"><a href="#IPFS初始化" class="headerlink" title="IPFS初始化"></a>IPFS初始化</h3><p>安装完成之后，要使用IPFS第一步是要对IPFS进行初始化，使用<code>ipfs init</code>进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs init</span><br><span class="line">initializing ipfs node at /Users/Emmett/.ipfs</span><br><span class="line">generating 2048-bit RSA keypair...done</span><br><span class="line">peer identity: QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva</span><br><span class="line">to get started, enter:</span><br><span class="line"></span><br><span class="line">  ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</span><br></pre></td></tr></table></figure><p>上面是执行命令即对应输出，在执行<code>ipfs init</code>进行初始化时，会有一下行为：</p><ol><li><p>生成一个秘钥对并产生对应的节点id， 即命令提示：<code>peer identity</code>后面的hash值。</p><blockquote><p>节点的id用来标识和连接一个节点，每个节点的id是独一无二的， 因此大家看到的提示也会和我的不一样。</p></blockquote></li><li><p>在当前用户的主目录（~ 目录）下产生一个.ipfs 的隐藏目录，这个目录称之为库（repository）目录，ipfs 所有相关的数据都会放在这个目录下。<br>如同步文件数据块放在.ipfs/blocks 目录，秘钥在.ipfs/keystore 目录，ipfs配置文件为：.ipfs/config。</p></li></ol><h4 id="IPFS-配置修改"><a href="#IPFS-配置修改" class="headerlink" title="IPFS 配置修改"></a>IPFS 配置修改</h4><p>在IPFS初始化之后，可以根据需要修改配置（可选），修改方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ipfs</span><br><span class="line">export EDITOR=/usr/bin/vim</span><br><span class="line">ipfs config edit</span><br></pre></td></tr></table></figure><p>或者直接编辑 ~/.ipfs/config 文件。</p><h3 id="上传文件到IPFS"><a href="#上传文件到IPFS" class="headerlink" title="上传文件到IPFS"></a>上传文件到IPFS</h3><p>我们先创建一个upchain.pro.txt文件，可以使用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo &quot;登链学院：区块链教育领先品牌&quot; &gt;&gt; upchain.pro.txt</span><br></pre></td></tr></table></figure><p>ipfs 使用add 命令来添加内容到节点中，  在命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs add upchain.pro.txt</span><br><span class="line">added QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi upchain.pro.txt</span><br><span class="line"> 43 B / 43 B [=====================================================] 100%</span><br></pre></td></tr></table></figure><p>当它文件添加到节点时，会为文件生成唯一的hash: QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi, 可以使用ipfs cat 查看文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs cat QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi</span><br><span class="line">登链学院：区块链教育领先品牌</span><br></pre></td></tr></table></figure><p>注意，此时文件仅仅是上传在本地的IPFS节点中，如果需要把文件同步到网络，就需要开启 daemon 服务， 使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs daemon</span><br><span class="line">Initializing daemon...</span><br><span class="line">go-ipfs version: 0.4.18-</span><br><span class="line">Repo version: 7</span><br><span class="line">System version: amd64/darwin</span><br><span class="line">Golang version: go1.11.1</span><br><span class="line">Swarm listening on /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/192.168.8.105/tcp/4001</span><br><span class="line">Swarm listening on /ip6/2408:84f3:82e:cfcd:409:fee2:e261:4dc3/tcp/4001</span><br><span class="line">Swarm listening on /ip6/2408:84f3:82e:cfcd:a9c6:116b:349f:8c2b/tcp/4001</span><br><span class="line">Swarm listening on /ip6/2408:84f3:82e:cfcd:ec89:145d:cf27:4/tcp/4001</span><br><span class="line">Swarm listening on /ip6/::1/tcp/4001</span><br><span class="line">Swarm listening on /ip6/fd1d:43b:e89b:eb9b:c405:56af:8f52:67df/tcp/4001</span><br><span class="line">Swarm listening on /p2p-circuit</span><br><span class="line">Swarm announcing /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/192.168.8.105/tcp/4001</span><br><span class="line">Swarm announcing /ip6/2408:84f3:82e:cfcd:409:fee2:e261:4dc3/tcp/4001</span><br><span class="line">Swarm announcing /ip6/2408:84f3:82e:cfcd:a9c6:116b:349f:8c2b/tcp/4001</span><br><span class="line">Swarm announcing /ip6/2408:84f3:82e:cfcd:ec89:145d:cf27:4/tcp/4001</span><br><span class="line">Swarm announcing /ip6/::1/tcp/4001</span><br><span class="line">Swarm announcing /ip6/fd1d:43b:e89b:eb9b:c405:56af:8f52:67df/tcp/4001</span><br><span class="line">API server listening on /ip4/127.0.0.1/tcp/5001</span><br><span class="line">Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</span><br><span class="line">Daemon is ready</span><br></pre></td></tr></table></figure><p>开启 daemon 之后，Swarm 就会尝试连接其他的节点，同步数据，同时在本地还会开启两个服务：API服务及Web网关服务，下面分别介绍下：</p><ol><li>API服务，默认在5001端口，可以通过 <a href="http://localhost:5001/webui" target="_blank" rel="noopener">http://localhost:5001/webui</a> 进行访问，界面如：</li></ol><p><img src="https://learnblockchain.cn/media/15458049832966.jpg" alt=""></p><p>这也是IPFS的一个Web版的管理控制台， 可以通过这个控制台添加文件，查看节点连接情况等等。</p><ol><li>网关服务，默认在8080端口， 由于当前浏览器还不支持通过IPFS协议（ipfs://）来访问文件，如果我们要在浏览器里访问文件的话，就需要借助于IPFS 提供的网关服务，由浏览器先访问到网关，网关去获取IPFS网络杀过了的文件。 有了网关服务，就可以通过这个链接：<code>http://localhost:8080/ipfs/QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi</code> 来访问刚刚上传到ipfs 的文件。</li></ol><blockquote><p>ipfs 也提供了官方的网关服务：<a href="https://ipfs.io/，" target="_blank" rel="noopener">https://ipfs.io/，</a> 因此也可以通过 <a href="https://ipfs.io/ipfs/QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi" target="_blank" rel="noopener">https://ipfs.io/ipfs/QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi</a> （需要翻墙）来访问刚刚上传到ipfs 的文件。</p></blockquote><h3 id="上传目录到IPFS"><a href="#上传目录到IPFS" class="headerlink" title="上传目录到IPFS"></a>上传目录到IPFS</h3><p>我们先创建一个文件夹upchain, 并把之前的 upchain.pro.txt 放进目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir upchain</span><br><span class="line">&gt; mv upchain.pro.txt  upchain</span><br></pre></td></tr></table></figure><p>上传目录到IPFS 需要在使用 add 命令时加上 -r ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs add -r upchain</span><br><span class="line">added QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi upchain/upchain.pro.txt</span><br><span class="line">added QmQYpGRFBpHVzoShpwU5C3XgGAxJKqY83X8VXfMbyktdbP upchain</span><br><span class="line"> 43 B / 43 B [===========================================================================] 100.00%</span><br></pre></td></tr></table></figure><p>在上传时文件夹，文件夹也会生成一个对应的hash，可以通过hash后接文件名来进行访问， 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;ipfs cat QmQYpGRFBpHVzoShpwU5C3XgGAxJKqY83X8VXfMbyktdbP/upchain.pro.txt</span><br><span class="line">登链学院：区块链教育领先品牌</span><br></pre></td></tr></table></figure><p>在浏览器可以链接：<code>http://127.0.0.1:8080/ipfs/QmQYpGRFBpHVzoShpwU5C3XgGAxJKqY83X8VXfMbyktdbP/upchain.pro.txt</code> 来访问。</p><p>通过上传目录的方式，可以把整个静态网站的根目录上传到IPFS网络，这样就可以省去托管服务器，例如可以直接通过以下链接访问深入浅出区块链博客：<br><a href="https://ipfs.io/ipfs/QmaFWgfpRNzeLgfDrH33BuBdiauRTejnF3Yw9AuCphq2ua/index.html" target="_blank" rel="noopener">https://ipfs.io/ipfs/QmaFWgfpRNzeLgfDrH33BuBdiauRTejnF3Yw9AuCphq2ua/index.html</a></p><h2 id="使用IPNS解决文件更新问题"><a href="#使用IPNS解决文件更新问题" class="headerlink" title="使用IPNS解决文件更新问题"></a>使用IPNS解决文件更新问题</h2><p>因为IPFS在IPFS中，对一个文件的内容修改后（如升级），会生成一个完全不同的新Hash，使用IPNS就可以利用同一个链接总是指向更新的内容，其实使用也很简单，只需要每次在内容更新之后使用ipfs name publish <code>hash</code> 发布到节点。 </p><p>例如把upchain.pro.txt发布到节点，使用下面的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs name publish QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi</span><br><span class="line">Published to QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva: /ipfs/QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi</span><br></pre></td></tr></table></figure></p><p>命令中的<code>QmQgMZKqHzyEdyJja5ioF8WaXrbUDVjqhJDoaUKDymgioi</code>是<code>upchain.pro.txt</code>的hash, 命令提示中的<code>QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva</code>是当前节点id(大家可以回看一个前面ipfs init 的输出)。</p><p>发布之后就可以使用<a href="http://127.0.0.1:8080/ipns/QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva" target="_blank" rel="noopener">http://127.0.0.1:8080/ipns/QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva</a> 或 <a href="https://ipfs.io/ipns/QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva" target="_blank" rel="noopener">https://ipfs.io/ipns/QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva</a> 来访问upchain.pro.txt的内容，如图：</p><p><img src="https://learnblockchain.cn/media/15458309509991.jpg" alt=""></p><p>其实理想下是使用 ipns://QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva 来访问，通过网站还是前面提到的浏览器暂不支持ipfs协议。</p><p>现在我们来更新一下upchain.pro.txt 加入文字：”创办人：Tiny熊”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo &quot;创办人：Tiny熊&quot; &gt;&gt;  upchain.pro.txt</span><br><span class="line">&gt; ipfs add upchain.pro.txt</span><br><span class="line">added QmUUiDN6tWtj89xmUw1iCK2NczBqE6m3zH9QnbhHoMvZ5S upchain.pro.txt</span><br><span class="line"> 63 B / 63 B [=============================================================] 100.00%</span><br></pre></td></tr></table></figure><p>重新发布一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs name publish QmUUiDN6tWtj89xmUw1iCK2NczBqE6m3zH9QnbhHoMvZ5S</span><br><span class="line">Published to QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva: /ipfs/QmUUiDN6tWtj89xmUw1iCK2NczBqE6m3zH9QnbhHoMvZ5S</span><br></pre></td></tr></table></figure><p>再次访问 <a href="http://127.0.0.1:8080/ipns/QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva" target="_blank" rel="noopener">http://127.0.0.1:8080/ipns/QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva</a> （这个链接和上面的链接一样）可以看到内容更新了。</p><p><img src="https://learnblockchain.cn/media/15458322289639.jpg" alt=""></p><p>如果我们要查询 节点id 指向的hash 可以使用 <code>ipfs name resolve</code> 进行查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs name resolve</span><br><span class="line">/ipfs/QmUUiDN6tWtj89xmUw1iCK2NczBqE6m3zH9QnbhHoMvZ5</span><br></pre></td></tr></table></figure></p><p>有一点值得大家注意： 节点id其实是公钥的hash，它的关联信息是需要经过私钥签名才可以发布，因此只有我们自己才可以更新节点的指向。</p><p>如果我们有多个站点需要更新，可以新产生一个秘钥对，使用新的key 发布，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs key gen --type=rsa --size=2048 mykey</span><br><span class="line">QmVZvdYEsdfHSR43Qm1fY8eDFrhB3UNZ2oVyEuVUH3VHrg</span><br><span class="line">&gt; ipfs name publish --key=mykey  hashxxx</span><br></pre></td></tr></table></figure><h2 id="Pinning"><a href="#Pinning" class="headerlink" title="Pinning"></a>Pinning</h2><p>Pinning 在IPFS里是一个很重要的概念，当我们每次请求一个网络上的内容的时候，IPFS总是会把内容先同步的本地提供服务，而为了防止 IPFS 存储空间不停增长，实际上使用cache 机制来处理文件， 如果文件在一段时间内没有被使用，文件会被”回收“。 Pinning 的作用就是把文件”钉“住，确保文件在本地不被”回收“。 如果是重要的文件，就可以使用 Pinning 防止文件被删除。</p><p>当我们使用ipfs add 添加文件时，默认会进行Pinning(使用其他命令获取的文件不会进行pinning），</p><p>IPFS 提供了pin命令进行Pinning操作, 比如我们查询下某一个hash 是否被pin:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs pin ls QmUUiDN6tWtj89xmUw1iCK2NczBqE6m3zH9QnbhHoMvZ5S</span><br><span class="line">QmUUiDN6tWtj89xmUw1iCK2NczBqE6m3zH9QnbhHoMvZ5S recursive</span><br><span class="line"></span><br><span class="line">&gt; ipfs pin ls QmWnrAEKyDVUQ1jh9vDtQhtBSNEgUnQhAJyMmo3JjwJZK7</span><br><span class="line">Error: path &apos;QmWnrAEKyDVUQ1jh9vDtQhtBSNEgUnQhAJyMmo3JjwJZK7&apos; is not pinned</span><br></pre></td></tr></table></figure><p>可以使用 pin add 手动钉住一个文件，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs pin add QmWnrAEKyDVUQ1jh9vDtQhtBSNEgUnQhAJyMmo3JjwJZK7</span><br><span class="line">pinned QmWnrAEKyDVUQ1jh9vDtQhtBSNEgUnQhAJyMmo3JjwJZK7 recursively</span><br></pre></td></tr></table></figure><p>如果要删除pin的状态，使用pin rm ， 如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ipfs pin rm -r QmWnrAEKyDVUQ1jh9vDtQhtBSNEgUnQhAJyMmo3JjwJZK7</span><br><span class="line">unpinned QmWnrAEKyDVUQ1jh9vDtQhtBSNEgUnQhAJyMmo3JjwJZK7</span><br></pre></td></tr></table></figure><p>pin rm 的参数 -r 表示递归的删除pin 状态，对于没有pin住的文件， 如果执行GC操作 <code>ipfs repo gc</code> 文件会被删除。</p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://learnblockchain.cn/2018/12/12/what-is-ipfs/&quot;&gt;上一篇文章&lt;/a&gt;介绍了IPFS要做什么， 本篇文章介绍下IPFS怎么用， 按照本站的风格，我不会仅仅把一个个命令列出来，同时会说明命令在后面为我们做了什么。&lt;/p&gt;
    
    </summary>
    
      <category term="IPFS" scheme="https://learnblockchain.cn/categories/IPFS/"/>
    
    
      <category term="IPFS" scheme="https://learnblockchain.cn/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title>第六期 - DAG技术中的比特币XDAG</title>
    <link href="https://learnblockchain.cn/2018/12/21/dev_meeting_6/"/>
    <id>https://learnblockchain.cn/2018/12/21/dev_meeting_6/</id>
    <published>2018-12-21T03:41:23.000Z</published>
    <updated>2018-12-21T10:45:09.945Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讲师：以太零-苏显华"><a href="#讲师：以太零-苏显华" class="headerlink" title="讲师：以太零 苏显华"></a>讲师：以太零 苏显华</h4><p>分享大纲:</p><ol><li>区块链技术现状</li><li>DAG公链的发展现状</li><li>DAG技术的比特币XDAG</li><li>XDAG的技术实践</li><li>未来的挑战</li></ol><p><a href="https://wiki.learnblockchain.cn/pdf/meetup_6.pdf" target="_blank" rel="noopener">点击下载PPT</a> 及 <a href="https://m.qlchat.com/live/channel/channelPage/2000003040784741.htm" target="_blank" rel="noopener">现场视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;讲师：以太零-苏显华&quot;&gt;&lt;a href=&quot;#讲师：以太零-苏显华&quot; class=&quot;headerlink&quot; title=&quot;讲师：以太零 苏显华&quot;&gt;&lt;/a&gt;讲师：以太零 苏显华&lt;/h4&gt;&lt;p&gt;分享大纲:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;区块链技术现状&lt;/li&gt;
&lt;li&gt;DA
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>第五期 - 搞明白以太坊DAPP开发</title>
    <link href="https://learnblockchain.cn/2018/12/14/dev_meeting_5/"/>
    <id>https://learnblockchain.cn/2018/12/14/dev_meeting_5/</id>
    <published>2018-12-14T03:41:23.000Z</published>
    <updated>2018-12-17T14:09:12.512Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讲师：登链学院-Tiny熊"><a href="#讲师：登链学院-Tiny熊" class="headerlink" title="讲师：登链学院 Tiny熊"></a>讲师：登链学院 Tiny熊</h4><p>分享大纲:</p><ol><li>DAPP与APP 的区别</li><li>智能合约开发简介</li><li>web3.js 与 合约交互</li><li>MetaMask, Remix , Truffle，Ganache 使用</li></ol><p><a href="https://wiki.learnblockchain.cn/pdf/meetup_5.pdf" target="_blank" rel="noopener">点击下载PPT</a> 及 <a href="https://m.qlchat.com/wechat/page/channel-intro?channelId=2000002953398745" target="_blank" rel="noopener">现场视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;讲师：登链学院-Tiny熊&quot;&gt;&lt;a href=&quot;#讲师：登链学院-Tiny熊&quot; class=&quot;headerlink&quot; title=&quot;讲师：登链学院 Tiny熊&quot;&gt;&lt;/a&gt;讲师：登链学院 Tiny熊&lt;/h4&gt;&lt;p&gt;分享大纲:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DAPP与AP
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>第四期 - 以太坊零手续费及其安全防御的实现</title>
    <link href="https://learnblockchain.cn/2018/12/13/dev_meeting_4/"/>
    <id>https://learnblockchain.cn/2018/12/13/dev_meeting_4/</id>
    <published>2018-12-13T03:41:23.000Z</published>
    <updated>2018-12-17T14:09:21.705Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讲师：以太零CTO-钟瑞仙"><a href="#讲师：以太零CTO-钟瑞仙" class="headerlink" title="讲师：以太零CTO 钟瑞仙"></a>讲师：以太零CTO 钟瑞仙</h4><p>主要内容:</p><ol><li>以太坊⼿手续费简介</li><li>零⼿手续费的必要性  </li><li>零⼿手续费的实现</li><li>零⼿手续费带来的安全问题及其解决⽅方案</li><li>零⼿手续费的副作⽤</li></ol><p><a href="https://wiki.learnblockchain.cn/pdf/meetup_4.pdf" target="_blank" rel="noopener">点击下载PPT</a>及<a href="https://m.qlchat.com/wechat/page/channel-intro?channelId=2000002858537956" target="_blank" rel="noopener">完整课程视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;讲师：以太零CTO-钟瑞仙&quot;&gt;&lt;a href=&quot;#讲师：以太零CTO-钟瑞仙&quot; class=&quot;headerlink&quot; title=&quot;讲师：以太零CTO 钟瑞仙&quot;&gt;&lt;/a&gt;讲师：以太零CTO 钟瑞仙&lt;/h4&gt;&lt;p&gt;主要内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以太坊⼿手续费
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>第三期 - 高TPS与去中心化存储带来的机遇</title>
    <link href="https://learnblockchain.cn/2018/12/13/dev_meeting_3/"/>
    <id>https://learnblockchain.cn/2018/12/13/dev_meeting_3/</id>
    <published>2018-12-13T03:27:23.000Z</published>
    <updated>2018-12-17T14:09:28.127Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讲师：星际区块（深圳）CEO-谢建怀"><a href="#讲师：星际区块（深圳）CEO-谢建怀" class="headerlink" title="讲师：星际区块（深圳）CEO 谢建怀"></a>讲师：星际区块（深圳）CEO 谢建怀</h4><p>主要内容:</p><ol><li>高TPS能让我们做更多有意思的东西</li><li>第三代区块链技术能落地的思考   </li><li>去中心化存储能在工程上带来哪些应用</li><li>区块链应用的项目探索（基于EOS、FIBOS和IPFS 应用）</li></ol><p><a href="https://wiki.learnblockchain.cn/pdf/meeting_3.pdf" target="_blank" rel="noopener">点击下载PPT</a>及<a href="https://m.qlchat.com/live/channel/channelPage/2000002746846802.htm" target="_blank" rel="noopener">完整课程视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;讲师：星际区块（深圳）CEO-谢建怀&quot;&gt;&lt;a href=&quot;#讲师：星际区块（深圳）CEO-谢建怀&quot; class=&quot;headerlink&quot; title=&quot;讲师：星际区块（深圳）CEO 谢建怀&quot;&gt;&lt;/a&gt;讲师：星际区块（深圳）CEO 谢建怀&lt;/h4&gt;&lt;p&gt;主要内容:&lt;
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>第二期 - 深度探索以太坊智能合约</title>
    <link href="https://learnblockchain.cn/2018/12/13/dev_meeting_2/"/>
    <id>https://learnblockchain.cn/2018/12/13/dev_meeting_2/</id>
    <published>2018-12-13T03:26:23.000Z</published>
    <updated>2018-12-17T14:09:35.980Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讲师：以太零CTO-钟瑞仙"><a href="#讲师：以太零CTO-钟瑞仙" class="headerlink" title="讲师：以太零CTO 钟瑞仙"></a>讲师：以太零CTO 钟瑞仙</h4><p>主要内容包含:</p><ol><li>以太坊账户介绍</li><li>交易数据⾥里data字段的编码规则</li><li>智能合约属性的索引和存储</li><li>预编译合约介绍及汇编调⽤</li></ol><p><a href="https://wiki.learnblockchain.cn/pdf/deep_smartcontract.pdf" target="_blank" rel="noopener">点击下载PPT</a>及<a href="https://m.qlchat.com/wechat/page/channel-intro?channelId=2000002631831830&amp;sourceNo=link" target="_blank" rel="noopener">完整课程视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;讲师：以太零CTO-钟瑞仙&quot;&gt;&lt;a href=&quot;#讲师：以太零CTO-钟瑞仙&quot; class=&quot;headerlink&quot; title=&quot;讲师：以太零CTO 钟瑞仙&quot;&gt;&lt;/a&gt;讲师：以太零CTO 钟瑞仙&lt;/h4&gt;&lt;p&gt;主要内容包含:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以太坊账户
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>第一期 - 以太坊钱包开发</title>
    <link href="https://learnblockchain.cn/2018/12/13/dev_meeting_1/"/>
    <id>https://learnblockchain.cn/2018/12/13/dev_meeting_1/</id>
    <published>2018-12-13T03:25:59.000Z</published>
    <updated>2018-12-17T14:09:41.301Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讲师：登链学院-熊丽兵"><a href="#讲师：登链学院-熊丽兵" class="headerlink" title="讲师：登链学院 熊丽兵"></a>讲师：登链学院 熊丽兵</h4><p>分享大纲:</p><ol><li>私钥 地址 及账号</li><li>什么是HD钱包（分层确定性钱包）</li><li>助记词及私钥保存</li><li>如何测量gasLimit及设定gasPrice</li><li>如何发送签名交易及转移Token</li></ol><p><a href="https://wiki.learnblockchain.cn/pdf/eth_wallet.pdf" target="_blank" rel="noopener">点击下载PPT</a>及<a href="https://m.qlchat.com/wechat/page/channel-intro?channelId=2000002356009198" target="_blank" rel="noopener">完整课程视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;讲师：登链学院-熊丽兵&quot;&gt;&lt;a href=&quot;#讲师：登链学院-熊丽兵&quot; class=&quot;headerlink&quot; title=&quot;讲师：登链学院 熊丽兵&quot;&gt;&lt;/a&gt;讲师：登链学院 熊丽兵&lt;/h4&gt;&lt;p&gt;分享大纲:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;私钥 地址 及账号&lt;/li&gt;

      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>站在Web3.0 理解IPFS是什么</title>
    <link href="https://learnblockchain.cn/2018/12/12/what-is-ipfs/"/>
    <id>https://learnblockchain.cn/2018/12/12/what-is-ipfs/</id>
    <published>2018-12-12T08:35:33.000Z</published>
    <updated>2018-12-17T12:36:55.419Z</updated>
    
    <content type="html"><![CDATA[<p>尽管网络上，已经有不少文章讨论IPFS，不过真正讲明白IPFS想做什么的很少，文本尝试站在未来Web3.0的高度来看看IPFS究竟用来解决什么问题。</p><a id="more"></a><h2 id="DApp-的缺陷"><a href="#DApp-的缺陷" class="headerlink" title="DApp 的缺陷"></a>DApp 的缺陷</h2><p>对区块链有所了解的同学，知道区块链维护的是一个中立的（去中心）、共同信任、难以篡改的数据库、智能合约创造的是一个完全透明（不被干扰）的运行规则，因此可以解决信任问题。</p><p>一切看起来很美好，我们可以<a href="https://ke.qq.com/course/335169" target="_blank" rel="noopener">开发去中心化应用DApp</a> 解决信任问题，由此也确实产生了很多的博彩类DApp游戏。</p><blockquote><p>不熟悉DApp的同学可以看我另一篇文章<a href="https://learnblockchain.cn/2018/08/31/devDapp/">程序员如何切入区块链去中心化应用开发</a>.</p></blockquote><p>细心的同学，也许会发现一个问题，<strong>虽然DApp的后台逻辑（智能合约）是在无中心的节点上运行的透明的规则，但是我们看到内容却来自于一台无信任的中心化服务器。</strong></p><p>这是由当前互联网规则-超文本媒体传输协议（HTTP）决定的，简单来讲，在这个协议下，当我们在浏览器输入一个网址时，总是会先找到这个网址（域名）对应的服务器IP地址，然后请求服务器，并把服务器的响应显示在浏览器。</p><blockquote><p>这种方式下文件能否访问，完全取决于服务器，服务器也许会关闭、内容获取被篡改或删除，对用户都无法保证。我自己看到好内容把网页收藏的习惯，经常会出现过一段时间再去访问的时候，页面已经不存在了。</p></blockquote><h2 id="IPFS想要做什么"><a href="#IPFS想要做什么" class="headerlink" title="IPFS想要做什么"></a>IPFS想要做什么</h2><p>IPFS - InterPlanetary File System 星际文件系统，多数人谈到IPFS都只讲到它的去中心化存储，其实IPFS想要做的远不只存储，其目标是取代HTTP，成为Web3.0时代的基础协议。我们从其<a href="https://ipfs.io/" target="_blank" rel="noopener">官网</a>对IPFS的定义就可以看到其雄心。</p><blockquote><p> 尽管Web3.0目前没有明确定义，从2014年以太坊联合创始人Gavin Wood提出分布式网络的Web3.0概念开始，业界普遍认为Web3.0 特征应该是 分布式、可信任。</p></blockquote><p>在官网的有这样两个描述：</p><ol><li><p>IPFS is the Distributed Web<br>A peer-to-peer hypermedia protocol to make the web faster, safer, and more open.</p></li><li><p>IPFS aims to replace HTTP and build a better web for all of us.</p></li></ol><p>翻译过来就是： 1. IPFS是分布式Web，是点对点的超媒体协议，以构建更快、更安全、更开放的网络。 2. IPFS旨在取代HTTP，为我们构建一个更好的web。</p><p>当然，要完全取代HTTP还有一段路要走，最大的坎是怎样让‍‍主流的浏览器支持IPFS协议，‍‍现在是通过HTTP网关的方式访问IPFS网上面存在的文件。<br>未来IPFS能取代Http的话？就是通过网络浏览器里直接输入 <code>ipfs://文件hash</code> 访问内容，‍‍目前这种方式访问IPFS 必须依靠浏览器插件<a href="https://github.com/ipfs-shipyard/ipfs-companion" target="_blank" rel="noopener">ipfs 伴侣</a>， 并且这个插件的使用不广泛。</p><blockquote><p>注意，这里提到的浏览器，只是沿用这个名词，Web3.0的浏览器也许不叫浏览器， 它更可能是数字钱包和浏览器的组合体，现在浏览器上发起交易也同样需要依靠钱包插件进行签名。所以这样一个形态的产品也是大家的机会，这是一个全新的超大入口级产品。</p></blockquote><p>即未来期望的访问方式是这样的：<br>ipfs://Qme2qNy61yLj9hzDm4VN6HDEkCmksycgSEM33k4eHCgaVu</p><p>而现在通过网关访问是这样的：<br><a href="http://127.0.0.1:8080/ipfs/Qme2qNy61yLj9hzDm4VN6HDEkCmksycgSEM33k4eHCgaVu" target="_blank" rel="noopener">http://127.0.0.1:8080/ipfs/Qme2qNy61yLj9hzDm4VN6HDEkCmksycgSEM33k4eHCgaVu</a><br><a href="https://ipfs.io/ipfs/Qme2qNy61yLj9hzDm4VN6HDEkCmksycgSEM33k4eHCgaVu" target="_blank" rel="noopener">https://ipfs.io/ipfs/Qme2qNy61yLj9hzDm4VN6HDEkCmksycgSEM33k4eHCgaVu</a></p><h2 id="IPFS是怎么做的"><a href="#IPFS是怎么做的" class="headerlink" title="IPFS是怎么做的"></a>IPFS是怎么做的</h2><p>IPFS是一种内容可寻址、版本化、点对点超媒体的分布式存储、传输协议。</p><p>我们知道在现在的网络服务里，内容是基于位置（IP）寻址的，就是在查找内容的时候，需要先找到内容所在的服务器（根据IP），然后再在服务器上找对应的内容。<br>而在IPFS的网络里，是根据内容寻址，每一个‍‍上传到IPFS上面去的文件、文件夹，都是以Qm为开头字母的哈希值，无需知道文件存储在哪里，通过哈希值就能够找到这个文件，这种方式叫内容寻址。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>在IPFS系统中，内容会分块存放（如果内容很小就会直接存在DHT中），并分散存储在IPFS网络中的节点上（不过目前的IPFS实现，一个节点会完整保存内容的所有区块）。系统会给内容的每一个块计算哈希值，然后把所有块的哈希值拼凑起来，再计算一次哈希值，从而得到最终的哈希值。同时每个节点会维护一张DHT（分布式哈希表），包含数据块与目标节点的映射关系。</p><p>在IPFS中是通过哈希去请求文件的，它就会使用这个分布式哈希表找到文件所在的节点，取回文件根据哈希重新组合文件（同样也会验证文件）。</p><h3 id="IPFS的特点"><a href="#IPFS的特点" class="headerlink" title="IPFS的特点"></a>IPFS的特点</h3><p>根据前面的原理，我们可以推倒出IPFS的几个特点：</p><ol><li><p>当我们知道一个文件的哈希值之后，可以确保文件不被修改， 即可以确保访问的文件是没有被篡改的。因为根据哈希的特点，哪怕源文件有一丁点的更改，对应的哈希值也会完全不同。</p></li><li><p>(理论上) 如果IPFS得以普及，节点数达到一定规模，内容将永久保存，就算部分节点离线，也不会影响文件的读取，不像现在的收藏会失效。</p></li><li><p>由于IPFS是一个统一的网络，只要文件在网络中被存储过，除了必要的冗余备份，文件不会被重复存储，对比现有互联网，信息孤岛，各中心间不共享数据，数据不的不重复存储，IPFS一定意义上节约了空间，使得整个网络带宽消耗更低，网络更加高效。</p></li><li><p>相对于中心化存储的容易遭受DDOS攻击，IPFS采用分布式存储网络，文件被存储在不同的网络节点，天然避免了DDOS攻击，同时一个文件可以同时从多个节点同时下载，通信的效率也会更高。</p></li></ol><h2 id="IPNS"><a href="#IPNS" class="headerlink" title="IPNS"></a>IPNS</h2><p>在IPFS中，一个文件的哈希值完全取决于其内容，修改它的内容，其相应的Hash值也会发生改变。这样有一个优点是保证文件的不可篡改，提高数据的安全性。<br>但同时我们在开发应用（如网站）时，经常需要更新内容发布新版本，如果每次都让用户每次在浏览器中输入不同的IPFS地址来访问更新后内容的网页，这个体验肯定是无法接受的。</p><p>IPFS提供了一个解决方案IPNS(Inter-Planetary Naming System)，他提供了一个被私钥限定的IPNS哈希ID（通常是PeerID），其用来指向具体IPFS文件哈希，当有新的内容更新时，就可以更新IPNS哈希ID的指向。</p><p>为了方便大家理解，做一个类比，和DNS类似， DNS记录了域名指向的IP地址， 如果服务器更改，我们可以更改DNS域名指向，保证域名指向最新的服务器。<br>IPNS则是用一个哈希ID指向一个真实内容文件的Hash，文件更新这更改哈希ID的指向，当然更新指向需要有哈希ID对应的私钥。</p><p>通过IPNS访问文件的方式如下：</p><p>利用插件访问：ipns://QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva<br>利用网关访问： <a href="http://127.0.0.1:8080/ipns/QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva" target="_blank" rel="noopener">http://127.0.0.1:8080/ipns/QmYM36s4ut2TiufVvVUABSVWmx8VvmDU7xKUiVeswBuTva</a></p><p>IPNS同样兼容DNS，使用DNS TXT记录域名对应的IPNS哈希ID，就可以域名来替换IPNS哈希ID来进行访问。从而实现更容易读写和记忆。</p><p>例如使用以下方式简化访问：<br>ipns://ipfs.io<br><a href="https://ipfs.io/ipns/ipfs.io/" target="_blank" rel="noopener">https://ipfs.io/ipns/ipfs.io/</a></p><p>IPFS/IPNS 如果使用，将在后面的文章进一步介绍。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>IPFS是一项非常激动人心的技术，尽管它仍在发展的早期（区块链也是），还有很多问题需要我们一起解决，如NAT穿透问题，浏览器支持问题，内容存储激励问题，存储数据安全与隐私保护问题。<br>但是通过 IPFS + 区块链将真正创建Web3.0时代的应用，这是一个完全可信的、自运转（不停机）的应用，它可以做什么我不知道，我对未来充满期待。</p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管网络上，已经有不少文章讨论IPFS，不过真正讲明白IPFS想做什么的很少，文本尝试站在未来Web3.0的高度来看看IPFS究竟用来解决什么问题。&lt;/p&gt;
    
    </summary>
    
      <category term="IPFS" scheme="https://learnblockchain.cn/categories/IPFS/"/>
    
    
      <category term="IPFS" scheme="https://learnblockchain.cn/tags/IPFS/"/>
    
      <category term="Web3" scheme="https://learnblockchain.cn/tags/Web3/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术工坊</title>
    <link href="https://learnblockchain.cn/2018/12/12/dev_meeting/"/>
    <id>https://learnblockchain.cn/2018/12/12/dev_meeting/</id>
    <published>2018-12-12T03:25:59.000Z</published>
    <updated>2018-12-22T11:37:50.033Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我们是谁、我们的目标</strong><br>区块链技术工坊主要由HiBlock社区牵头，在全国各主要城市由一群热爱区块链技术开发者组织的技术分享活动。<br>深圳地区由Tiny熊组织，我们每周四晚上邀请一位技术大咖进行分享，由于区块链技术涉及面广、发展快速，我们希望通过这个分享大家能够一起学习交流、共同成长。</p><p><strong>如何加入</strong><br>很简单，在活动行报名即可，最新一期交流：区块链的设计思想和演化逻辑，<a href="http://hiblock.huodongxing.com/event/6470529423511" target="_blank" rel="noopener">戳链接报名</a>。<br>如果你进行分享，欢迎联系Tiny熊，微信：xlbxiong</p><p><strong>致谢</strong><br>一个活动，单靠几个爱好的的兴趣是不够的，因此要感谢中能链提供场地支持，以及多个优秀的区块链项目：以太零、Qtum、FIBOS、AckBlock、HPB对活动的大力赞助。如果你有兴趣赞助，请联系Tiny熊了解权益和义务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;我们是谁、我们的目标&lt;/strong&gt;&lt;br&gt;区块链技术工坊主要由HiBlock社区牵头，在全国各主要城市由一群热爱区块链技术开发者组织的技术分享活动。&lt;br&gt;深圳地区由Tiny熊组织，我们每周四晚上邀请一位技术大咖进行分享，由于区块链技术涉及面广、发展快速
      
    
    </summary>
    
      <category term="技术工坊" scheme="https://learnblockchain.cn/categories/dev-meeting/"/>
    
    
  </entry>
  
  <entry>
    <title>联盟链初识以及Fabric环境搭建流程</title>
    <link href="https://learnblockchain.cn/2018/11/21/fabric_introduction/"/>
    <id>https://learnblockchain.cn/2018/11/21/fabric_introduction/</id>
    <published>2018-11-21T09:30:27.000Z</published>
    <updated>2018-11-27T13:36:35.791Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章首先简单介绍了联盟链是什么，再详细的介绍了Fabric环境搭建的整个流程。<br><a id="more"></a></p><h2 id="区块链分类"><a href="#区块链分类" class="headerlink" title="区块链分类"></a>区块链分类</h2><p>以参与方式分类，区块链可以分为：公有链、联盟链和私有链。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们知道区块链就是一个分布式的，去中心化的公共数据库（或称公共账本）。而联盟链是区块链的一个分支，所以它本身也是一个分布式的，去中心化的公共数据库，跟其他链的区别就是它是针对特定群体的成员和有限的第三方，其内部指定多个预选节点为记账人，其共识过程受到预选节点控制的区块链</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>联盟链本质仍然是一种私有链，只不过它要比单个小组织开发的私有链更大，但是却没有公有链这么大的规模，可以理解为它是介于公有链和私有链的一种区块链。</p><h2 id="联盟链的特点"><a href="#联盟链的特点" class="headerlink" title="联盟链的特点"></a>联盟链的特点</h2><ul><li>交易速度快<br> 我们知道对于公有链来说，要想达成共识，必须得由区块链中的所有节点来决定，本身公有链的节点数量就非常庞大，所以处理速度很慢。但对于联盟链来说，由于其节点不多的原因，而且只要当网络上2/3的节点达成共识，就可以完成交易，交易速度自然也就快很多。</li><li>数据默认不会公开<br> 不同于公有链，联盟链上的信息并不是所有有访问条件的人就可以访问的，联盟链的数据只限于联盟里的机构及其用户才有权限进行访问。</li><li>部分去中心化<br>与公有链不同，联盟链某种程度上只属于联盟内部的所有成员所有，且很容易达成共识，因为其节点数毕竟是有限的。</li></ul><h3 id="联盟链项目"><a href="#联盟链项目" class="headerlink" title="联盟链项目"></a>联盟链项目</h3><p>R3：由40多加银行参与的区块链联盟R3，包括世界著名的银行（如摩根大通、高盛、瑞信、伯克莱、汇丰银行等），IT巨头（如IBM、微软）。</p><p>超级账本（Hyperledger）:由 Linux基金会在2015年12月主导发起该项目， 成员包括金融，银行，物联网，供应链，制造和科技行业的领头羊。</p><h2 id="Fabric介绍"><a href="#Fabric介绍" class="headerlink" title="Fabric介绍"></a>Fabric介绍</h2><p>我们知道智能合约比较成功的就是以太坊了。以太坊主要是公有链，其实对企业应用来说并不是特别合适，而且本身并没有权限控制功能，面向企业的，主要还是HyperLedger Fabric，当然还有R3的Corda。这里我们主要是讲Fabric。<br>Fabric是一个面向企业应用的区块链框架，基于Fabric的开发可以粗略分为几个层面：</p><p><strong>1.</strong> 参与Fabric的底层开发，这主要是fabric，fabric-ca和sdk等核心组件。<br><strong>2.</strong> 参与Fabric周边生态的开发，如支持如支持fabric的工具explorer, composer等。<br><strong>3.</strong> 利用fabric平台开发应用，这就是利用fabirc提供的各种sdk来为应用服务（应用开发）</p><p>大部分企业会参与2-3的内容，以3为主来服务应用场景，以2为辅。因为现在除了区块链核心功能尚未完善外，对区块链的管理，运维，监控，测试，优化，调试等工具非常匮乏。企业将不得不面对自己开发一些工作。</p><h3 id="Fabric环境依赖"><a href="#Fabric环境依赖" class="headerlink" title="Fabric环境依赖"></a>Fabric环境依赖</h3><p>Fabric官方推荐的开发环境是基于docker搭建的,使用docker搭建需要一下前置条件：</p><ul><li>docker一一Docker version 17.06.2-ce 或以上版本</li><li>Docker Compose一一1.14或以上版本</li><li>Go一一1.10或以上版本， Node.js一一8.9.x或以上版本</li><li>Python一一主要是python-pip</li></ul><h3 id="Fabric环境搭建具体步骤"><a href="#Fabric环境搭建具体步骤" class="headerlink" title="Fabric环境搭建具体步骤"></a>Fabric环境搭建具体步骤</h3><p>这里使用的是Ubuntu 16.04.4版本</p><h4 id="1-安装go及环境变量配置"><a href="#1-安装go及环境变量配置" class="headerlink" title="1.安装go及环境变量配置"></a><strong>1.安装go及环境变量配置</strong></h4><p>(1)下载最新版本的go二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.google.com/go/go1.9.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>(2)解压文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar -C /usr/local -xzf go1.9.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>(3)配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.profile</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=$HOME/go</span><br><span class="line">export PATH=$PATH:$HOME/go/bin</span><br></pre></td></tr></table></figure><p>编辑保存并退出vi后，记得使这些环境变量生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure><h4 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2.安装Docker"></a><strong>2.安装Docker</strong></h4><p>Fabric的chaincode是运行在docker里的。</p><p><strong>(1)</strong> 由于apt官方库里的docker版本可能比较旧，所以先卸载可能存在的旧版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker-ce docker.io</span><br></pre></td></tr></table></figure><p><strong>(2)</strong> 更新apt包索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p><strong>(3)</strong> 安装以下包以使apt可以通过HTTPS使用存储库（repository）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><p><strong>(4)</strong> 添加Docker官方的GPG密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">备注：可验证秘钥指纹 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</span><br><span class="line">使用如下命令验证：</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p><strong>(5)</strong> 使用下面的命令来设置stable存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p><strong>(6)</strong> 再更新一下apt包索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p><strong>(7)</strong> 安装最新版本的Docker CE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y docker-ce</span><br><span class="line">注意：在生产系统上，可能会需要应该安装一个特定版本的Docker CE，而不是总是使用最新版本：</span><br><span class="line">列出可用的版本：apt-cache madison docker-ce</span><br><span class="line">选择要安装的特定版本，第二列是版本字符串，第三列是存储库名称，它指示包来自哪个存储库，以及扩展它的稳定性级别。要安装一个特定的版本，将版本字符串附加到包名中，并通过等号(=)分隔它们：</span><br><span class="line">sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure><p><strong>(8)</strong> 测试是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure><p><strong>(9)</strong> 使用阿里提供的镜像,否则后面下载Fabric镜像会非常慢<br>cd到/etc/docker目录下,创建文件daemon.json，输入下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;https://obou6wyb.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存并退出，接着执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p><strong>(10)</strong> 查看docker服务是否启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p><strong>(11)</strong> 若未启动，则启动docker服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start或者sudo systemctl start docker</span><br></pre></td></tr></table></figure><h4 id="3-安装最新版本的Docker-compose"><a href="#3-安装最新版本的Docker-compose" class="headerlink" title="3.安装最新版本的Docker-compose"></a><strong>3.安装最新版本的Docker-compose</strong></h4><p><strong>(1)</strong> Docker-compose是支持通过模板脚本批量创建Docker容器的一个组件。在安装Docker-Compose之前，需要安装Python-pip，运行脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><p><strong>(2)</strong> 安装Docker-compose：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><p><strong>(3)</strong> 验证是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose --version</span><br></pre></td></tr></table></figure><p>安装Docker还可以参考<a href="https://blog.csdn.net/so5418418/article/details/78355868" target="_blank" rel="noopener">此篇文章</a></p><h4 id="4-Fabric源码下载"><a href="#4-Fabric源码下载" class="headerlink" title="4.Fabric源码下载"></a><strong>4.Fabric源码下载</strong></h4><p><strong>(1)</strong> 新建存放测试、部署代码的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/go/src/github.com/hyperledger/</span><br></pre></td></tr></table></figure><p><strong>(2)</strong> cd到刚创建的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/go/src/github.com/hyperledger</span><br></pre></td></tr></table></figure><p><strong>(3)</strong> 下载Fabric,这里使用使用git命令下载源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure><p><strong>特别注意这里：</strong><br>直接使用上面的git clone下载会非常慢，因为github.global.ssl.fastly.Net域名被限制了。只要找到这个域名对应的ip地址，然后在hosts文件中加上ip–&gt;域名的映射，刷新DNS缓存就可以了。<br>解决办法：<br>步骤【1】:查询域名<code>global-ssl.fastly.Net</code>和 <code>github.com</code> 公网地址<br>可以使用<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 这个查。<br>分别查找下面这两个域名的ip地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github.global.ssl.fastly.net</span><br><span class="line">github.com</span><br></pre></td></tr></table></figure><p>步骤【2】:将ip地址添加到hosts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>在文件下方输入下面内容并保存，前面两个ip就是我们刚才上面查找到的ip：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">151.101.185.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.113 github.com</span><br></pre></td></tr></table></figure><p>步骤【3】：修改完hosts还不会立即生效，你需要刷新DNS缓存，告诉电脑我的hosts文件已经修改了。<br>输入指令：<br>sudo /etc/init.d/networking restart 即可，如果不行也可以尝试重启一下电脑。<br>接下来再去git clone就快很多了。</p><p><strong>(4)</strong> 由于Fabric一直在更新，新版本的并不稳定，所有我们并不需要最新的源码，需要切换到v1.0.0版本的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout v1.0.0</span><br></pre></td></tr></table></figure><h4 id="5-下载Fabric-Docker镜像"><a href="#5-下载Fabric-Docker镜像" class="headerlink" title="5.下载Fabric  Docker镜像"></a><strong>5.下载Fabric  Docker镜像</strong></h4><p><strong>(1)</strong> 前面步骤4下载完成后，我们可以看到当前工作目录(~/go/src/github.com/hyperledger/)下多了一个fabric的文件夹,<br>接下来我们cd到~/go/src/github.com/hyperledger/fabric/examples/e2e_cli目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source download-dockerimages.sh -c x86_64-1.0.0 -f x86_64-1.0.0</span><br></pre></td></tr></table></figure><p>(注：一定要下载完所有镜像并且镜像版本要和Fabric版本一致如何没有下载问继续执行source download-dockerimages.sh命令直到在完如图所有镜像)，执行完所有会用到的Fabric docker镜像都会下载下来了。<br>运行以下命令检查下载的镜像列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果下载时遇到权限问题，需要切换到root用户下：su root<br><strong>(2)</strong> 重启Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h4 id="6-测试Fabric环境是否成功"><a href="#6-测试Fabric环境是否成功" class="headerlink" title="6.测试Fabric环境是否成功"></a><strong>6.测试Fabric环境是否成功</strong></h4><p>在~/go/src/github.com/hyperledger/fabric/examples/e2e_cli下执行如下命令启动测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network_setup.sh up</span><br></pre></td></tr></table></figure><p>这个指令具体进行了如下操作：</p><ol><li>编译生成Fabric公私钥、证书的程序，程序在目录：fabric/release/linux-amd64/bin</li><li>基于configtx.yaml生成创世区块和通道相关信息，并保存在channel-artifacts文件夹。基于configtx.yaml生成创世区块和通道相关信息，并保存在channel-artifacts文件夹。</li><li>基于crypto-config.yaml生成公私钥和证书信息，并保存在crypto-config文件夹中。基于crypto-config.yaml生成公私钥和证书信息，并保存在crypto-config文件夹中。</li><li>基于docker-compose-cli.yaml启动1Orderer+4Peer+1CLI的Fabric容器。基于docker-compose-cli.yaml启动1Orderer+4Peer+1CLI的Fabric容器。<br>在CLI启动的时候，会运行scripts/script.sh文件，这个脚本文件包含了创建Channel，加入Channel，安装Example02，运行Example02等功能。</li></ol><p>运行完如果出现下图所示，说明整个Fabric网络已经通了。<br><img src="/images/fabric_test.png" alt="在这里插入图片描述"></p><h4 id="这里记录本人测试Fabric环境是否成功时遇到的问题"><a href="#这里记录本人测试Fabric环境是否成功时遇到的问题" class="headerlink" title="这里记录本人测试Fabric环境是否成功时遇到的问题"></a>这里记录本人测试Fabric环境是否成功时遇到的问题</h4><p><strong>1.</strong> 如果发现运行 <strong>./network_setup.sh up</strong>命令 后提示在…fabric/release/linux-amd64/bin文件夹下找不到指定文件<br><strong>解决办法</strong>：<br>可以在~/go/src/github.com/hyperledger/fabric/scripts文件下找到 <strong>bootstrap.1.0.0.sh</strong>文件，手动运行它    <strong>./bootstrap.1.0.0.sh</strong>， 此时可以在当前文件夹生成一个<strong>bin</strong>文件夹，bin里面的文件就是我们需要的，将它拷贝到前面的…fabric/release/linux-amd64/bin文件夹下</p><p><strong>2.</strong> 如果出现：Error on outputBlock: Error writing genesis block: open ./channel-artifacts/genesis.block: is a directory不能生成创世块的错误。<br><strong>解决办法：</strong><br>可以在~/go/src/github.com/hyperledger/fabric/examples/e2e_cli/channel-artifacts目录下，将genesis.block这个目录删除，<strong>rm -rf genesis.block/</strong></p><p><strong>3.</strong> 如果出现：.ERROR: for orderer.example.com  Cannot start service orderer.example.com: b’OCI runtime create failed: container_linux.go:348: starting container process caused “process_linux.go:402: container init caused \“rootfs_linux.go:58:<br><strong>解决办法：</strong><br>执行./network_setup.sh down 清除网络后再启动即可</p><h3 id="测试Fabric网络"><a href="#测试Fabric网络" class="headerlink" title="测试Fabric网络"></a>测试Fabric网络</h3><p>接下来我们手动测试下Fabric网络，Fabric提供了SDK和CLI两种交互方式，这里我们使用的是CLI。<br>这里我们使用官方提供的小例子进行测试，在官方例子中，channel名字是mychannel，链码（智能合约）的名字是mycc。<br>首先要登录到CLI这个容器中，才能执行Fabric的CLI命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure><p>这时用户名变为root@caa22f87a5bf，当前目录变为/opt/go/src/github.com/hyperledger/fabric/peer#，接着可执行peer命令，体验区块链的命令行使用方式。</p><p><strong>1.查看a账户的余额</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure><p>此时我们可以看到控制台输出有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query Result: 90</span><br></pre></td></tr></table></figure><p>这里90就是a账户的余额</p><p><strong>2.调用链码，转账</strong></p><p>这里我们让b账户向a账户转账10：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o orderer.example.com:7050  --tls true --cafile /opt/go/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;b&quot;,&quot;a&quot;,&quot;10&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure><p>转账成功后，我们可以看到有输出如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBU 009 ESCC invoke result: version:1 response:&lt;status:200 message:&quot;OK&quot;</span><br></pre></td></tr></table></figure><p>接下来我们使用前面的命令继续查看a账户的余额，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query Result: 100</span><br></pre></td></tr></table></figure><p>很明显我们已经转账成功了。</p><p><strong>退出cli容器：</strong></p><p>直接执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>最后如果我们要关闭Fabric网络，cd到<code>~/go/src/github.com/hyperledger/fabric/examples/e2e_cli</code>下（注意这里的路径按自己前面创建的，不一定要和我一样），执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network_setup.sh down</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/github_34965845/article/details/80610060" target="_blank" rel="noopener">https://blog.csdn.net/github_34965845/article/details/80610060</a><br><a href="https://www.cnblogs.com/preminem/p/7729497.html" target="_blank" rel="noopener">https://www.cnblogs.com/preminem/p/7729497.html</a><br><a href="https://www.cnblogs.com/gao90/p/8692642.html" target="_blank" rel="noopener">https://www.cnblogs.com/gao90/p/8692642.html</a><br><a href="https://blog.csdn.net/so5418418/article/details/78355868" target="_blank" rel="noopener">https://blog.csdn.net/so5418418/article/details/78355868</a><br><a href="https://blog.csdn.net/iflow/article/details/77951610" target="_blank" rel="noopener">https://blog.csdn.net/iflow/article/details/77951610</a><br><a href="https://blog.csdn.net/vivian_ll/article/details/79966210" target="_blank" rel="noopener">https://blog.csdn.net/vivian_ll/article/details/79966210</a></p><p>本文的作者是lgy</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><p><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链知识星球</a>最专业技术问答社区，加入社区还可以在微信群里和300多位区块链技术爱好者一起交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章首先简单介绍了联盟链是什么，再详细的介绍了Fabric环境搭建的整个流程。&lt;br&gt;
    
    </summary>
    
      <category term="Fabric" scheme="https://learnblockchain.cn/categories/Fabric/"/>
    
      <category term="联盟链" scheme="https://learnblockchain.cn/categories/Fabric/%E8%81%94%E7%9B%9F%E9%93%BE/"/>
    
    
      <category term="Fabric" scheme="https://learnblockchain.cn/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric1.0 交易流程</title>
    <link href="https://learnblockchain.cn/2018/11/21/fabric_transaction_process/"/>
    <id>https://learnblockchain.cn/2018/11/21/fabric_transaction_process/</id>
    <published>2018-11-21T09:30:27.000Z</published>
    <updated>2018-12-14T08:43:52.048Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章详细介绍fabric的交易流程，以图片加文字的形式呈现。</p><a id="more"></a><h2 id="Fabric-1-0交易流程"><a href="#Fabric-1-0交易流程" class="headerlink" title="Fabric 1.0交易流程"></a>Fabric 1.0交易流程</h2><p>Fabric中的所有交易都是通过chaincode执行</p><p><img src="/images/transaction_process.png" alt=""></p><ol><li><p>应用程序客户端通过SDK调用证书服务（CA）服务，进行注册和登记，并获取身份证书。</p></li><li><p>应用程序客户端通过SDK创建好交易提案（Proposal），交易提案把带有本次交易要调用的合约标识、合约方法和参数信息以及客户端签名等信息发送给背书（Endorser）节点。</p></li><li><p>背书（Endorser）节点收到交易提案（Proposal）后，开始进行验证，验证的内容如下：</p><ul><li>交易预案是完好的</li><li>该预案以前没有提交过(防止重放攻击)</li><li>携带的签名是合法的</li><li>交易发起者是否满足区块链写策略， 即ACL 权限检查</li></ul></li></ol><p>满足以上要求后，背书节点把’交易预案’作为输入参数，调用chaincode中的函数，chaincode根据当前的账本状态计算出一个’交易结果’，该结果包括返回值，读写集。此时，区块链账本并不会被更新。’交易结果’在被签名后与一个是/否的背书结果一同返回，称之为’预案回复’。</p><ol><li><p>应用程序客户端收到背书（Endorser）节点返回的信息后，判断提案结果是否一致，以及是否收到足够多的背书节点返回的结果（参照指定的背书策略执行），如果没有足够的背书，则中止处理，这个交易就会被舍弃。否则，将交易提案、模拟交易结果和背书信息打包组成一个交易并签名发给Orderer节点（一个排序服务）。</p></li><li><p>Orderer节点对来自客户端（SDK）的交易信息进行共识排序，分通道对’交易消息’按时间排序，并按通道将交易打包成块，发送给提交（Committer）节点。</p></li><li><p>提交（Committer）节点收到区块后，会对区块中的每笔交易进行校验，检查交易依赖的输入输出是否符合当前区块链的状态，验证背书策略是否满足，验证完成后将区块追加到本地的区块链，更新账本，并修改世界状态。具体过程如下：</p><ul><li>运行验证逻辑（VSCC检查背书策略）</li><li>在区块中指明哪些交易是有效和无效的。</li><li>在内存或文件系统上把区块加入区块链</li><li>将区块内的有效交易写入状态数据库。</li><li>发出Event消息，使得客户端通过SDK监听知道哪些交易是有效的或无效的。</li></ul></li></ol><p>本文的作者是lgy</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章详细介绍fabric的交易流程，以图片加文字的形式呈现。&lt;/p&gt;
    
    </summary>
    
      <category term="Fabric" scheme="https://learnblockchain.cn/categories/Fabric/"/>
    
      <category term="联盟链" scheme="https://learnblockchain.cn/categories/Fabric/%E8%81%94%E7%9B%9F%E9%93%BE/"/>
    
    
      <category term="Fabric" scheme="https://learnblockchain.cn/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 网络环境启动过程详解</title>
    <link href="https://learnblockchain.cn/2018/11/21/fabric_startup%20_process/"/>
    <id>https://learnblockchain.cn/2018/11/21/fabric_startup _process/</id>
    <published>2018-11-21T09:30:27.000Z</published>
    <updated>2018-11-25T09:37:48.930Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章对Fabric的网络环境启动过程进行讲解,也就是我们<a href="https://learnblockchain.cn/2018/11/21/fabric_introduction/">上节</a>讲到的启动测试Fabric网络环境时运行network_setup.sh这个文件的执行流程</p><a id="more"></a><h2 id="Fabric网络环境启动过程详解"><a href="#Fabric网络环境启动过程详解" class="headerlink" title="Fabric网络环境启动过程详解"></a>Fabric网络环境启动过程详解</h2><p>上一节我们讲到 fabric网络环境的启动测试，主要是使用 <strong>./network_setup.sh  up</strong> 这个命令，所以fabric网络环境启动的重点就在network_setup.sh这个文件中。接下来我们就分析一下network_setup.sh这个文件。<br>network_setup.sh其中包括两个部分，一个是利用generateArtifacts.sh脚本文件配置组织关系和颁发证书、公/私钥、通道证书等，另一个是docker-compose-cli.yaml用于根据配置启动集群并测试chaincode的示例代码。下面是具体的流程图介绍：</p><p><img src="/images/startup _process.png" alt=""></p><p><strong>首先看下generateArtifacts.sh脚本文件，它包含三个函数，分别是：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.generateCerts：</span><br><span class="line"> 该函数使用cryptogen工具根据crypto-config.yaml来生成公私钥和证书信息等。</span><br><span class="line"></span><br><span class="line">2.replacePrivateKey：</span><br><span class="line"> 将docker-compose-e2e-template.yaml文档中的ca私钥替换成具体的私钥。</span><br><span class="line"></span><br><span class="line">3.generateChannelArtifacts：</span><br><span class="line"> 使用configtxgen工具根据configtx.yaml文件来生成创世区块和通道相关信息，更新锚节点。</span><br></pre></td></tr></table></figure><p><strong>接着是docker-compose-cli.yaml文件</strong></p><p>docker-compose-cli.yaml文件根据组织关系启动docker集群，并在cli容器中执行command命令运行./scripts/script.sh脚本文件。 那./scripts/script.sh脚本具体做了什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. createChannel：创建channel。</span><br><span class="line">2. joinChannel：将每个peer节点加入channel。</span><br><span class="line">3. updateAnchorPeers：更新锚节点</span><br><span class="line">4. installChaincode：部署chaincode。</span><br><span class="line">5. instantiateChaincode：初始化chaincode。</span><br><span class="line">6. chaincodeQuery：chaincode查询</span><br></pre></td></tr></table></figure><p>另外docker-compose-cli.yaml这个文件还有一个配置项是需要注意的地方，那就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:  base/docker-compose-base.yaml</span><br></pre></td></tr></table></figure><p>这里的docker-compose-base.yaml其实就是Orderer和peer的基础配置文件，包括指定端口等。</p><h3 id="几个重要的配置文件"><a href="#几个重要的配置文件" class="headerlink" title="几个重要的配置文件"></a>几个重要的配置文件</h3><h4 id="1-crypto-config-yaml"><a href="#1-crypto-config-yaml" class="headerlink" title="1.crypto-config.yaml"></a>1.crypto-config.yaml</h4><p>基于crypto-config.yaml（此文件在../fabric/examples/e2e_cli中）<strong>生成公、私钥和证书信息，并保存在crypto-config文件夹中</strong>。另外crypto-config.yaml还定义了组织成员以及组织下的peer节点个数。</p><p><strong>crypto-config.yaml文件讲解：</strong></p><p>字段Name和Domain就是关于这个组织的名字和域名，这主要是用于生成证书的时候，证书内会包含该信息。而Template.Count=2是说我们要生成2套公私钥和证书，一套是peer0.org1的，还有一套是peer1.org1的（也就指定了org中存在peer0和peer1两个节点）。最后Users.Count=1是说每个Template下面会有几个普通User（注意，Admin是Admin，不包含在这个计数中），这里配置了1，也就是说我们只需要一个普通用户User1@org1.example.com 我们可以根据实际需要调整这个配置文件，增删Org Users等。文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  # ---------------------------------------------------------------------------</span><br><span class="line">  # Orderer</span><br><span class="line">  # ---------------------------------------------------------------------------</span><br><span class="line">  - Name: Orderer</span><br><span class="line">    Domain: example.com</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    # &quot;Specs&quot; - See PeerOrgs below for complete description</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    Specs:</span><br><span class="line">      - Hostname: orderer</span><br><span class="line"># ---------------------------------------------------------------------------</span><br><span class="line"># &quot;PeerOrgs&quot; - Definition of organizations managing peer nodes</span><br><span class="line"># ---------------------------------------------------------------------------</span><br><span class="line">PeerOrgs:</span><br><span class="line">  # ---------------------------------------------------------------------------</span><br><span class="line">  # Org1</span><br><span class="line">  # ---------------------------------------------------------------------------</span><br><span class="line">  - Name: Org1</span><br><span class="line">    Domain: org1.example.com</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    # &quot;Specs&quot;</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    # Uncomment this section to enable the explicit definition of hosts in your</span><br><span class="line">    # configuration.  Most users will want to use Template, below</span><br><span class="line">    #</span><br><span class="line">    # Specs is an array of Spec entries.  Each Spec entry consists of two fields:</span><br><span class="line">    #   - Hostname:   (Required) The desired hostname, sans the domain.</span><br><span class="line">    #   - CommonName: (Optional) Specifies the template or explicit override for</span><br><span class="line">    #                 the CN.  By default, this is the template:</span><br><span class="line">    #</span><br><span class="line">    #                              &quot;&#123;&#123;.Hostname&#125;&#125;.&#123;&#123;.Domain&#125;&#125;&quot;</span><br><span class="line">    #</span><br><span class="line">    #                 which obtains its values from the Spec.Hostname and</span><br><span class="line">    #                 Org.Domain, respectively.</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    # Specs:</span><br><span class="line">    #   - Hostname: foo # implicitly &quot;foo.org1.example.com&quot;</span><br><span class="line">    #     CommonName: foo27.org5.example.com # overrides Hostname-based FQDN set above</span><br><span class="line">    #   - Hostname: bar</span><br><span class="line">    #   - Hostname: baz</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    # &quot;Template&quot;</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    # Allows for the definition of 1 or more hosts that are created sequentially</span><br><span class="line">    # from a template. By default, this looks like &quot;peer%d&quot; from 0 to Count-1.</span><br><span class="line">    # You may override the number of nodes (Count), the starting index (Start)</span><br><span class="line">    # or the template used to construct the name (Hostname).</span><br><span class="line">    #</span><br><span class="line">    # Note: Template and Specs are not mutually exclusive.  You may define both</span><br><span class="line">    # sections and the aggregate nodes will be created for you.  Take care with</span><br><span class="line">    # name collisions</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    Template:</span><br><span class="line">      Count: 2</span><br><span class="line">      # Start: 5</span><br><span class="line">      # Hostname: &#123;&#123;.Prefix&#125;&#125;&#123;&#123;.Index&#125;&#125; # default</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    # &quot;Users&quot;</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    # Count: The number of user accounts _in addition_ to Admin</span><br><span class="line">    # ---------------------------------------------------------------------------</span><br><span class="line">    Users:</span><br><span class="line">      Count: 1</span><br><span class="line">  # ---------------------------------------------------------------------------</span><br><span class="line">  # Org2: See &quot;Org1&quot; for full specification</span><br><span class="line">  # ---------------------------------------------------------------------------</span><br><span class="line">  - Name: Org2</span><br><span class="line">    Domain: org2.example.com</span><br><span class="line">    Template:</span><br><span class="line">      Count: 2</span><br><span class="line">    Users:</span><br><span class="line">      Count: 1</span><br></pre></td></tr></table></figure><p><strong>注：</strong><br>peer：<br>Fabric 网络中的节点，表现为一个运行着的docker容器。可以与网络中的其他peer进行通信，每个peer都在本地保留一份ledger的副本。它是org下的组织成员。<br>org:<br>一个组织，它可以由一个或多个peer组成。<br>Orderer :<br>联盟成员共享的中心化节点。用来对交易进行排序，是 Fabric 共识机制的重要组成部分。</p><h4 id="2-configtx-yaml"><a href="#2-configtx-yaml" class="headerlink" title="2.configtx.yaml"></a>2.configtx.yaml</h4><p>基于configtx.yaml（此文件在../fabric/examples/e2e_cli中）<strong>生成创世区块和通道相关信息，并保存在channel-artifacts文件夹。还可以指定背书策略。</strong></p><p><strong>configtx.yaml文件讲解：</strong></p><ol><li>官方提供的examples/e2e_cli/configtx.yaml这个文件里面配置了由2个Org参与的Orderer共识配置TwoOrgsOrdererGenesis，以及由2个Org参与的Channel配置：TwoOrgsChannel。</li><li>另外我们可以在此文件的Orderer部分设置共识的算法是Solo还是Kafka，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而Peer节点的配置包含了MSP的配置，锚节点的配置。如果我们有更多的Org，或者有更多的Channel，那么就可以根据模板进行对应的修改。</li><li>Policies配置也要特别注意，该配置项定义了不同角色的权限,Reader,Writer以及Admin分别对应读，写，以及admin权限,读权限角色只能从别的peer节点同步账本而不能发起交易，只有writer定义项下的角色才拥有发起交易的也就是调用chaincode的invoke方法的权限(不一定都是invoke方案，只要涉及到chaincode中状态修改的方法，都只有拥有writer权限或admin权限的角色才能调用)。以该配置的Organizations配置下的Org1配置为例,”OR(‘Org1MSP.admin’, ‘Org1MSP.client’)”,表示org1的msp服务中的admin或者client角色拥有发起交易的权限。文件内容如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"># Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># SPDX-License-Identifier: Apache-2.0</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">################################################################################</span><br><span class="line">#</span><br><span class="line">#   Profile</span><br><span class="line">#</span><br><span class="line">#   - Different configuration profiles may be encoded here to be specified</span><br><span class="line">#   as parameters to the configtxgen tool</span><br><span class="line">#</span><br><span class="line">################################################################################</span><br><span class="line">Profiles:</span><br><span class="line"></span><br><span class="line">    TwoOrgsOrdererGenesis:</span><br><span class="line">        Orderer:</span><br><span class="line">            &lt;&lt;: *OrdererDefaults</span><br><span class="line">            Organizations:</span><br><span class="line">                - *OrdererOrg</span><br><span class="line">        Consortiums:</span><br><span class="line">            SampleConsortium:</span><br><span class="line">                Organizations:</span><br><span class="line">                    - *Org1</span><br><span class="line">                    - *Org2</span><br><span class="line">    TwoOrgsChannel:</span><br><span class="line">        Consortium: SampleConsortium</span><br><span class="line">        Application:</span><br><span class="line">            &lt;&lt;: *ApplicationDefaults</span><br><span class="line">            Organizations:</span><br><span class="line">                - *Org1</span><br><span class="line">                - *Org2</span><br><span class="line"></span><br><span class="line">################################################################################</span><br><span class="line">#</span><br><span class="line">#   Section: Organizations</span><br><span class="line">#</span><br><span class="line">#   - This section defines the different organizational identities which will</span><br><span class="line">#   be referenced later in the configuration.</span><br><span class="line">#</span><br><span class="line">################################################################################</span><br><span class="line">Organizations:</span><br><span class="line"></span><br><span class="line">    # SampleOrg defines an MSP using the sampleconfig.  It should never be used</span><br><span class="line">    # in production but may be used as a template for other definitions</span><br><span class="line">    - &amp;OrdererOrg</span><br><span class="line">        # DefaultOrg defines the organization which is used in the sampleconfig</span><br><span class="line">        # of the fabric.git development environment</span><br><span class="line">        Name: OrdererOrg</span><br><span class="line"></span><br><span class="line">        # ID to load the MSP definition as</span><br><span class="line">        ID: OrdererMSP</span><br><span class="line"></span><br><span class="line">        # MSPDir is the filesystem path which contains the MSP configuration</span><br><span class="line">        MSPDir: crypto-config/ordererOrganizations/example.com/msp</span><br><span class="line"></span><br><span class="line">    - &amp;Org1</span><br><span class="line">        # DefaultOrg defines the organization which is used in the sampleconfig</span><br><span class="line">        # of the fabric.git development environment</span><br><span class="line">        Name: Org1MSP</span><br><span class="line"></span><br><span class="line">        # ID to load the MSP definition as</span><br><span class="line">        ID: Org1MSP</span><br><span class="line"></span><br><span class="line">        MSPDir: crypto-config/peerOrganizations/org1.example.com/msp</span><br><span class="line"></span><br><span class="line">        AnchorPeers:</span><br><span class="line">            # AnchorPeers defines the location of peers which can be used</span><br><span class="line">            # for cross org gossip communication.  Note, this value is only</span><br><span class="line">            # encoded in the genesis block in the Application section context</span><br><span class="line">            - Host: peer0.org1.example.com</span><br><span class="line">              Port: 7051</span><br><span class="line"></span><br><span class="line">    - &amp;Org2</span><br><span class="line">        # DefaultOrg defines the organization which is used in the sampleconfig</span><br><span class="line">        # of the fabric.git development environment</span><br><span class="line">        Name: Org2MSP</span><br><span class="line"></span><br><span class="line">        # ID to load the MSP definition as</span><br><span class="line">        ID: Org2MSP</span><br><span class="line"></span><br><span class="line">        MSPDir: crypto-config/peerOrganizations/org2.example.com/msp</span><br><span class="line"></span><br><span class="line">        AnchorPeers:</span><br><span class="line">            # AnchorPeers defines the location of peers which can be used</span><br><span class="line">            # for cross org gossip communication.  Note, this value is only</span><br><span class="line">            # encoded in the genesis block in the Application section context</span><br><span class="line">            - Host: peer0.org2.example.com</span><br><span class="line">              Port: 7051</span><br><span class="line"></span><br><span class="line">################################################################################</span><br><span class="line">#</span><br><span class="line">#   SECTION: Orderer</span><br><span class="line">#</span><br><span class="line">#   - This section defines the values to encode into a config transaction or</span><br><span class="line">#   genesis block for orderer related parameters</span><br><span class="line">#</span><br><span class="line">################################################################################</span><br><span class="line">Orderer: &amp;OrdererDefaults</span><br><span class="line"></span><br><span class="line">    # Orderer Type: The orderer implementation to start</span><br><span class="line">    # Available types are &quot;solo&quot; and &quot;kafka&quot;</span><br><span class="line">    OrdererType: solo</span><br><span class="line"></span><br><span class="line">    Addresses:</span><br><span class="line">        - orderer.example.com:7050</span><br><span class="line"></span><br><span class="line">    # Batch Timeout: The amount of time to wait before creating a batch</span><br><span class="line">    BatchTimeout: 2s</span><br><span class="line"></span><br><span class="line">    # Batch Size: Controls the number of messages batched into a block</span><br><span class="line">    BatchSize:</span><br><span class="line"></span><br><span class="line">        # Max Message Count: The maximum number of messages to permit in a batch</span><br><span class="line">        MaxMessageCount: 10</span><br><span class="line"></span><br><span class="line">        # Absolute Max Bytes: The absolute maximum number of bytes allowed for</span><br><span class="line">        # the serialized messages in a batch.</span><br><span class="line">        AbsoluteMaxBytes: 98 MB</span><br><span class="line"></span><br><span class="line">        # Preferred Max Bytes: The preferred maximum number of bytes allowed for</span><br><span class="line">        # the serialized messages in a batch. A message larger than the preferred</span><br><span class="line">        # max bytes will result in a batch larger than preferred max bytes.</span><br><span class="line">        PreferredMaxBytes: 512 KB</span><br><span class="line"></span><br><span class="line">    Kafka:</span><br><span class="line">        # Brokers: A list of Kafka brokers to which the orderer connects</span><br><span class="line">        # NOTE: Use IP:port notation</span><br><span class="line">        Brokers:</span><br><span class="line">            - 127.0.0.1:9092</span><br><span class="line"></span><br><span class="line">    # Organizations is the list of orgs which are defined as participants on</span><br><span class="line">    # the orderer side of the network</span><br><span class="line">    Organizations:</span><br><span class="line"></span><br><span class="line">################################################################################</span><br><span class="line">#</span><br><span class="line">#   SECTION: Application</span><br><span class="line">#</span><br><span class="line">#   - This section defines the values to encode into a config transaction or</span><br><span class="line">#   genesis block for application related parameters</span><br><span class="line">#</span><br><span class="line">################################################################################</span><br><span class="line">Application: &amp;ApplicationDefaults</span><br><span class="line"></span><br><span class="line">    # Organizations is the list of orgs which are defined as participants on</span><br><span class="line">    # the application side of the network</span><br><span class="line">    Organizations:</span><br></pre></td></tr></table></figure><p>本文的作者是lgy</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章对Fabric的网络环境启动过程进行讲解,也就是我们&lt;a href=&quot;https://learnblockchain.cn/2018/11/21/fabric_introduction/&quot;&gt;上节&lt;/a&gt;讲到的启动测试Fabric网络环境时运行network_setup.sh这个文件的执行流程&lt;/p&gt;
    
    </summary>
    
      <category term="Fabric" scheme="https://learnblockchain.cn/categories/Fabric/"/>
    
      <category term="联盟链" scheme="https://learnblockchain.cn/categories/Fabric/%E8%81%94%E7%9B%9F%E9%93%BE/"/>
    
    
      <category term="Fabric" scheme="https://learnblockchain.cn/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Plasma（四）Plasma Cash</title>
    <link href="https://learnblockchain.cn/2018/11/16/plasma-cash/"/>
    <id>https://learnblockchain.cn/2018/11/16/plasma-cash/</id>
    <published>2018-11-16T04:44:17.000Z</published>
    <updated>2018-11-25T09:25:43.312Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列文章将围绕以太坊的二层扩容框架 Plasma，介绍其基本运行原理，具体操作细节，安全性讨论以及未来研究方向等。本篇文章主要介绍在 Plasma 框架下的项目 Plasma Cash。</p><a id="more"></a><p>在<a href="https://github.com/gitferry/mastering-ethereum/blob/master/Plasma-in-depth/plasma-mvp.md" target="_blank" rel="noopener">上一篇</a>文章中我们已经理解了 Plasma 的最小实现 Plasma MVP 如何使用 UTXO 模型实现 Plasma 链下扩容的核心思想。但由于 Plasma MVP 本身过于简单，并不能用于实际的生产环境中。2018 年 3 月，在巴黎举行的以太坊开发者大会上，Vitalik 发布了 Plasma Cash 模型<a href="https://ethresear.ch/t/plasma-cash-plasma-with-much-less-per-user-data-checking/1298" target="_blank" rel="noopener">[1]</a>，可以视为对 Plasma MVP 的改进。Plasma Cash 与 Plasma MVP 的主要区别是每次存款操作都会产生一个唯一的 coin ID 对应转移到侧链上的资产，并使用一种称为稀疏梅克尔树（Sparse Merkle Tree）的数据结构存储交易历史。由此带来的好处是用户不需要关注子链上的每个动态，只需要关注跟自己的 token 有关的动态。在下文中将介绍具体细节。</p><h3 id="存款（Deposits）"><a href="#存款（Deposits）" class="headerlink" title="存款（Deposits）"></a>存款（Deposits）</h3><p>Plasma Cash 中的每次存款操作都会对应产生一个 NFT（non-fungible token）<a href="https://en.wikipedia.org/wiki/Non-fungible_token" target="_blank" rel="noopener">[2]</a>。NFT 可以简单理解为“不可互换的 token”，即每个 token 都是独一无二的，由唯一的 ID 标记。以太坊官方为 NFT 提供了 ERC721 标准<a href="http://erc721.org/" target="_blank" rel="noopener">[3]</a>，在之前火爆到阻塞以太坊的 CryptoKitties 就是由 ERC721 合约实现的。</p><p>在 Plasma Cash 中，当用户向 Plasma 合约发送存款交易时，合约会生成一个与存款等值的 token，并给这个 token 分配一个唯一的 ID。如果一个用户分别执行两次存款操作，且每次存款都是 5 ETH，那么他将得到相等价值的两个完全不同的 token。和 Plasma MVP 一样，每次存款操作都会使得 Plasma 合约产生一个只包含这个存款交易的区块。</p><h3 id="Plasma-Cash-区块"><a href="#Plasma-Cash-区块" class="headerlink" title="Plasma Cash 区块"></a>Plasma Cash 区块</h3><p>Plasma Cash 中的每个 token 都被分配唯一的 ID，因此可以按 ID 的顺序存储每个 token 的交易历史。Plasma Cash 的区块按 token ID 的顺序给每个 token 分配了一个插槽（slot），每个插槽会记录这个 token 是否被交易的信息。例如在下图（来源<a href="https://github.com/ethsociety/learn-plasma" target="_blank" rel="noopener">[4]</a>）的区块中，包含 4 个 token，id 分别是 #1，#2，#3，#4。其中 #1，#2，#3 被标记为没有被花费，而 #4 由用户 A 发送给用户 B。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/pc-block.png" width="600" height="190" alt="Plasma Cash Block"></p><p>从上面这个例子中我们可以看到，每个插槽记录了其所对应的 token 在当前区块中的交易状态，所有存储了某个 token 的交易状态的区块按时间顺序连在一起就构成了这个 token 的全部交易历史。每当一个 token 被分配了一个 id，之后的所有交易状态都会被保存在每个区块相同的插槽中，也不会被其它 token 取代。因此，用户只需要关注每个区块中存储属于自己的 token 的状态，完全不用关心别的插槽存储的内容。</p><h3 id="交易与验证"><a href="#交易与验证" class="headerlink" title="交易与验证"></a>交易与验证</h3><p>由于 Plasma Cash 中的节点只追踪属于自己的 token 的交易历史，因此当有交易发生时，token 的发送者要向接收者提供关于这个 token 所有的交易历史（从存款交易开始）以便接收者验证。从下图（来源<a href="https://github.com/ethsociety/learn-plasma" target="_blank" rel="noopener">[4]</a>）的例子中可以看到 4 个区块中所记录的 4 个 token 的交易历史。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/pc-tx.png" width="400" height="500" alt="Plasma Cash TXs"></p><p>截止到区块 #4，可以看到token #1 和 token #3 始终没有被交易。token #2 在区块 #2 被 E 发送给了 F，在区块 #4 被 F 发送给了 G，在其它区块没有发生交易，token #2 的最终所有权归 G。token #4 在区块 #1 被 A 发送给了 B，在区块 #3 被 B 发送给了 C，在其它区块没有发生交易，token #4 的最终所有权归 C。F 为了向 G 证明 token #2 的合法性，需要向 G 提供 token #2 在前 4 个区块中的所有交易历史，也就是说不仅需要包括区块 #2 中 E =&gt; F 的交易证明、区块 #4中 F =&gt; G 的交易证明，还要包括在区块 #1 和 #3 中没有被交易的证明。到这里可能感觉有点奇怪，为什么还要包括没有被交易的证明？这是为了防止双花，因为 G 并不知道在区块 #1 和 #3 中 token #2 是否被交易给了其它人。假如 F 在区块 #3 中将 token #2 发送给了 H，并且对 G 隐瞒了这个交易，那么发生在区块 #4 中的 F =&gt; G 就是非法（双花）的。因此，在 Plasma Cash 中，完整且合法的交易历史是一个 token 被安全交易的前提。</p><h3 id="稀疏梅克尔树（Sparse-Merkle-Tree）"><a href="#稀疏梅克尔树（Sparse-Merkle-Tree）" class="headerlink" title="稀疏梅克尔树（Sparse Merkle Tree）"></a>稀疏梅克尔树（Sparse Merkle Tree）</h3><p>在上文中我们已经了解到一个交易的成功的前提是需要发送方提供关于一个 token 的完整交易历史。完整的交易历史既包括这个 token 在哪些区块被交易的信息，也包括这个 token 在哪些区块没有被交易的信息。我们都知道，在区块链中，使用梅克尔树（Merkle Tree，MT）构造梅克尔证明（Merkel Proof, MP）可以在 O(logN)的时间复杂度验证一个交易是否存在一个区块中。但想要证明一个交易没有存在一个区块中，使用标准的梅克尔树却没那么容易。因此，Plasma Cash 中使用了一种称为稀疏梅克尔树（Sparse Merkle Tree，SMT）的数据结构存储交易数据，能够在O(logN)的时间复杂度验证一个交易不存在。</p><p>SMT 实际上一点都不复杂，它的叶子节点是按数据集中的元素序号顺序排列的。如果某个叶子节点对应的元素为空，那么该叶子节点将存储一个特定的值（例如 0 的哈希值）。一个简单的 SMT 示例如下图（来源<a href="https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837" target="_blank" rel="noopener">[5]</a>）所示。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/SMT.png" width="400" height="400" alt="Sparse Merkle Tree"></p><p>扩展到 Plasma Cash 中，SMT 的叶子节点对应了区块中给每个 token 分配的插槽，按照每个 token 的 ID 排序。每个叶子节点存储对应的 token 的交易信息，如果 token 在这个区块中没有被交易，则相应的叶子节点存储的值为 <em>null</em>。</p><p>以上图为例，如果需要证明交易 A 存在，就像在标准的 MT 中一样，需要构造 MP：H(null) 和 H(H(null) + H(D))。如果需要证明 B 不存在，同样很简单，我们已经知道 B 的位置是第二个叶子节点，如果 B 不存在，那么该节点存储的值应该为 <em>null</em>。因此就像在标准的 MT 中证明存在的 MP 一样，只不过需要加上 H(null) 作为 MP 的一部分，即 MP：H(null)、H(A)和 H(H(null)+H(D))。</p><h3 id="取款-退出（Withdrawl-Exit）"><a href="#取款-退出（Withdrawl-Exit）" class="headerlink" title="取款/退出（Withdrawl/Exit）"></a>取款/退出（Withdrawl/Exit）</h3><p>Plasma Cash 中的取款操作在流程上跟 Plasma MVP 大体相同，都要从提交取款申请开始，经历争议期之后才能完成。由于 Plasma Cash 中采用的数据结构不同，在取款时需要提交的 token 所有权证明不同，因此当争议发生时需要提交的争议证明也不同。</p><h4 id="提交取款申请"><a href="#提交取款申请" class="headerlink" title="提交取款申请"></a>提交取款申请</h4><p>在向 Plasma 合约提交关于某个 token 的取款申请时，需要提供关于这个 token 最近的两次交易证明。例如，在上图中，假如 G 想要取走 token #2 到主链，那么他需要提交关于 F =&gt; G 以及 E =&gt; F 的 Merkle Proof。</p><h4 id="提交争议"><a href="#提交争议" class="headerlink" title="提交争议"></a>提交争议</h4><p>取款者在提交了取款申请之后同样需要支付一定的保证金，并等待一段时间的争议期。在这期间如果有其它节点提交了有效的争议证明，那么取款者不但无法完成取款操作，也会损失全部或部分的保证金。</p><p>目前 Plasma Cash 支持三种争议证明，分别应对三种不同的攻击场景（具体会在后文分析）：</p><ol><li>已花费证明。如果能证明正在取款的 token 已经被花费，那么取款立即被取消；</li><li>双花证明。如果能证明取款申请中提供的两次交易证明中间还有别的交易，即发生了双花，那么取款立即被取消；</li><li>非法交易历史证明。用户还可以对正在取款的 token 的其它交易历史提出争议。这种争议不会立刻阻断取款，而是强制取款者提交其它交易证明来反驳争议，如果没有在规定时间内反驳，则取款被取消。</li></ol><h3 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h3><p>在这一节将讨论已有的 3 种攻击场景以及如何构造争议分别应对这些攻击<a href="https://karl.tech/plasma-cash-simple-spec/" target="_blank" rel="noopener">[6]</a>。在这里假设 Plasma Cash 中存在不可信的 operator 接收所有的交易并构造区块。</p><h4 id="发送交易后立即退出"><a href="#发送交易后立即退出" class="headerlink" title="发送交易后立即退出"></a>发送交易后立即退出</h4><p>如下图（来源<a href="https://github.com/loomnetwork/plasma-paper/blob/master/plasma_cash.pdf" target="_blank" rel="noopener">[7]</a>）所示，假设攻击者 Alice 向 Bob 发送了一个 token A，且 Bob 已经验证了 A 的交易历史没有问题，交易在区块 N+X 得到确认。在这之后，Alice 立即提交取款申请，企图将 token A 取回主链，并提交 A 在区块 N 以及之前的交易证明。为了应对这种情况，Bob 必须及时发现 Alice 的取款行为，并且在争议期结束前提交在区块 N+X 中 token A 被 Alice 发送给 Bob 的证明。这里需要注意的是，如果 Bob 在区块 N+Y 将 token A 发送给 Charlie 的交易是不能被当做争议证明的，只有最接近被争议的交易的下一个交易证明有效。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/attack1.png" width="700" height="220" alt="attack1"></p><h4 id="双花攻击"><a href="#双花攻击" class="headerlink" title="双花攻击"></a>双花攻击</h4><p>双花攻击需要 operator 配合，将含有已经被花费的 token 的交易打包入下一个区块中。如下图所示（来源<a href="https://github.com/loomnetwork/plasma-paper/blob/master/plasma_cash.pdf" target="_blank" rel="noopener">[7]</a>），攻击者 Alice 和 Charlie 是同谋，Alice 向 Bob 发送一个 token A 在区块 N+X 被确认，之后 Alice 又将 token A 发送给 Charlie，并在区块 N+Y 被确认。这时在主链看来，Bob 和 Charlie 都是 token A 的合法拥有者。接下来，Charlie 立即提交取款申请，企图取走 token A。Bob 为了防止自己的 token 被盗，可以在争议期内提交在区块 N+X 被确认的交易，表明自己在 Charlie 之前已经拥有了 token A。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/attack2.png" width="700" height="300" alt="attack2"></p><h4 id="取款包含非法交易历史"><a href="#取款包含非法交易历史" class="headerlink" title="取款包含非法交易历史"></a>取款包含非法交易历史</h4><p>这种攻击需要联合比较多的同谋者。如下图所示，Alice 在区块 N 拥有 token A。Bob 联合 operator、Charlie 以及 Dylan 企图盗走 Alice 的 token。首先，operator 伪造 Alice 将 token A 发送给 Bob 的交易，并在区块 N+X 得到确认，之后 Bob 将 token 发送给 Charlie，在区块 N+Y 确认。同样地，Charlie 接着将 token 发送给 Dylan，在区块 N+Z 确认。这是，Dylan 提出取款申请，企图取走 token A。Dylan 用于取款申请的两个交易证明 Charlie =&gt; Dylan 和 Bob =&gt; Charlie 都是合法的，但 token A 的交易历史中有一部分是伪造的。Alice 为了证明自己是 token A 的最新合法拥有者，可以提出争议，要求 Dylan 提供 Alice =&gt; Bob 的交易证明，同时 Alice 需要提交一部分保证金（否则任何人都可以随便提出争议）。Dylan 必须在一定的时间内提供合法的交易证明，否则取款失效。</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/attack3.png" width="900" height="250" alt="attack3"></p><h3 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h3><blockquote><p>Talk is cheap, show me your code.</p></blockquote><p>目前已经有许多机构和公司已经实现了 Plasma Cash，但实现的语言和细节有所不同：</p><ul><li>Loom Network <a href="https://github.com/loomnetwork/plasma-cash" target="_blank" rel="noopener">[8]</a></li><li>Omisego <a href="https://github.com/omisego/plasma-cash" target="_blank" rel="noopener">[9]</a></li><li>Wolk <a href="https://github.com/wolkdb/deepblockchains/tree/master/Plasmacash" target="_blank" rel="noopener">[10]</a></li><li>Lucidity <a href="https://github.com/luciditytech/lucidity-plasma-cash" target="_blank" rel="noopener">[11]</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇介绍了 Plasma 框架下的基于 NFT 的项目 Plasma Cash。Plasma Cash 给每个新转移的 token 分配一个唯一的 token ID，并且用稀疏梅克尔树存储交易，使得用户可以只关注跟自己的 token 有关的动态，而不需要关注其它 token。Plasma Cash 可以被看作 Plasma 逐渐迈向成熟的一步，已经有很多公司使用 Plasma Cash 搭建自己的平台和应用，例如 Loomnetwork 公司搭建了自己的 Plasma Cash 子链并且编写了 SDK 支撑开发者在上面开发新的应用。然而 Plasma Cash 本身仍然存在较多的问题，例如 token 无法被分隔合并、需要提交的证明过长等。在接下来的文章中还会继续跟进 Plasma 最新的进展。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ol><li><a href="https://ethresear.ch/t/plasma-cash-plasma-with-much-less-per-user-data-checking/1298" target="_blank" rel="noopener">https://ethresear.ch/t/plasma-cash-plasma-with-much-less-per-user-data-checking/1298</a></li><li><a href="https://en.wikipedia.org/wiki/Non-fungible_token" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Non-fungible_token</a></li><li><a href="http://erc721.org/" target="_blank" rel="noopener">http://erc721.org/</a></li><li><a href="https://github.com/ethsociety/learn-plasma" target="_blank" rel="noopener">https://github.com/ethsociety/learn-plasma</a></li><li><a href="https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837" target="_blank" rel="noopener">https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837</a></li><li><a href="https://karl.tech/plasma-cash-simple-spec/" target="_blank" rel="noopener">https://karl.tech/plasma-cash-simple-spec/</a></li><li><a href="https://github.com/loomnetwork/plasma-paper/blob/master/plasma_cash.pdf" target="_blank" rel="noopener">https://github.com/loomnetwork/plasma-paper/blob/master/plasma_cash.pdf</a></li><li><a href="https://github.com/loomnetwork/plasma-cash" target="_blank" rel="noopener">https://github.com/loomnetwork/plasma-cash</a></li><li><a href="https://github.com/omisego/plasma-cash" target="_blank" rel="noopener">https://github.com/omisego/plasma-cash</a></li><li><a href="https://github.com/wolkdb/deepblockchains/tree/master/Plasmacash" target="_blank" rel="noopener">https://github.com/wolkdb/deepblockchains/tree/master/Plasmacash</a></li><li><a href="https://github.com/luciditytech/lucidity-plasma-cash" target="_blank" rel="noopener">https://github.com/luciditytech/lucidity-plasma-cash</a></li></ol><p>本文的作者是盖盖，他的微信公众号: chainlab</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列文章将围绕以太坊的二层扩容框架 Plasma，介绍其基本运行原理，具体操作细节，安全性讨论以及未来研究方向等。本篇文章主要介绍在 Plasma 框架下的项目 Plasma Cash。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Plasma" scheme="https://learnblockchain.cn/categories/ethereum/Plasma/"/>
    
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Plasma" scheme="https://learnblockchain.cn/tags/Plasma/"/>
    
      <category term="扩容" scheme="https://learnblockchain.cn/tags/%E6%89%A9%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Plasma（三）Plasma MVP</title>
    <link href="https://learnblockchain.cn/2018/11/03/plasma-mvp/"/>
    <id>https://learnblockchain.cn/2018/11/03/plasma-mvp/</id>
    <published>2018-11-03T08:54:17.000Z</published>
    <updated>2018-12-17T12:36:59.877Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列文章将围绕以太坊的二层扩容框架 Plasma，介绍其基本运行原理，具体操作细节，安全性讨论以及未来研究方向等。本篇文章主要介绍 Plasma 的一个最小实现 Plasma MVP（Minima Viable Plasma）。</p><a id="more"></a><p>在<a href="https://github.com/gitferry/mastering-ethereum/blob/master/Plasma-in-depth/plasma-in-detail.md" target="_blank" rel="noopener">上一篇</a>文章中我们已经理解了 Plasma 中的一些关键操作，但是 Plasma 是一套框架，如果脱离了实际的应用，仍然很难彻底理解它。因此本篇将详细介绍 Plama 的第一个项目 Plasma MVP（Minimal Viable Plasma），即在 Plasma 框架下的最基础的实现。Plasma MVP 是 Vitalic 和他的团队在 2018 年初提出的基于 UTXO 模型实现的 Plasma 设计标准<a href="https://ethresear.ch/t/minimal-viable-plasma/426" target="_blank" rel="noopener">[1]</a>，它以最简单的方式实现了链下交易，但无法支持复杂的计算，例如脚本（Script）和智能合约。在阅读下面的内容之前，请确保已经理解了这个系列之前的文章。</p><p>整个 Plasma MVP 的生命周期可以通过下面这幅图表现出来：</p><p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/plasma-mvp.jpg" width="360" height="400" alt="Blockchains of Blockchain"></p><h2 id="Plasma-合约"><a href="#Plasma-合约" class="headerlink" title="Plasma 合约"></a>Plasma 合约</h2><p>首先需要将 Plasma 合约部署到主链（以太坊）上作为主链和子链沟通的媒介。Plasma 合约会处理由子链提交的区块，并且将区块的哈希值存在主链上。除此之外，还会处理用户的存款（deposit）、取款（withdrawal/exit）以及争议（challenge）操作。</p><p>Plasma 合约中主要包括的数据结构有：</p><ul><li>Owner：合约的拥有者（即部署合约交易的发送者）的地址，即部署合约交易的发送者；</li><li>Plasma 区块列表：每个 Plasma 区块中存储了（1）区块的 Merkle root（2）区块提交的时间；</li><li>退出列表：即提交了退出申请的列表，每个退出申请存储了（1）申请者的地址（2）申请退出的 UTXO 的位置。</li></ul><p>Plasma 合约中主要包括的函数有：</p><ul><li>submitBlock(bytes32 root)：向主链提交一个区块，仅仅提交区块中所有交易的 Merkle root；</li><li>deposit()：生成一个只包含一个交易的区块，这个交易中包含与 msg.value 值相等的 UTXO；</li><li>startExit()：执行给定 UTXO 的退出操作；</li><li>challengeExit()：向某个正在执行的退出提出争议。</li></ul><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><p>在前面的文章中我们已经知道 Plasma 子链是一个独立的区块链，那么也就有独立的共识机制。在 Plasma MVP 中采用的共识机制就是 PoA（Proof of Authority），即参与共识的只有唯一一个矿工，称为 Operator。Operator 负责处理所有子链上发生的交易，将其打包成区块存储在子链上，并且周期性地向 Plasma 合约提交区块，将子链上的状态（区块的哈希值）提交到主链共识。那么，既然 Operator 是唯一的矿工，这不就意味着 Plasma 违背了去中心化的初衷了吗？其实，这是去中心化向执行效率的妥协。在之前的文章中也提到过，Plasma 的安全基础依赖于底层的区块链，只要底层的区块链能够保证安全，那么在 Plasma 子链上发生的最差结果也只是迫使用户退出子链，而不会造成资产损失。</p><p>Operator 可以采用最简单的 REST API 方式实现，子链中的用户可以通过调用简单的 API 获取到子链中区块的数据。</p><h2 id="存款（deposit）"><a href="#存款（deposit）" class="headerlink" title="存款（deposit）"></a>存款（deposit）</h2><p>用户 Alice 通过存款（deposit）操作向 Plasma 合约发送带有一定数额的以太币或 ERC20 token 加入 Plasma Chain，这时 Plasma 合约会执行 deposit() 函数，生成一个只包含一个交易的区块，这个交易的 UTXO 记录了 Alice 从主链转移到子链的数额。当这个区块被主链确认后，Alice 就可以使用新生成的 UTXO 向其它用户发送交易了。</p><h2 id="交易（transaction）"><a href="#交易（transaction）" class="headerlink" title="交易（transaction）"></a>交易（transaction）</h2><p>在 Plasma MVP 中，所有用户发送的交易都是直接发送给 Operator，当积累了一定数量的交易后，由 Operator 将交易打包成区块。这里需要注意的是，由于 Plasma MVP 采用的是 UTXO 模型，所以即使交易的收款方不存在，交易也是成立的。</p><p>在子链上 Alice 向 Bob 发送一个交易的流程如下：</p><ol><li>Alice 首先需要得到 Bob 在子链上的地址；</li><li>Alice 将一个或多个 UTXO 作为输入构造交易发送到 Bob 的地址，并对交易签名；</li><li>等待该交易被打包到区块中；</li><li>Alice 向 Bob 发送确认消息，并且使用相同的私钥签名。</li></ol><h2 id="生成区块"><a href="#生成区块" class="headerlink" title="生成区块"></a>生成区块</h2><p>在 Plasma MVP 中，一个 Plasma 区块产生的情况只有两种：一种是 Operator 打包生成区块，另外一种是当用户执行 deposit 操作时，由 Plasma 合约直接生成一个只包含一个交易的区块。</p><h2 id="监视子链"><a href="#监视子链" class="headerlink" title="监视子链"></a>监视子链</h2><p>为了保证子链上资产的安全，用户需要周期性地检查子链上的数据，保证没有恶意交易产生。用户需要运行一种自动化的软件（例如钱包），每隔一段时间下载子链中的区块数据，检查每个区块中的交易，如果有恶意交易产生，立即退出子链。</p><h2 id="取款-退出（withdrawal-exit）"><a href="#取款-退出（withdrawal-exit）" class="headerlink" title="取款/退出（withdrawal/exit）"></a>取款/退出（withdrawal/exit）</h2><p>当 Alice 想要退出子链时，需要向 Plasma 合约发送一个 exit 交易，申请中需要包含（1）所要退出的 UTXO 的位置，包括区块号（blknum）、区块内交易号（txindex）以及交易内输出号（outindex）（2）包含该 UTXO 的交易（3）该交易的 Merkle proof（4）用于生成该 UTXO 所涉及的之前一系列交易的确认签名。除此之外，exit 交易中还要包含“退出押金（exit bond）”。如果这个 exit 被 challenge 成功，那么取款的操作将被取消，而且退出押金将被发送给提出 challenge 的用户。</p><p>之后这个申请会被放入一个优先队列中，通过这个公式计算优先级：</p><blockquote><p>Priority = blknum <em> 1000000000 + txindex </em> 10000 + oindex</p></blockquote><p>之所以采用这种优先队列的方式处理取款顺序的原因是保证旧的 UTXO 总能优先于新的 UTXO 被取出。也就是说，当有恶意交易（例如双花等）产生时，所有在恶意交易发生之前的交易都可以被优先取出。那么如何解决在恶意交易之后被确认的交易的取款问题呢？Plasma MVP 采用了“确认签名（Confirmation Signatures）”的机制，在下一小节我们将介绍这一机制是如何工作的。</p><h2 id="确认签名（Confirmation-Signatures）"><a href="#确认签名（Confirmation-Signatures）" class="headerlink" title="确认签名（Confirmation Signatures）"></a>确认签名（Confirmation Signatures）</h2><p>在 Plasma MVP 中，用户的退出顺序以所要退出的 UTXO 所在的交易的位置为准。假如 operator 作恶，在一个合法的交易之前插入一个非法的交易，那么当用户执行取款时，由于非法交易可以先被取出，因此当执行到该用户的交易时，可能 Plasma 合约中的资产已经被取空。为了解决这个问题，Plasma MVP 采用了“确认签名”机制，例如当 Alice 产生一个交易时，她首先会对交易签名。当该交易被打包入区块后，Alice 还需要对该交易进行一次签名，即“确认签名”。</p><p>引入确认签名机制后，当 Alice 发现在一个区块中自己的合法交易之前存在非法交易时，可以拒绝对自己的交易进行“确认签名”，同时申请取款。这样可以使得当前的交易失效，保证自己之前“确认签名”后的交易可以优先于非法交易之前取出。</p><p>这种确认签名机制极大地破坏了用户体验，用户每产生一个交易都要经历签名-&gt;等待确认-&gt;确认签名。而且由于确认签名也需要占据 Plasma 区块的空间，因此也降低了子链的可扩展性。为了解决这个问题，Plasma 的研究人员提出了扩展版本 More Viable Plasma 移除了确认签名的要求<a href="https://ethresear.ch/t/more-viable-plasma/2160" target="_blank" rel="noopener">[2]</a>。</p><h2 id="争议（Challenge）"><a href="#争议（Challenge）" class="headerlink" title="争议（Challenge）"></a>争议（Challenge）</h2><p>每个取款操作都会经历一个争议期。例如在 Alice 的某个 UTXO 退出子链的过程中，如果 Bob 在争议期内发现有恶意行为发生，他可以提出一个争议（challenge）。一个争议需要给出针对的 UTXO 的位置，以及该 UTXO 被花费的证明，即该 UTXO 已经存在于某个交易中，且这个交易已经被打包到区块。</p><p>合约通过调用 challengeExit() 函数执行一个争议，争议成功后会取消正在执行的取款操作，并将提交取款申请所冻结的押金发送给 Bob。</p><h2 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h2><p>在 Plasma 子链中主要存在两种攻击场景：</p><ol><li>Alice 试图忽视在子链中转移给 Bob 的资产，使用最初加入 Plasma 子链时的交易证明向主链提出取款申请。</li><li>Operator 生成一个恶意交易，占有其他用户的资产，并且尝试退出子链。</li></ol><p>下面对这两个攻击场景进行分析，观察 Plasma MVP 如何保证资产的安全性：</p><p>场景1</p><ol><li>Alice 使用最初加入子链时生成的交易作为证据向主链提出取款申请；</li><li>Bob（或者其他任意用户）拥有 Alice 申请退出的 UTXO 被花费的交易证明，并将此作为证据向主链提出一个争议；</li><li>争议生效，Alice 的退出申请被驳回，同时将 Alice 申请退出的押金发送给 Bob；</li><li>Alice 的攻击失效。</li></ol><p>场景2</p><ol><li>Operator 创建了一个非法交易，并且将其打包生成区块之后在主链得到确认；</li><li>Operator 提交取款申请，打算将 Alice 的资产取走；</li><li>在争议期内，Alice 发现了 Operator 的恶意行为，立即提出取款申请，退出子链；</li><li>由于 Alice 的申请优先级较高，因此会在 Operator 之前退出；</li><li>Operator 的攻击失效。</li></ol><h2 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h2><blockquote><p>Talk is cheap, show me your code.</p></blockquote><p>目前已经有许多机构和公司已经实现了 Plasma MVP，但实现的语言和细节有所不同：</p><ul><li>FourthState Lab<a href="https://github.com/fourthstate" target="_blank" rel="noopener">[3]</a></li><li>Omisego<a href="https://github.com/omisego/plasma-mvp" target="_blank" rel="noopener">[4]</a></li><li>Kyokan<a href="https://github.com/kyokan/plasma" target="_blank" rel="noopener">[5]</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Plasma 的最小实现版本 Plasma MVP，虽然采用最简单的 UTXO 模型，但已经足够体现出 Plasma 的核心思想。在 Plasma MVP 中，用户资产的安全主要依赖于用户及时发现恶意行为，并退出子链。接下来的文章将会介绍另外一个稍微复杂一点的项目，Plasma Cash。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ol><li><a href="https://ethresear.ch/t/minimal-viable-plasma/426" target="_blank" rel="noopener">https://ethresear.ch/t/minimal-viable-plasma/426</a></li><li><a href="https://ethresear.ch/t/more-viable-plasma/2160" target="_blank" rel="noopener">https://ethresear.ch/t/more-viable-plasma/2160</a></li><li><a href="https://github.com/fourthstate" target="_blank" rel="noopener">https://github.com/fourthstate</a></li><li><a href="https://github.com/omisego/plasma-mvp" target="_blank" rel="noopener">https://github.com/omisego/plasma-mvp</a></li><li><a href="https://github.com/kyokan/plasma" target="_blank" rel="noopener">https://github.com/kyokan/plasma</a></li></ol><p>本文的作者是盖盖，他的微信公众号: chainlab</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列文章将围绕以太坊的二层扩容框架 Plasma，介绍其基本运行原理，具体操作细节，安全性讨论以及未来研究方向等。本篇文章主要介绍 Plasma 的一个最小实现 Plasma MVP（Minima Viable Plasma）。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Plasma" scheme="https://learnblockchain.cn/categories/ethereum/Plasma/"/>
    
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Plasma" scheme="https://learnblockchain.cn/tags/Plasma/"/>
    
      <category term="扩容" scheme="https://learnblockchain.cn/tags/%E6%89%A9%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包开发系列4 - 发送Token(代币）</title>
    <link href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/"/>
    <id>https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/</id>
    <published>2018-10-26T09:34:44.000Z</published>
    <updated>2018-12-14T08:43:52.048Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊去中心化网页钱包开发系列，点链接<a href="https://ke.qq.com/course/356068?tuin=bd898bbf" target="_blank" rel="noopener">观看视频课程</a>，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/">创建钱包账号</a>、<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_2/">账号Keystore文件导入导出</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/">展示钱包信息及发起签名交易</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/">发送Token(代币）</a>，本文是第四篇，Token（代币、通证）是以太坊的一大特色，既然开发钱包，则发送Token 功能必不可少。</p><a id="more"></a><h2 id="合约-ABI-信息"><a href="#合约-ABI-信息" class="headerlink" title="合约 ABI 信息"></a>合约 ABI 信息</h2><p>首先我们需要明白，进行Token转账的时候，其实是在调用合约的转账函数，而要调用一个合约的函数，需要知道合约的 ABI 信息。</p><p>其次 通常我们所说的Token， 其实指的是符合 ERC20 标准接口的合约， <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" target="_blank" rel="noopener">ERC20</a> 接口定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = <span class="string">"Token Name"</span>;</span><br><span class="line">    string public constant symbol = <span class="string">"SYM"</span>;</span><br><span class="line">    uint8 public constant decimals = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">balanceOf</span>(<span class="params">address tokenOwner</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint balance</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">allowance</span>(<span class="params">address tokenOwner, address spender</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint remaining</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address spender, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transfer</span>(<span class="params">address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address from, address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Transfer</span>(<span class="params">address indexed from, address indexed to, uint tokens</span>);</span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Approval</span>(<span class="params">address indexed tokenOwner, address indexed spender, uint tokens</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>ABI 全称是 Application Binary Interface，它就是合约接口的描述，因此有了合约的接口定义，就可以很容易通过编译拿到ABI 信息，比如像下图在Remix 的编译选项卡就可以直接复制ABI。</p><p><img src="https://learnblockchain.cn/media/15403775499051.jpg" alt=""></p><p>生成的 ABI 描述大概长这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"totalSupply"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"tokenOwner"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"address"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"balanceOf"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"balance"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>它是一个JSON形式的数组，数组里每一个元素，都是对函数接口的描述，在外部调用合约的时候就需要遵从这个接口，以上面的接口为例，通常一个接口描述包含下述几个字段：</p><ul><li>name: 函数会事件的名称</li><li>type: 可取值有function，constructor，fallback，event</li><li>inputs: 函数的输入参数，每个参数对象包含下述属性：<ul><li>name: 参数名称</li><li>type: 参数的规范型(Canonical Type)。</li></ul></li><li>outputs:  一系列的类似inputs的对象，如果无返回值时，可以省略。</li><li>constant: true表示函数声明自己不会改变状态变量的值。</li><li>payable: true表示函数可以接收ether，否则表示不能。</li></ul><p>接下来在构造合约对象就需要是使用ABI。</p><h2 id="构造合约对象"><a href="#构造合约对象" class="headerlink" title="构造合约对象"></a>构造合约对象</h2><p>ethers.js 构造合约对象很简单，仅需要提供三个参数给ethers.Contract构造函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abi = [...];</span><br><span class="line"><span class="keyword">var</span> addr = <span class="string">"0x..."</span>;</span><br><span class="line"><span class="keyword">var</span> contract = <span class="keyword">new</span> ethers.Contract(address, abi, provider);</span><br></pre></td></tr></table></figure><p>合约的地址在合约部署之后，可以获得，关于Token合约部署及ERC20相关的概念，这里不展开讲，不熟悉的同学，可以参考我另一篇文章<a href="https://learnblockchain.cn/2018/01/12/create_token/">创建自己的数字货币</a>。</p><p>只有就可以是使用 <code>contract</code> 对象来调用Token合约的函数。</p><h2 id="获取Token余额及转移Token"><a href="#获取Token余额及转移Token" class="headerlink" title="获取Token余额及转移Token"></a>获取Token余额及转移Token</h2><h3 id="获取Token余额"><a href="#获取Token余额" class="headerlink" title="获取Token余额"></a>获取Token余额</h3><p>结合UI来实现以下获取Token余额，UI如下：</p><p> <img src="https://learnblockchain.cn/media/15405195250777.jpg" alt=""></p><p>在HTML里，定义的标签如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span>TT Token:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">readonly</span>=<span class="string">"readonly"</span> <span class="attr">class</span>=<span class="string">"readonly"</span> <span class="attr">id</span>=<span class="string">"wallet-token-balance"</span> <span class="attr">value</span>=<span class="string">"0.0"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的逻辑代码也很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> tokenBalance = $(<span class="string">'#wallet-token-balance'</span>);</span><br><span class="line"> <span class="comment">// 直接调用合约方法</span></span><br><span class="line">contract.balanceOf(activeWallet.address).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>)</span>&#123;</span><br><span class="line">    tokenBalance.val(balance);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="转移Token"><a href="#转移Token" class="headerlink" title="转移Token"></a>转移Token</h3><p>转移Token的UI效果如下：</p><p> <img src="https://learnblockchain.cn/media/15405195493994.jpg" alt=""></p><p>界面的HTML代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>转移代币:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>发送至:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(target address)"</span> <span class="attr">id</span>=<span class="string">"wallet-token-send-target-address"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>金额:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(amount)"</span> <span class="attr">id</span>=<span class="string">"wallet-token-send-amount"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wallet-token-submit-send"</span> <span class="attr">class</span>=<span class="string">"submit disable"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面定义了两个文本输入框及一个“发送“按钮，在逻辑处理部分，转移Token代币尽管和获取余额类似，同样是调用合约的方法，不过转移代币需要发起一个交易，因此需要测量gas 消耗。<br>点击发送时运行一下（关键）代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputTargetAddress = $(<span class="string">'#wallet-token-send-target-address'</span>);</span><br><span class="line"><span class="keyword">var</span> inputAmount = $(<span class="string">'#wallet-token-send-amount'</span>);</span><br><span class="line"><span class="keyword">var</span> submit = $(<span class="string">'#wallet-token-submit-send'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> targetAddress = ethers.utils.getAddress(inputTargetAddress.val());</span><br><span class="line"><span class="keyword">var</span> amount = inputAmount.val();</span><br><span class="line"></span><br><span class="line">submit.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 先计算transfer 需要的gas 消耗量，这一步有默认值，非必须。</span></span><br><span class="line">    contract.estimate.transfer(targetAddress, amount)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">gas</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 必须关联一个有过签名钱包对象</span></span><br><span class="line">          <span class="keyword">let</span> contractWithSigner = contract.connect(activeWallet);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//  发起交易，前面2个参数是函数的参数，第3个是交易参数</span></span><br><span class="line">          contractWithSigner.transfer(targetAddress, amount, &#123;</span><br><span class="line">              gasLimit: gas,</span><br><span class="line">              <span class="comment">// 偷懒，直接是用 2gwei</span></span><br><span class="line">              gasPrice: ethers.utils.parseUnits(<span class="string">"2"</span>, <span class="string">"gwei"</span>),</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(tx);</span><br><span class="line">                <span class="comment">// 介绍刷新上面的Token余额，重置输入框</span></span><br><span class="line">            &#125;);  </span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述有一个地方都要注意一下，在合约调用 transfer 之前， 需要连接一个<strong>signer</strong>，因为发起交易的时候需要用它来进行签名，在ethers.js API里 Wallet 是 signer（抽象类）的实现类。</p><blockquote><p>所有会更改区块链数据的函数都需要关联签名器，如果是视图函数则只需要连接provider。</p></blockquote><p>ethers.js 的 Contract 提供了一个非常方便方法：<code>contract.estimate.functionName</code> 来计算预测交易的gasLimit。</p><p>在发起交易的时候，可以提供一个可选的<a href="https://docs.ethers.io/ethers.js/html/api-contract.html?highlight=estimate#overrides" target="_blank" rel="noopener">Overrides</a>参数，在这个参数里可以指定如交易的 gasLimit 、 gasPrice，如果我们不指定这个参数时，会默认使用 contract.estimate 获得的值作为 gasLimit，以及 provider.getGasPrice() 的值来指定 gasPrice。</p><p>哈哈，恭喜大家，到这里这里就完整的实现了一个基于以太坊去中心化网页钱包。</p><p>这是一条硬广，欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">深入浅出区块链技术小专栏</a>，目前仅需69元， 订阅就可以查看完整源码，还有其他惊喜哦~。<br>戳链接收看<a href="https://ke.qq.com/course/356068?tuin=bd898bbf" target="_blank" rel="noopener">详细的视频课程讲解</a>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://docs.ethers.io/ethers.js/html" target="_blank" rel="noopener">Ethers.js</a></li></ol><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><p><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链知识星球</a>最专业技术问答社区，加入社区还可以在微信群里和300多位区块链技术爱好者一起交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以太坊去中心化网页钱包开发系列，点链接&lt;a href=&quot;https://ke.qq.com/course/356068?tuin=bd898bbf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;观看视频课程&lt;/a&gt;，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/&quot;&gt;创建钱包账号&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/eth-web-wallet_2/&quot;&gt;账号Keystore文件导入导出&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/&quot;&gt;展示钱包信息及发起签名交易&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/&quot;&gt;发送Token(代币）&lt;/a&gt;，本文是第四篇，Token（代币、通证）是以太坊的一大特色，既然开发钱包，则发送Token 功能必不可少。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包开发系列3 - 展示钱包信息及发起签名交易</title>
    <link href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/"/>
    <id>https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/</id>
    <published>2018-10-26T02:31:44.000Z</published>
    <updated>2018-12-14T08:43:52.047Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊去中心化网页钱包开发系列，点链接<a href="https://ke.qq.com/course/356068?tuin=bd898bbf" target="_blank" rel="noopener">观看视频课程</a>，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/">创建钱包账号</a>、<a href="https://learnblockchain.cn/2018/10/25/eth-web-wallet_2/">账号Keystore文件导入导出</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/">展示钱包信息及发起签名交易</a>、<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/">发送Token(代币）</a>，这是第三篇介绍使用ethers.js的钱包对象获取相关信息及发起你离线交易。</p><a id="more"></a><h2 id="使用-Provider-连接以太坊网络"><a href="#使用-Provider-连接以太坊网络" class="headerlink" title="使用 Provider 连接以太坊网络"></a>使用 Provider 连接以太坊网络</h2><p>我们前面两篇文章介绍创建（或导入）钱包账号的过程都是是离线的，即不需要依赖以太坊网络即可创建钱包账号，但如果想获取钱包账号的相关信息，比如余额、交易记录，发起交易的话，就需要让钱包连上以太坊的网络。</p><p>不管是在 Web3 中，还是Ethers.js 都是使用 Provider 来进行网络连接的，Ethers.js 提供了集成多种 Provider 的方式：</p><ul><li><p>Web3Provider: 使用一个已有的web3 兼容的Provider，如有MetaMask 或 Mist提供。</p></li><li><p>EtherscanProvider 及 InfuraProvider:  如果没有自己的节点，可以使用Etherscan 及 Infura 的Provider，他们都是以太坊的基础设施服务提供商，Ethers.js 还提供了一种更简单的方式：使用一个默认的provider, 他会自动帮我们连接Etherscan 及 Infura。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let defaultProvider = ethers.getDefaultProvider(&apos;ropsten&apos;);</span><br></pre></td></tr></table></figure><p>  连接Provider, 通常有一个参数network网络名称，取值有： <code>homestead</code>, <code>rinkeby</code>, <code>ropsten</code>,  <code>kovan</code>, 关于Provider的更多用法，可以参考<a href="https://docs.ethers.io/ethers.js/html/api-providers.html" target="_blank" rel="noopener">Ethers.js Provider</a>。</p></li><li><p>JsonRpcProvider 及 IpcProvider:  如果有自己的节点可以使用，可以连接主网，测试网络，私有网络或Ganache，这也是本系列文章使用的方式。</p></li></ul><p>使用钱包连接Provider的方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接本地的geth 节点，8545是geth 的端口</span></span><br><span class="line"><span class="keyword">var</span> provider = <span class="keyword">new</span> ethers.providers.JsonRpcProvider(<span class="string">"http://127.0.0.1:8545"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wallet 为前两篇文章中生成的钱包对象, activeWallet就是后面可以用来请求余额发送交易的对象</span></span><br><span class="line"><span class="keyword">var</span> activeWallet = wallet.connect(App.provider);</span><br></pre></td></tr></table></figure><blockquote><p>启动geth的需要注意一下，需要使用 <code>--rpc --rpccorsdomain</code> 开启 RPC通信及跨域，</p></blockquote><h2 id="展示钱包详情：查询余额及Nonce"><a href="#展示钱包详情：查询余额及Nonce" class="headerlink" title="展示钱包详情：查询余额及Nonce"></a>展示钱包详情：查询余额及Nonce</h2><p>连接到以太坊网络之后，就可以向网络请求余额以及获取账号交易数量，使用一下API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeWallet.getBalance().then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">activeWallet.getTransactionCount().then(<span class="function"><span class="keyword">function</span>(<span class="params">transactionCount</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>activeWallet就是后面可以用来请求发送交易的对象</p><p><img src="https://learnblockchain.cn/media/15402868832290.jpg" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;钱包详情:<span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>地址:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> readonly=<span class="string">"readonly"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"readonly"</span> id=<span class="string">"wallet-address"</span> value=<span class="string">""</span> /&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>tr&gt;</span><br><span class="line">    &lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>余额:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> readonly=<span class="string">"readonly"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"readonly"</span> id=<span class="string">"wallet-balance"</span> value=<span class="string">"0.0"</span> /&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>tr&gt;</span><br><span class="line">    &lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Nonce:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> readonly=<span class="string">"readonly"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"readonly"</span> id=<span class="string">"wallet-transaction-count"</span> value=<span class="string">"0"</span> /&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>tr&gt;</span><br><span class="line">    &lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;div id=<span class="string">"wallet-submit-refresh"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"submit"</span>&gt;刷新&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>td&gt;</span><br><span class="line">    &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>table&gt;</span><br></pre></td></tr></table></figure><p>js处理的逻辑就是获取信息之后，填充相应的控件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputBalance = $(<span class="string">'#wallet-balance'</span>);</span><br><span class="line"><span class="keyword">var</span> inputTransactionCount = $(<span class="string">'#wallet-transaction-count'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#wallet-submit-refresh"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取余额时， 包含当前正在打包的区块</span></span><br><span class="line">   activeWallet.getBalance(<span class="string">'pending'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 单位转换 wei -&gt; ether</span></span><br><span class="line">          inputBalance.val(ethers.utils.formatEther(balance, &#123; <span class="attr">commify</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   activeWallet.getTransactionCount(<span class="string">'pending'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">transactionCount</span>) </span>&#123;</span><br><span class="line">          inputTransactionCount.val(transactionCount);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一次点击获取数据</span></span><br><span class="line">$(<span class="string">"#wallet-submit-refresh"</span>).click();</span><br></pre></td></tr></table></figure><h2 id="发送签名交易"><a href="#发送签名交易" class="headerlink" title="发送签名交易"></a>发送签名交易</h2><p>之前我们有一篇文章：<a href="https://learnblockchain.cn//2018/09/12/web3-sendeth/">如何使用Web3.js API 在页面中进行转账</a>介绍过发起交易，不过当时的签名是利用MetaMask来完成的，现在我们要完成一个钱包，必须要发送一个签名交易，签名交易也称为离线交易（因为这个过程可以离线进行：在离线状态下对交易进行签名，然后把签名后的交易进行广播）。</p><p>尽管 Ethers.js 提供了非常简洁的API来发送签名交易，但是探究下简洁API背后的细节依然会对我们有帮助，这个过程大致可分为三步:</p><ol><li>构造交易</li><li>交易签名</li><li>发送（广播）交易</li></ol><h3 id="构造交易"><a href="#构造交易" class="headerlink" title="构造交易"></a>构造交易</h3><p>先来看看一个交易长什么样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> txParams = &#123;</span><br><span class="line">  nonce: <span class="string">'0x00'</span>,</span><br><span class="line">  gasPrice: <span class="string">'0x09184e72a000'</span>,</span><br><span class="line">  gasLimit: <span class="string">'0x2710'</span>,</span><br><span class="line">  to: <span class="string">'0x0000000000000000000000000000000000000000'</span>,</span><br><span class="line">  value: <span class="string">'0x00'</span>,</span><br><span class="line">  data: <span class="string">'0x7f7465737432000000000000000000000000000000000000000000000000000000600057'</span>,</span><br><span class="line">  <span class="comment">// EIP 155 chainId - mainnet: 1, ropsten: 3</span></span><br><span class="line">  chainId: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起交易的时候，就是需要填充每一个字段，构建这样一个交易结构。<br><code>to</code> 和 <code>value</code>: 很好理解，就是用户要转账的目标及金额。<br><code>data</code>: 是交易时附加的消息，如果是对合约地址发起交易，这会转化为对合约函数的执行，可参考：<a href="https://learnblockchain.cn/2018/08/09/understand-abi/">如何理解以太坊ABI</a><br><code>nonce</code>: 交易序列号<br><code>chainId</code>:  链id，用来去区分不同的链（分叉链）id可在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#specification" target="_blank" rel="noopener">EIP-55</a>查询。</p><blockquote><p><code>nonce</code> 和 <code>chainId</code> 有一个重要的作用就是防止重放攻击，如果没有nonce的活，收款人可能把这笔签名过的交易再次进行广播，没有chainId的话，以太坊上的交易可以拿到以太经典上再次进行广播。</p></blockquote><p><code>gasPrice</code>和<code>gasLimit</code>： Gas是以太坊的工作计费机制，是由交易发起者给矿工打包的费用。上面几个参数的设置比较固定，Gas的设置（尤其是gasPrice）则灵活的多。</p><p><code>gasLimit</code> 表示预计的指令和存储空间的工作量，如果工作量没有用完，会退回交易发起者，如果不够会发生<em>out-of-gas</em> 错误。<br><strong>一个普通转账的交易，工作量是固定的，gasLimit为21000</strong>，合约执行gasLimit则是变化的，也许有一些人会认为直接设置为高一点，反正会退回，但如果合约执行出错，就会吃掉所有的gas。幸运的是web3 和 ethers.js 都提供了测算Gas Limit的方法，下一遍<a href="https://learnblockchain.cn/2018/10/26/eth-web-wallet_4">发送代币</a></p><p><code>gasPrice</code>是交易发起者是愿意为工作量支付的<strong>单位</strong>费用，矿工在选择交易的时候，是按照gasPrice进行排序，先服务高出价者，因此如果出价过低会导致交易迟迟不能打包确认，出价过高对发起者又比较亏。</p><p>web3 和 ethers.js 提供一个方法 <strong>getGasPrice()</strong> 用来获取最近几个历史区块gas price的中位数，也有一些第三方提供预测gas price的接口，如：<a href="https://www.etherchain.org/tools/gasPriceOracle" target="_blank" rel="noopener">gasPriceOracle</a> 、 <a href="https://ethgasstation.info/json/ethgasAPI.json" target="_blank" rel="noopener">ethgasAPI</a>、 <a href="https://etherscan.io/gastracker" target="_blank" rel="noopener">etherscan gastracker</a>，这些服务通常还会参考当前交易池内交易数量及价格，可参考性更强，</p><p>常规的一个做法是利用这些接口给用户一个参考值，然后用户可以根据参考值进行微调。</p><h3 id="交易签名"><a href="#交易签名" class="headerlink" title="交易签名"></a>交易签名</h3><p>在构建交易之后，就是用私钥对其签名，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tx = <span class="keyword">new</span> EthereumTx(txParams)</span><br><span class="line">tx.sign(privateKey)</span><br><span class="line"><span class="keyword">const</span> serializedTx = tx.serialize()</span><br></pre></td></tr></table></figure><p>代码参考<a href="https://github.com/ethereumjs/ethereumjs-tx" target="_blank" rel="noopener">ethereumjs-tx</a></p><h3 id="发送（广播）交易"><a href="#发送（广播）交易" class="headerlink" title="发送（广播）交易"></a>发送（广播）交易</h3><p>然后就是发送（广播）交易，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendRawTransaction(serializedTx, <span class="function"><span class="keyword">function</span> (<span class="params">err, transactionHash</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(transactionHash);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这三步就完成了发送签名交易的过程，ethers.js 里提供了一个简洁的接口，来完成所有这三步操作(强调一下，签名已经在接口里帮我们完成了)，接口如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">activeWallet.sendTransaction(&#123;</span><br><span class="line">           to: targetAddress,</span><br><span class="line">           value: amountWei,</span><br><span class="line">           gasPrice: activeWallet.provider.getGasPrice(),</span><br><span class="line">           gasLimit: <span class="number">21000</span>,</span><br><span class="line">       &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>) </span>&#123;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h2 id="用ethers-js-实现发送交易"><a href="#用ethers-js-实现发送交易" class="headerlink" title="用ethers.js 实现发送交易"></a>用ethers.js 实现发送交易</h2><p>先来看看发送交易的UI界面：</p><p><img src="https://learnblockchain.cn/media/15403685871339.jpg" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>以太转账:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>发送至:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(target address)"</span> <span class="attr">id</span>=<span class="string">"wallet-send-target-address"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>金额:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"(amount)"</span> <span class="attr">id</span>=<span class="string">"wallet-send-amount"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wallet-submit-send"</span> <span class="attr">class</span>=<span class="string">"submit disable"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面主要定义了两个文本输入框及一个“发送“按钮，在点击发送时运行一下（关键）代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputTargetAddress = $(<span class="string">'#wallet-send-target-address'</span>);</span><br><span class="line"><span class="keyword">var</span> inputAmount = $(<span class="string">'#wallet-send-amount'</span>);</span><br><span class="line"><span class="keyword">var</span> submit = $(<span class="string">'#wallet-submit-send'</span>);</span><br><span class="line"></span><br><span class="line">submit.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 得到一个checksum 地址</span></span><br><span class="line">    <span class="keyword">var</span> targetAddress = ethers.utils.getAddress(inputTargetAddress.val());</span><br><span class="line"><span class="comment">// ether -&gt; wei</span></span><br><span class="line">    <span class="keyword">var</span> amountWei = ethers.utils.parseEther(inputAmount.val());</span><br><span class="line">    activeWallet.sendTransaction(&#123;</span><br><span class="line">        to: targetAddress,</span><br><span class="line">        value: amountWei,</span><br><span class="line">        <span class="comment">// gasPrice: activeWallet.provider.getGasPrice(),  (可用默认值)</span></span><br><span class="line">        <span class="comment">// gasLimit: 21000,</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(tx);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>哈哈哈~， 干活介绍到这里，现在夹带一点私货，有到了推广时间了，完整源码请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">深入浅出区块链技术小专栏</a>查看，赶紧订阅吧，走过路过，不容错过。<br>戳链接收看<a href="https://ke.qq.com/course/356068?tuin=bd898bbf" target="_blank" rel="noopener">详细的视频课程讲解</a>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://github.com/ethereumjs/ethereumjs-tx" target="_blank" rel="noopener">ethereum-tx</a></li><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md" target="_blank" rel="noopener">EIP-55</a></li><li><a href="https://docs.ethers.io/ethers.js/html" target="_blank" rel="noopener">Ethers.js</a></li></ol><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><p><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链知识星球</a>最专业技术问答社区，加入社区还可以在微信群里和300多位区块链技术爱好者一起交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以太坊去中心化网页钱包开发系列，点链接&lt;a href=&quot;https://ke.qq.com/course/356068?tuin=bd898bbf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;观看视频课程&lt;/a&gt;，将从零开始开发出一个可以实际使用的钱包，本系列文章是理论与实战相结合，一共有四篇：&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/eth-web-wallet_1/&quot;&gt;创建钱包账号&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/25/eth-web-wallet_2/&quot;&gt;账号Keystore文件导入导出&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_3/&quot;&gt;展示钱包信息及发起签名交易&lt;/a&gt;、&lt;a href=&quot;https://learnblockchain.cn/2018/10/26/eth-web-wallet_4/&quot;&gt;发送Token(代币）&lt;/a&gt;，这是第三篇介绍使用ethers.js的钱包对象获取相关信息及发起你离线交易。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="钱包" scheme="https://learnblockchain.cn/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
</feed>
