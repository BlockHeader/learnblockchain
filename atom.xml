<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深入浅出区块链</title>
  
  <subtitle>系统学习区块链技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://learnblockchain.cn/"/>
  <updated>2018-09-04T06:42:28.223Z</updated>
  <id>https://learnblockchain.cn/</id>
  
  <author>
    <name>Tiny熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员如何切入区块链去中心化应用开发</title>
    <link href="https://learnblockchain.cn/2018/08/31/devDapp/"/>
    <id>https://learnblockchain.cn/2018/08/31/devDapp/</id>
    <published>2018-08-31T03:30:55.000Z</published>
    <updated>2018-09-04T06:42:28.223Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间一个以太坊游戏应用：<a href="http://exitscam.me/play" target="_blank" rel="noopener">Fomo3D</a>异常火爆，在短短的几天内就吸引了几万的以太币投入游戏，第一轮游戏一个“黑客”用了一个非常巧妙的利用以太坊规则成为了最终赢家，拿走了1万多以太币奖金。</p><p>区块链应用的价值由这个游戏反映的淋漓尽致，Fomo3D游戏能够成功核心所依赖的是以太坊提供的一个可信、不可篡改平台。当游戏的规则确定之后，一切都按规则运行，无人可干预。今天这篇就来介绍一下如何开发去中心化应用。</p><a id="more"></a><h2 id="中心化应用"><a href="#中心化应用" class="headerlink" title="中心化应用"></a>中心化应用</h2><p>作为对比，先来看看中心化应用，其实就是现有的互联网应用，为什么它是中心化应用，看看它的架构图：<br><img src="/images/capp.jpg" alt=""></p><p>平时我们接触的是应用的前端（或称客户端），前端可以是HTML5的web页面、 小程序、APP， 在前端展现的内容通常发送一个请求到服务器，服务器返回相应的内容给前端。在前端的动作同样也会转化请求发送到服务器，服务器处理之后返回数据到前端。也就是说我们所有看到的内容或者操作都是中心化的服务器控制，因此说是中心化应用。</p><h2 id="去中心化应用DAPP"><a href="#去中心化应用DAPP" class="headerlink" title="去中心化应用DAPP"></a>去中心化应用DAPP</h2><p>而去中心化应用有什么不同呢？ 看看它的架构图：<br><img src="/images/dapp.jpg" alt=""><br>前端的表现上是一样的， 还是H5页面、 小程序、APP，DAPP和传统App关键是后端部分不同，是后端不再是一个中心化的服务器，而是分布式网络上任意节点，注意可以是 <strong>任意一个节点</strong>，在应用中给节点发送的请求通常称为 <strong>交易</strong>，交易和中心化下的请求有几个很大的不同是：交易的数据经过用户个人签名之后发送到节点，节点收到交易请求之后，会把 <strong>请求广播到整个网络</strong>，交易在网络达成共识之后，才算是真正的执行（真正其作用的执行不一是连接的后端节点，尽管后端也会执行）。以及中心化下的请求大多数都是同步的（及时拿到结果）， 而交易大多数是异步的，这也是在开发去中心应用时需要注意的地方，</p><p>从节点上获得数据状态（比如交易的结果），一般是通过事件回调来获得。</p><h2 id="如何开发"><a href="#如何开发" class="headerlink" title="如何开发"></a>如何开发</h2><p>在开发中心化应用最重要两部分是 <strong>客户端UI表现</strong>和 <strong>后端服务程序</strong>， UI表现通过HTTP请求连接到后端服务程序，后端服务程序运行在服务器上，比如Nginx Apached等等。</p><p>开发一个去中心化应用最重要也是两部分： <strong>客户端UI表现</strong>及 <strong>智能合约</strong>，智能合约的作用就像后端服务程序，智能合约是运行在节点的EVM上， 客户端调用智能合约，是通过向节点发起RPC请求完成。</p><p>下面是一个对比：</p><pre><code>     客户端UI &lt;=&gt; 客户端UI         HTTP &lt;=&gt; RPC  后端服务程序 &lt;=&gt; 智能合约Nginx/Apache &lt;=&gt; 节点</code></pre><p>因此对于去中心化应用来说，程序员可以从两个方面切入:</p><p>一个是 <strong>去中心化应用的客户端开发</strong>， 熟悉已经熟悉客户端软件（如Web\APP等）开发的同学，只需要了解一下客户端跟区块链节点通信的API接口，如果是在当前应用最广泛的区块链平台以太坊上开发去中心化应用，那么需要了解Web3<br>这个库，Web3对节点暴露出来的JSON-RPC接口进行了封装，比如Web3提供的功能有：获取节点状态，获取账号信息，调用合约、监听合约事件等等。</p><p>目前的主流语言都有Web3的实现，列举一些实现给大家参考：</p><ul><li><a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">JavaScript Web3.js</a></li><li><a href="https://github.com/ethereum/web3.py" target="_blank" rel="noopener">Python Web3.py</a></li><li><a href="https://github.com/airalab/hs-web3" target="_blank" rel="noopener">Haskell hs-web3</a></li><li><a href="https://github.com/web3j/web3j" target="_blank" rel="noopener">Java web3j</a></li><li><a href="https://github.com/mslinn/web3j-scala" target="_blank" rel="noopener">Scala web3j-scala</a></li><li><a href="https://github.com/f-o-a-m/purescript-web3" target="_blank" rel="noopener">Purescript purescript-web3</a></li><li><a href="https://github.com/sc0Vu/web3.php" target="_blank" rel="noopener">PHP web3.php</a></li><li><a href="https://github.com/digitaldonkey/ethereum-php" target="_blank" rel="noopener">PHP ethereum-php</a></li></ul><p>另一个切入点是 <strong>智能合约的开发</strong>，在以太坊现在推荐的语言是Solidity，有一些同学对新学一门语言有一些畏惧，Solidity的语法其实很简洁，有过一两门其他语言基础（开发经验）的同学三五天就可以学会，我也录制了一个视频课程：<a href="https://wiki.learnblockchain.cn/course/solidity.html" target="_blank" rel="noopener">深入详解以太坊智能合约语言Solidity</a>。</p><p>下面用一个Hello合约，体会下Solidity的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Hello &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"Hello World"</span>; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把上面的contract关键字更改为class，就和其他语言定义一个类一样。</p><p>有兴趣的同学可以进一步学习一下这个DApp开发案例<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>，</p><p>在DAPP的开发过程中，一些开发工具可以帮助我们事半功倍，如：Truffle开发框架以及Ganache工具来模拟节点等，这篇文章<a href="https://learnblockchain.cn/2018/01/12/first-dapp/">一步步教你开发、部署第一个去中心化应用</a></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对于想切入到去中心化应用开发的同学，对区块链运行的原理了解肯定会是加分项，尤其是各类共识机制（<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">POW</a>，POS，DPOS等）的理解，P2P网络的理解，以及各类加密和Hash算法的运用。有一些同学想做区块链底层开发，对区块链运行的原理则是必须项。</p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间一个以太坊游戏应用：&lt;a href=&quot;http://exitscam.me/play&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fomo3D&lt;/a&gt;异常火爆，在短短的几天内就吸引了几万的以太币投入游戏，第一轮游戏一个“黑客”用了一个非常巧妙的利用以太坊规则成为了最终赢家，拿走了1万多以太币奖金。&lt;/p&gt;
&lt;p&gt;区块链应用的价值由这个游戏反映的淋漓尽致，Fomo3D游戏能够成功核心所依赖的是以太坊提供的一个可信、不可篡改平台。当游戏的规则确定之后，一切都按规则运行，无人可干预。今天这篇就来介绍一下如何开发去中心化应用。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Dapp" scheme="https://learnblockchain.cn/categories/ethereum/Dapp/"/>
    
    
      <category term="Dapp入门" scheme="https://learnblockchain.cn/tags/Dapp%E5%85%A5%E9%97%A8/"/>
    
      <category term="以太坊概念" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>如何理解以太坊ABI - 应用程序二进制接口</title>
    <link href="https://learnblockchain.cn/2018/08/09/understand-abi/"/>
    <id>https://learnblockchain.cn/2018/08/09/understand-abi/</id>
    <published>2018-08-09T09:08:39.000Z</published>
    <updated>2018-08-15T14:42:41.181Z</updated>
    
    <content type="html"><![CDATA[<p>很多同学不是很明白以太坊ABI是什么，他的作用是什么，读完本文就明白了。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>，也可以观看我们的视频：<a href="https://wiki.learnblockchain.cn/course/beginner.html" target="_blank" rel="noopener">零基础搞懂区块链</a>和<a href="https://wiki.learnblockchain.cn/course/solidity.html" target="_blank" rel="noopener">深入详解以太坊智能合约语言Solidity</a>, 可以系统全面学习理解以太坊、智能合约。</p><h2 id="ABI-是什么"><a href="#ABI-是什么" class="headerlink" title="ABI 是什么"></a>ABI 是什么</h2><p>ABI 全称是 Application Binary Interface，翻译过来就是：应用程序二进制接口，简单来说就是 以太坊的调用合约时的接口说明。还不是很理解，没关系。</p><h2 id="调用合约函数发生了什么"><a href="#调用合约函数发生了什么" class="headerlink" title="调用合约函数发生了什么"></a>调用合约函数发生了什么</h2><p>从外部施加给以太坊的行为都称之为向以太坊网络提交了一个交易， 调用合约函数其实是向合约地址（账户）提交了一个交易，这个交易有一个附加数据，这个附加的数据就是ABI的编码数据。<br><img src="/images/abi1.jpg" alt=""></p><blockquote><p>比特币的交易也可以附加数据，以太坊革命性的地方就是能把附加数据转化为都函数的执行。</p></blockquote><p>因此要想和合约交互，就离不开ABI数据。</p><h3 id="演示调用函数"><a href="#演示调用函数" class="headerlink" title="演示调用函数"></a>演示调用函数</h3><p>以下面以个最简单的合约为例，我们看看用参数 1 调用<code>set(uint x)</code>，这个交易附带的数据是什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    </span><br><span class="line">    uint storedData;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然第一步需要先把合约部署到以太坊网络（其实部署也是一个）上，然后用 “1” 作为参数调用set，如下图:<br><img src="/images/abi2.jpg" alt=""></p><p>然后我们打开etherscan查看<a href="https://ropsten.etherscan.io/tx/0xd773a6909808f99c5a26c0c890af8b0bb6d784f29a3af55e04fa35d44d7716e2" target="_blank" rel="noopener">交易详情数据</a>, 可以看到其附加数据如下图：<br><img src="/images/abi3.jpg" alt=""></p><p>这个数据就是ABI的编码数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x60fe47b10000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure></p><h2 id="ABI-编码分析"><a href="#ABI-编码分析" class="headerlink" title="ABI 编码分析"></a>ABI 编码分析</h2><p>我把上面交易的附加数据拷贝出来分析一下，这个数据可以分成两个子部分：</p><ul><li><p>函数选择器(4字节)<br>0x60fe47b1</p></li><li><p>第一个参数(32字节)<br>00000000000000000000000000000000000000000000000000000000000000001</p></li></ul><p>函数选择器值 实际是对函数签名字符串进行sha3（keccak256）哈希运算之后，取前4个字节，用代码表示就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes4(sha3(“set(uint256)”)) == <span class="number">0x60fe47b1</span></span><br></pre></td></tr></table></figure><p>参数部分则是使用对应的16进制数。</p><p>现在就好理解 附加数据怎么转化为对应的函数调用。</p><h2 id="ABI-编码函数"><a href="#ABI-编码函数" class="headerlink" title="ABI 编码函数"></a>ABI 编码函数</h2><p>那么怎么获得函数对应的ABI 数据呢， 有两种方法：</p><h3 id="Solidity-ABI-编码函数"><a href="#Solidity-ABI-编码函数" class="headerlink" title="Solidity ABI 编码函数"></a>Solidity ABI 编码函数</h3><p>一个是 solidity 提供了ABI的相关<a href="https://learnblockchain.cn/2018/03/14/solidity-api/">API</a>， 用来直接得到ABI编码信息，这些函数有：</p><ul><li>abi.encode(…) returns (bytes)：计算参数的ABI编码。</li><li>abi.encodePacked(…) returns (bytes)：计算参数的紧密打包编码</li><li>abi. encodeWithSelector(bytes4 selector, …) returns (bytes)： 计算函数选择器和参数的ABI编码</li><li>abi.encodeWithSignature(string signature, …) returns (bytes): 等价于* abi.encodeWithSelector(bytes4(keccak256(signature), …)</li></ul><p>通过ABI编码函数可以在不用调用函数的情况下，获得ABI编码值，下面通过一段代码来看看这些方法的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line"></span><br><span class="line">contract testABI &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abiEncode</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">        abi.encode(<span class="number">1</span>);  <span class="comment">// 计算1的ABI编码</span></span><br><span class="line">        <span class="keyword">return</span> abi.encodeWithSignature(<span class="string">"set(uint256)"</span>, <span class="number">1</span>); <span class="comment">//计算函数set(uint256) 及参数1 的ABI 编码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以运行运行下<code>abiEncode</code>函数，它的输出其实就是前面调用的附加数据。</p><h3 id="Web3-ABI-编码函数"><a href="#Web3-ABI-编码函数" class="headerlink" title="Web3 ABI 编码函数"></a>Web3 ABI 编码函数</h3><p>另一个web3提供相应的API，例如使用web3计算函数选择器的方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.abi.encodeFunctionSignature(<span class="string">'myMethod(uint256,string)'</span>);</span><br></pre></td></tr></table></figure><p>其完整的文档在<a href="http://web3js.readthedocs.io/en/1.0/web3-eth-abi.html" target="_blank" rel="noopener">这里</a>，这里不一一演示。</p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多同学不是很明白以太坊ABI是什么，他的作用是什么，读完本文就明白了。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="ABI" scheme="https://learnblockchain.cn/tags/ABI/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列13 -  函数调用</title>
    <link href="https://learnblockchain.cn/2018/08/09/solidity-callfun/"/>
    <id>https://learnblockchain.cn/2018/08/09/solidity-callfun/</id>
    <published>2018-08-09T03:17:17.000Z</published>
    <updated>2018-08-09T03:25:59.523Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第13篇介绍函数调用， 本文会介绍函数使用元组返回多个值，通过命名方式进行参数调用以及如何省略函数参数名称。</p><p>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="函数调用及参数"><a href="#函数调用及参数" class="headerlink" title="函数调用及参数"></a>函数调用及参数</h2><p>在<a href="https://xiaozhuanlan.com/topic/1293405678" target="_blank" rel="noopener">函数类型</a>一节中，我们介绍过Solidity 中有两种函数调用方式：内部函数调用和外部函数调用，这一节我们进一步介绍。</p><h2 id="内部函数调用（Internal-Function-Calls）"><a href="#内部函数调用（Internal-Function-Calls）" class="headerlink" title="内部函数调用（Internal Function Calls）"></a>内部函数调用（Internal Function Calls）</h2><p>内部调用，不会创建一个EVM消息调用。而是直接调用当前合约的函数，也可以递归调用。<br>如下面这个的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint a</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f();       <span class="comment">// 直接调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> g(<span class="number">7</span>) + f();    <span class="comment">// 直接调用及递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些函数调用被转换为EVM内部的简单指令跳转（jumps）。 这样带来的一个好处是，当前的内存不会被回收。在一个内部调用时传递一个内存型引用效率将非常高的。当然，仅仅是同一个合约的函数之间才可通过内部的方式进行调用。</p><h2 id="外部函数调用-External-Function-Calls"><a href="#外部函数调用-External-Function-Calls" class="headerlink" title="外部函数调用(External Function Calls)"></a>外部函数调用(External Function Calls)</h2><p>外部调用，会创建EVM<strong>消息调用</strong>。<br>表达式this.g(8);和c.g(2)（这里的c是一个合约实例）是外部调用函数的方式，它会发起一个消息调用，而不是EVM的指令跳转。需要注意的是，在合约的构造器中，不能使用this调用函数，因为当前合约还没有创建完成。</p><p>其它合约的函数必须通过外部的方式调用。对于一个外部调用，所有函数的参数必须要拷贝到内存中。</p><p>当调用其它合约的函数时，可以通过选项<strong>.value()</strong>，和<strong>.gas()</strong>来分别指定要发送的以太币（以wei为单位）和gas值，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFeed</span>(<span class="params">address addr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">      feed = InfoFeed(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callFeed</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">      feed.info.value(<span class="number">10</span>).gas(<span class="number">800</span>)();  <span class="comment">// 附加以太币及gas来调用info</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>info()函数，必须使用payable关键字，否则不能通过value()来接收以太币。</p><p>表达式InfoFeed(addr)进行了一个显示的类型转换，表示给定的地址是合约InfoFeed类型，这里并不会执行构造器的初始化。<br>在进行显式的类型强制转换时需要非常小心，不要调用一个我们不知道类型的合约函数。</p><p>我们也可以使用<strong>function setFeed(InfoFeed _feed) { feed = _feed; }</strong>来直接进行赋值。<br>注意<strong>feed.info.value(10).gas(800)</strong>仅仅是对发送的以太币和gas值进行了设置，真正的调用是后面的括号()。<br>调用callFeed时，需要预先存入一定量的以太币，要不能会因余额不足报错。</p><blockquote><p>如果我们不知道被调用的合约源代码，和它们交互会有潜在的风险，即便被调用的合约继承自一个已知的父合约（继承仅仅要求正确实现接口，而不关注实现的内容）。<br>因为和他们交互，相当于把自己控制权交给被调用的合约，对方几乎可以利用它做任何事。<br>此外, 被调用的合约可以改变调用合约的状态变量，在编写函数时需要注意可重入性漏洞问题（可查看安全建议）。</p></blockquote><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>与其他语言一样，函数可以提供参数作为输入（函数类型本身也可以作为参数）; 与Javascript和C不同的是，solidity还可以返回任意数量的参数作为输出。</p><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>输入参数的声明方式与变量相同， 未使用的参数可以省略变量名称。假设我们希望合约接受一种带有两个整数参数的外部调用，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">taker</span>(<span class="params">uint _a, uint _b</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 _a  _b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>输出参数的声明和输入参数一样，只不过它接在returns 之后，假设我们希望返回两个结果：两个给定整数的和及积，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arithmetics</span>(<span class="params">uint _a, uint _b</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">pure</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint o_sum, uint o_product</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以省略输出参数的名称，也可以使用return语句指定输出值，return可以返回多个值（见下文）。<br>返回一个没有赋值的参数，则默认为0。</p><p>输入参数和输出参数可以在函数内表达式中使用，也可以作为被赋值的对象， 如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">taker</span>(<span class="params">uint _a, uint _b</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint _c</span>) </span>&#123;</span><br><span class="line">        _a = <span class="number">1</span>;</span><br><span class="line">        _b = <span class="number">2</span>;</span><br><span class="line">        _c = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>当一个函数有多个输出参数时, 可以使用元组(tuple)来返回多个值。元组(tuple)是一个数量固定，类型可以不同的元素组成的一个列表（用小括号表示），使用return (v0, v1, …, vn) 语句，就可以返回多个值，返回值的数量需要和输出参数声明的数量一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint, bool, uint</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用元组返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">7</span>, <span class="literal">true</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callf</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    uint x;</span><br><span class="line">    bool y;</span><br><span class="line">    uint z;</span><br><span class="line">    <span class="comment">// 使用元组给多个变量赋值</span></span><br><span class="line">    (x, y , z)  = f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充关于元组的介绍"><a href="#补充关于元组的介绍" class="headerlink" title="补充关于元组的介绍"></a>补充关于元组的介绍</h4><p>上面的代码中，使用了元组返回多个值及使用元组给多个变量赋值，给多个变量赋值通常也称为解构（解构的概念在函数式语言中较为常见），再来看看元组的一些用法，比如元组可以交换变量值，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) = (y, x);</span><br></pre></td></tr></table></figure><p>元组支持省略一些元素， 如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y, ) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>开头的元素也可以省略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(, y, ) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>注意 (1,) 是一个一个元素的元组， (1) 只是1。</p><h3 id="使用命名参数调用"><a href="#使用命名参数调用" class="headerlink" title="使用命名参数调用"></a>使用命名参数调用</h3><p>函数调用的参数，可以通过指定名称的方式调用，使用花括号{} 包起来，参数顺序任意，但参数的类型和数量要与定义一致。<br>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint key, uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        f(&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">key</span>: <span class="number">3</span>&#125;);  <span class="comment">// 命名参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="省略函数参数名称"><a href="#省略函数参数名称" class="headerlink" title="省略函数参数名称"></a>省略函数参数名称</h3><p>没有使用的参数名称可以省略(一般常见于返回值)。这些参数依然在栈(stack)上存在，但不可访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="comment">// omitted name for parameter</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">uint k, uint</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第13篇介绍函数调用， 本文会介绍函数使用元组返回多个值，通过命名方式进行参数调用以及如何省略函数参数名称。&lt;/p&gt;
&lt;p&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列12 -  库的使用</title>
    <link href="https://learnblockchain.cn/2018/08/09/solidity-library/"/>
    <id>https://learnblockchain.cn/2018/08/09/solidity-library/</id>
    <published>2018-08-09T02:40:56.000Z</published>
    <updated>2018-08-09T03:12:58.810Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第12篇介绍库的使用：库与合约的不同，使用库的正姿势。</p><p>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>库与合约类似，它也部署在一个指定的地址上（仅被部署一次，当代码在不同的合约可反复使用），然后通过EVM的特性DELEGATECALL (Homestead之前是用CALLCODE)来复用代码。库函数在被调用时，库代码是在发起合约（下文称<strong>主调合约</strong>：主动发起DELEGATECALL调用的合约）的上下文中执行的，使用this将会指向到主调合约，而且库代码可以访问主调合约的存储(storage)。</p><p>因为库合约是一个独立的代码，它仅可以访问主调合约明确提供的状态变量，否则，没办法法去知道这些状态变量。</p><p>对比普通合约来说，库存在以下的限制（这些限制将来也可能在将来的版本被解除）：</p><ol><li>无状态变量(state variables)。</li><li>不能继承或被继承</li><li>不能接收以太币</li><li>不能销毁一个库</li></ol><p>不会修改状态变量（例如被声明<strong>view</strong>或<strong>pure</strong>）库函数只能通过直接调用（如不用<strong>DELEGATECALL</strong>），是因为其被认为是状态无关的。</p><p>库有许多使用场景。两个主要的场景如下：</p><ol><li><p>如果有许多合约，它们有一些共同代码，则可以把共同代码部署成一个库。这将节省gas，因为gas也依赖于合约的规模。因此，可以把库想象成使用其合约的父合约。使用父合约（而非库）切分共同代码不会节省gas，因为在Solidity中，继承通过复制代码工作。</p></li><li><p>库可用于给数据类型添加成员函数。（参见下一节Using for）</p></li></ol><p>由于库被当作隐式的父合约（不过它们不会显式的出现在继承关系中，但调用库函数和调用父合约的方式是非常类似的，如库L有函数f()，使用L.f()即可访问）。库里面的内部（internal）函数被复制给使用它的合约；<br>同样按调用内部函数的调用方式，这意味着所有内部类型可以传进去，memory类型则通过引用传递，而不是拷贝的方式。 同样库里面的结构体structs和枚举enums也会被复制给使用它的合约。<br>因此，如果一个库里只包含内部函数或结构体或枚举，则不需要部署库，因为库里面的所有内容都被复制给使用它的合约。</p><p>下面的例子展示了如何使用库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">library <span class="built_in">Set</span> &#123;</span><br><span class="line">  <span class="comment">// 定义了一个结构体，保存主调函数的数据（本身并未实际存储的数据）。</span></span><br><span class="line">  struct Data &#123; mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// self是一个存储类型的引用（传入的会是一个引用，而不是拷贝的值），这是库函数的特点。</span></span><br><span class="line">  <span class="comment">// 参数名定为self 也是一个惯例，就像调用一个对象的方法一样.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已存在</span></span><br><span class="line">      self.flags[value] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">      self.flags[value] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">view</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="built_in">Set</span>.Data knownValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 库函数不需要实例化就可以调用，因为实例就是当前的合约</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="built_in">Set</span>.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这个合约中，如果需要的话可以直接访问knownValues.flags，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以不按上面的方式来使用库函数，可以不定义结构体，可以不使用storage类型引用的参数，还可以在任何位置有多个storage的引用类型的参数。</p><p>调用<strong>Set.contains</strong>，<strong>Set.remove</strong>，<strong>Set.insert</strong>都会编译为以DELEGATECALL的方式调用外部合约和库。如果使用库，需要注意的是一个真实的外部函数调用发生了。尽管msg.sender，msg.value，this还会保持它们在主调合约中的值（在Homestead之前，由于实际使用的是CALLCODE，msg.sender，msg.value会变化）。</p><p>下面的例子演示了在库中如何使用memory类型和内部函数(inernal function)来实现一个自定义类型，而不会用到外部函数调用(external function)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fromUint</span>(<span class="params">uint x</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bigint r</span>) </span>&#123;</span><br><span class="line">        r.limbs = <span class="keyword">new</span> uint[](<span class="number">1</span>);</span><br><span class="line">        r.limbs[<span class="number">0</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">bigint _a, bigint _b</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bigint r</span>) </span>&#123;</span><br><span class="line">        r.limbs = <span class="keyword">new</span> uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            <span class="keyword">if</span> (a + b &lt; a || (a + b == uint(<span class="number">-1</span>) &amp;&amp; carry &gt; <span class="number">0</span>))</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// too bad, we have to add a limb</span></span><br><span class="line">            uint[] memory newLimbs = <span class="keyword">new</span> uint[](r.limbs.length + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">limb</span>(<span class="params">bigint _a, uint _limb</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _limb &lt; _a.limbs.length ? _a.limbs[_limb] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">uint a, uint b</span>) <span class="title">private</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt <span class="keyword">for</span> BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = BigInt.fromUint(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">var</span> y = BigInt.fromUint(uint(<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">var</span> z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约的源码中不能添加库地址，它是在编译时向编译器以参数形式提供的（这些地址须由链接器（linker）填进最终的字节码中，使用命令行编译器来进行联接 TODO）。如果地址没有以参数的方式正确给到编译器，编译后的字节码将会仍包含一个这样格式的占们符<em>Set__</em>(其中Set是库的名称)。可以通过手动将所有的40个符号替换为库的十六进制地址。</p><h2 id="Using-for-指令"><a href="#Using-for-指令" class="headerlink" title="Using for 指令"></a>Using for 指令</h2><p>指令<strong>using A for B;</strong>用来把库函数(从库A)关联到类型B。这些函数将会把调用函数的实例作为第一个参数。语法类似，python中的self变量一样。例如：A库有函数 <strong>add(B b1, B b2)</strong>，则使用<strong>Using A for B</strong>指令后，如果有B b1就可以使用<strong>b1.add(b2)</strong>。</p><p>using A for *  表示库A中的函数可以关联到任意的类型上。</p><p>在这两种情形中，所有函数，即使第一个参数的类型与调用函数的对象类型不匹配的，也会被关联上。类型检查是在函数被调用时执行，以及函数重载是也会执行检查。</p><p><strong>using A for B;</strong> 指令仅在当前的作用域有效，且暂时仅仅支持当前的合约这个作用域，后续也非常有可能解除这个限制，允许作用到全局范围。如果能作用到全局范围，通过引入一些模块(module)，数据类型将能通过库函数扩展功能，而不需要每个地方都得写一遍类似的代码了。</p><p>下面我们使用Using for 指令方式重写上一节Set的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库合约代码和上一节一样</span></span><br><span class="line">library <span class="built_in">Set</span> &#123;</span><br><span class="line">  struct Data &#123; mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.flags[value])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// already there</span></span><br><span class="line">      self.flags[value] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// not there</span></span><br><span class="line">      self.flags[value] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">view</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using <span class="built_in">Set</span> <span class="keyword">for</span> <span class="built_in">Set</span>.Data; <span class="comment">// 这是一个关键的变化</span></span><br><span class="line">    <span class="built_in">Set</span>.Data knownValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 现在 Set.Data都对应的成员方法</span></span><br><span class="line">        <span class="comment">// 效果和Set.insert(knownValues, value)相同</span></span><br><span class="line">        <span class="built_in">require</span>(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以使用Using for的方式来对基本类型（elementary types）进行扩展： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">uint[] storage self, uint value</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">view</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; self.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (self[i] == value) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> uint(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search <span class="keyword">for</span> uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">uint _old, uint _new</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进行库调用</span></span><br><span class="line">        uint index = data.indexOf(_old);</span><br><span class="line">        <span class="keyword">if</span> (index == uint(<span class="number">-1</span>))</span><br><span class="line">            data.push(_new);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data[index] = _new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是所有库调用都实际上是EVM函数调用。这意味着，如果传的是memory类型的，或者是值类型，那么进行一次拷贝，即使是self变量，解决方法是使用存储(storage)类型的引用来避免拷贝内容。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第12篇介绍库的使用：库与合约的不同，使用库的正姿势。&lt;/p&gt;
&lt;p&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>Python实现一条基于POS算法的区块链</title>
    <link href="https://learnblockchain.cn/2018/08/07/python-blockchain-with-pos/"/>
    <id>https://learnblockchain.cn/2018/08/07/python-blockchain-with-pos/</id>
    <published>2018-08-07T12:44:00.000Z</published>
    <updated>2018-08-07T02:29:06.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链中的共识算法"><a href="#区块链中的共识算法" class="headerlink" title="区块链中的共识算法"></a>区块链中的共识算法</h1><p>在比特币公链架构解析中，就曾提到过为了实现去中介化的设计，比特币设计了一套共识协议，并通过此协议来保证系统的稳定性和防攻击性。 并且我们知道，截止目前使用最广泛，也是最被大家接受的共识算法，是我们先前介绍过的POW(proof of work)<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">工作量证明算法</a>。目前市值排名前二的比特币和以太坊也是采用的此算法。</p><a id="more"></a><p>虽然POW共识算法取得了巨大的成功，但对它的质疑也从来未曾停止过。 其中最主要的一个原因就是电力消耗。据不完全统计，基于POW的挖矿机制所消耗的电量是非常巨大的，甚至比绝大多数国家耗电量还要多。这对我们的资源造成了极大的浪费，此外随着比特大陆等公司的强势崛起，造成了算力的高度集中。</p><p>基于以上种种原因，更多的共识算法被提出来 POS、DPOS、BPFT等等。 今天我们就来认识POS(proof of stake)算法。</p><p>Proof of stake，译为权益证明。你可能已经猜到了，权益证明简单理解就是拥有更多token的人，有更大的概率获得记账权利，然后获得奖励。 这个概率具体有多大呢？ 下面我们在代码实现中会展示，分析也放在后面。 当然，POS是会比POW更好吗？ 会更去中心化吗？ 现在看来未必，所以我们这里也不去对比谁优谁劣。 我们站在中立的角度，单纯的来讨论讨论POS这种算法。</p><h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><h2 id="生成一个Block"><a href="#生成一个Block" class="headerlink" title="生成一个Block"></a>生成一个Block</h2><p>既然要实现POS算法，那么就难免要生成一条链，链又是由一个个Block生成的，所以下面我们首先来看看如何生成Block，当然在前面的内容里面，关于如何生成Block，以及交易、UTXO等等都已经介绍过了。由于今天我们的核心是实现POS，所以关于Block的生成，我们就用最简单的实现方式，好让大家把目光聚焦在核心的内容上面。</p><p>我们用三个方法来实现生成一个合法的区块</p><ul><li>calculate_hash  计算区块的hash值</li><li>is_block_valid  校验区块是否合法</li><li>generate_block  生成一个区块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_block</span><span class="params">(oldblock, bpm, address)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param oldblock:</span></span><br><span class="line"><span class="string">    :param bpm:</span></span><br><span class="line"><span class="string">    :param address:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    newblock = &#123;</span><br><span class="line">        <span class="string">"Index"</span>: oldblock[<span class="string">"Index"</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">"BPM"</span>: bpm,</span><br><span class="line">        <span class="string">"Timestamp"</span>: str(datetime.now()),</span><br><span class="line">        <span class="string">"PrevHash"</span>: oldblock[<span class="string">"Hash"</span>],</span><br><span class="line">        <span class="string">"Validator"</span>: address</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newblock[<span class="string">"Hash"</span>] = calculate_hash(newblock)</span><br><span class="line">    <span class="keyword">return</span> newblock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_hash</span><span class="params">(block)</span>:</span></span><br><span class="line">    record = <span class="string">""</span>.join([</span><br><span class="line">        str(block[<span class="string">"Index"</span>]),</span><br><span class="line">        str(block[<span class="string">"BPM"</span>]),</span><br><span class="line">        block[<span class="string">"Timestamp"</span>],</span><br><span class="line">        block[<span class="string">"PrevHash"</span>]</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sha256(record.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_block_valid</span><span class="params">(newblock, oldblock)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param newblock:</span></span><br><span class="line"><span class="string">    :param oldblock:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldblock[<span class="string">"Index"</span>] + <span class="number">1</span> != newblock[<span class="string">"Index"</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldblock[<span class="string">"Hash"</span>] != newblock[<span class="string">"PrevHash"</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> calculate_hash(newblock) != newblock[<span class="string">"Hash"</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>这里为了更灵活，我们没有用类的实现方式，直接采用函数来实现了Block生成，相信很容易看懂。</p><h2 id="创建一个TCP服务器"><a href="#创建一个TCP服务器" class="headerlink" title="创建一个TCP服务器"></a>创建一个TCP服务器</h2><p>由于我们需要用权益证明算法来选择记账人，所以需要从很多Node(节点)中选择记账人，也就是需要一个server让节点链接上来，同时要同步信息给节点。因此需要一个TCP长链接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> BaseRequestHandler, ThreadingTCPServer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># start a tcp server</span></span><br><span class="line">    serv = ThreadingTCPServer((<span class="string">''</span>, <span class="number">9090</span>), HandleConn)</span><br><span class="line">    serv.serve_forever()</span><br></pre></td></tr></table></figure><p>在这里我们用了python内库socketserver来创建了一个TCPServer。 需要注意的是，这里我们是采用的多线程的创建方式，这样可以保证有多个客户端同时连接上来，而不至于被阻塞。当然，这里这个server也是存在问题的，那就是有多少个客户端连接，就会创建多少个线程，更好的方式是创建一个线程池。由于这里是测试，所以就采用更简单的方式了。</p><p>相信大家已经看到了，在我们创建TCPServer的时候，使用到了HandleConn，但是我们还没有定义，所以接下来我们就来定义一个HandleConn</p><p>##消息处理器<br>下面我们来实现Handler函数，Handler函数在跟Client Node通信的时候，需要我们的Node实现下面的功能</p><ul><li>Node可以输入balance（token数量）  也就是股权数目</li><li>Node需要能够接收广播，方便Server同步区块以及记账人信息</li><li>添加自己到候选人名单 （候选人为持有token的人）</li><li>输入BPM生成Block</li><li>验证一个区块的合法性</li></ul><p>感觉任务还是蛮多的，接下来我们看代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue, Empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">block_chain = []</span><br><span class="line">temp_blocks = []</span><br><span class="line">candidate_blocks = Queue()  <span class="comment"># 创建队列，用于线程间通信</span></span><br><span class="line">announcements = Queue()</span><br><span class="line">validators = &#123;&#125;</span><br><span class="line"></span><br><span class="line">My_Lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleConn</span><span class="params">(BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Got connection from"</span>, self.client_address)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># validator address</span></span><br><span class="line">        self.request.send(<span class="string">b"Enter token balance:"</span>)</span><br><span class="line">        balance = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            balance = int(balance)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line">        t = str(datetime.now())</span><br><span class="line">        address = sha256(t.encode()).hexdigest()</span><br><span class="line">        validators[address] = balance</span><br><span class="line">        print(validators)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            announce_winner_t = threading.Thread(target=annouce_winner, args=(announcements, self.request,),</span><br><span class="line">                                                 daemon=<span class="keyword">True</span>)</span><br><span class="line">            announce_winner_t.start()</span><br><span class="line"></span><br><span class="line">            self.request.send(<span class="string">b"\nEnter a new BPM:"</span>)</span><br><span class="line">            bpm = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                bpm = int(bpm)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">del</span> validators[address]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># with My_Lock:</span></span><br><span class="line">            last_block = block_chain[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            new_block = generate_block(last_block, bpm, address)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_block_valid(new_block, last_block):</span><br><span class="line">                print(<span class="string">"new block is valid!"</span>)</span><br><span class="line">                candidate_blocks.put(new_block)</span><br><span class="line"></span><br><span class="line">            self.request.send(<span class="string">b"\nEnter a new BPM:\n"</span>)</span><br><span class="line"></span><br><span class="line">            annouce_blockchain_t = threading.Thread(target=annouce_blockchain, args=(self.request,), daemon=<span class="keyword">True</span>)</span><br><span class="line">            annouce_blockchain_t.start()</span><br></pre></td></tr></table></figure><p>这段代码，可能对大多数同学来说是有难度的，在这里我们采用了多线程的方式，同时为了能够让消息在线程间通信，我们使用了队列。 这里使用队列，也是为了我们的系统可以更好的拓展，后面如果可能，这一节的程序很容易拓展为分布式系统。 将多线程里面处理的任务拆分出去成独立的服务，然后用消息队列进行通信，就是一个简单的分布式系统啦。（是不是很激动？）</p><p>由于这里有难度，所以代码还是讲一讲吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># validator address</span></span><br><span class="line">    self.request.send(<span class="string">b"Enter token balance:"</span>)</span><br><span class="line">    balance = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        balance = int(balance)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line">    t = str(datetime.now())</span><br><span class="line">    address = sha256(t.encode()).hexdigest()</span><br><span class="line">    validators[address] = balance</span><br><span class="line">    print(validators)</span><br></pre></td></tr></table></figure><p>这一段就是我们提到的Node 客户端添加自己到候选人的代码，每链接一个客户端，就会添加一个候选人。 这里我们用添加的时间戳的hash来记录候选人。 当然也可以用其他的方式，比如我们代码里面的client_address </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">announce_winner_t = threading.Thread(target=annouce_winner, args=(announcements, self.request,),</span><br><span class="line">                                                daemon=<span class="keyword">True</span>)</span><br><span class="line">        announce_winner_t.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annouce_winner</span><span class="params">(announcements, request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param announcements:</span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg = announcements.get(block=<span class="keyword">False</span>)</span><br><span class="line">            request.send(msg.encode())</span><br><span class="line">            request.send(<span class="string">b'\n'</span>)</span><br><span class="line">        <span class="keyword">except</span> Empty:</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>然后接下来我们起了一个线程去广播获得记账权的节点信息到所有节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.request.send(<span class="string">b"\nEnter a new BPM:"</span>)</span><br><span class="line">            bpm = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                bpm = int(bpm)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">del</span> validators[address]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># with My_Lock:</span></span><br><span class="line">            last_block = block_chain[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            new_block = generate_block(last_block, bpm, address)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_block_valid(new_block, last_block):</span><br><span class="line">                print(<span class="string">"new block is valid!"</span>)</span><br><span class="line">                candidate_blocks.put(new_block)</span><br></pre></td></tr></table></figure><p>根据节点输入的BPM值生成一个区块，并校验区块的有效性。 将有效的区块放到候选区块当中，等待记账人将区块添加到链上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">annouce_blockchain_t = threading.Thread(target=annouce_blockchain, args=(self.request,), daemon=<span class="keyword">True</span>)</span><br><span class="line">        annouce_blockchain_t.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annouce_blockchain</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        time.sleep(<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">with</span> My_Lock:</span><br><span class="line">            output = json.dumps(block_chain)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request.send(output.encode())</span><br><span class="line">            request.send(<span class="string">b'\n'</span>)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后起一个线程，同步区块链到所有节点。</p><p>看完了，节点跟Server交互的部分，接下来是最重要的部分，</p><h2 id="POS算法实现"><a href="#POS算法实现" class="headerlink" title="POS算法实现"></a>POS算法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick_winner</span><span class="params">(announcements)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择记账人</span></span><br><span class="line"><span class="string">    :param announcements:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">with</span> My_Lock:</span><br><span class="line">            temp = temp_blocks</span><br><span class="line"></span><br><span class="line">        lottery_pool = []  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> temp:</span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> temp:</span><br><span class="line">                <span class="keyword">if</span> block[<span class="string">"Validator"</span>] <span class="keyword">not</span> <span class="keyword">in</span> lottery_pool:</span><br><span class="line">                    set_validators = validators</span><br><span class="line">                    k = set_validators.get(block[<span class="string">"Validator"</span>])</span><br><span class="line">                    <span class="keyword">if</span> k:</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                            lottery_pool.append(block[<span class="string">"Validator"</span>])</span><br><span class="line"></span><br><span class="line">            lottery_winner = choice(lottery_pool)</span><br><span class="line">            print(lottery_winner)</span><br><span class="line">            <span class="comment"># add block of winner to blockchain and let all the other nodes known</span></span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> temp:</span><br><span class="line">                <span class="keyword">if</span> block[<span class="string">"Validator"</span>] == lottery_winner:</span><br><span class="line">                    <span class="keyword">with</span> My_Lock:</span><br><span class="line">                        block_chain.append(block)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># write message in queue.</span></span><br><span class="line">                    msg = <span class="string">"\n&#123;0&#125; 赢得了记账权利\n"</span>.format(lottery_winner)</span><br><span class="line">                    announcements.put(msg)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> My_Lock:</span><br><span class="line">            temp_blocks.clear()</span><br></pre></td></tr></table></figure><p>这里我们用pick_winner 来选择记账权利，我们根据token数量构造了一个列表。 一个人获得记账权利的概率为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = mount[&apos;NodeA&apos;]/mount[&apos;All&apos;]</span><br></pre></td></tr></table></figure></p><p>文字描述就是其token数目在总数中的占比。 比如总数有100个，他有10个，那么其获得记账权的概率就是0.1， 到这里核心的部分就写的差不多了，接下来，我们来添加节点，开始测试吧 </p><h1 id="测试POS的记账方式"><a href="#测试POS的记账方式" class="headerlink" title="测试POS的记账方式"></a>测试POS的记账方式</h1><p>在测试之前，起始还有一部分工作要做，前面我们的run方法需要完善下，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># create a genesis block</span></span><br><span class="line">    t = str(datetime.now())</span><br><span class="line">    genesis_block = &#123;</span><br><span class="line">        <span class="string">"Index"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"Timestamp"</span>: t,</span><br><span class="line">        <span class="string">"BPM"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"PrevHash"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"Validator"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    genesis_block[<span class="string">"Hash"</span>] = calculate_hash(genesis_block)</span><br><span class="line">    print(genesis_block)</span><br><span class="line">    block_chain.append(genesis_block)</span><br><span class="line"></span><br><span class="line">    thread_canditate = threading.Thread(target=candidate, args=(candidate_blocks,), daemon=<span class="keyword">True</span>)</span><br><span class="line">    thread_pick = threading.Thread(target=pick_winner, args=(announcements,), daemon=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    thread_canditate.start()</span><br><span class="line">    thread_pick.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># start a tcp server</span></span><br><span class="line">    serv = ThreadingTCPServer((<span class="string">''</span>, <span class="number">9090</span>), HandleConn)</span><br><span class="line">    serv.serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">candidate</span><span class="params">(candidate_blocks)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param candidate_blocks:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            candi = candidate_blocks.get(block=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">except</span> Empty:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp_blocks.append(candi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><h1 id="添加节点连接到TCPServer"><a href="#添加节点连接到TCPServer" class="headerlink" title="添加节点连接到TCPServer"></a>添加节点连接到TCPServer</h1><p>为了充分减少程序的复杂性，tcp client我们这里就不实现了，可以放在后面拓展部分。 毕竟我们这个系统是很容易扩展的，后面我们拆分了多线程的部分，在实现tcp client就是一个完整的分布式系统了。</p><p>所以，我们这里用linux自带的命令 nc，不知道nc怎么用的同学可以google或者 man nc<br><img src="https://diycode.b0.upaiyun.com/photo/2018/de1ec95397b1f627c1ded8fc3ac256e1.png" alt=""></p><ul><li>启动服务    运行 python pos.py  </li><li>打开3个终端</li><li>分别输入下面命令<ul><li>nc localhost 9090</li></ul></li></ul><p>终端如果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter token balance:</span><br></pre></td></tr></table></figure></p><p>说明你client已经链接服务器ok啦.</p><h1 id="测试POS的记账方式-1"><a href="#测试POS的记账方式-1" class="headerlink" title="测试POS的记账方式"></a>测试POS的记账方式</h1><p>接下来依次按照提示操作。 balance可以按心情来操作，因为这里是测试，我们输入100，<br>紧接着会提示输入BPM，我们前面提到过，输入BPM是为了生成Block，那么就输入吧，随便输入个9. ok， 接下来就稍等片刻，等待记账。<br>输出如同所示<br><img src="https://diycode.b0.upaiyun.com/photo/2018/4eee010dfd46e7672d48d063b08cae47.png" alt=""><br>依次在不同的终端，根据提示输入数字，等待消息同步。</p><h1 id="生成区块链"><a href="#生成区块链" class="headerlink" title="生成区块链"></a>生成区块链</h1><p>下面是我这边获得的3个block信息。<br><img src="https://diycode.b0.upaiyun.com/photo/2018/1e5f93c93cc2bc5443902b89abd4ac02.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在上面的代码中，我们实现了一个完整的基于POS算法记账的链，当然这里有许多值得扩展与改进的地方。</p><ul><li>python中多线程开销比较大，可以改成协程的方式</li><li>TCP建立的长链接是基于TCPServer，是中心化的方式，可以改成P2P对等网络</li><li>链的信息不够完整</li><li>系统可以拓展成分布式，让其更健壮</li></ul><p>大概列了以上几点，其他还有很多可以拓展的地方，感兴趣的朋友可以先玩玩， 后者等到我们后面的教程。 （广告打的措手不及，哈哈）</p><p>当然了，语言不是重点，所以在这里，我也实现了go语言的版本<a href="https://github.com/csunny/argo/tree/master/src/pos" target="_blank" rel="noopener">源码地址</a></p><p>go语言的实现感觉要更好理解一点，也显得要优雅一点。这也是为什么go语言在分布式领域要更抢手的原因之一吧！</p><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><ul><li><a href="https://github.com/csunny/py-bitcoin/" target="_blank" rel="noopener">https://github.com/csunny/py-bitcoin/</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://medium.com/@mycoralhealth/code-your-own-proof-of-stake-blockchain-in-go-610cd99aa658" target="_blank" rel="noopener">https://medium.com/@mycoralhealth/code-your-own-proof-of-stake-blockchain-in-go-610cd99aa658</a></li></ul><p>我的<strong><a href="https://xiaozhuanlan.com/eosio" target="_blank" rel="noopener">专栏</a></strong>专注区块链底层技术开发，P2P网络、加密技术、MerkleTree、DAG、DHT等等，另外对于分布式系统的学习也很有帮助。欢迎大家交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区块链中的共识算法&quot;&gt;&lt;a href=&quot;#区块链中的共识算法&quot; class=&quot;headerlink&quot; title=&quot;区块链中的共识算法&quot;&gt;&lt;/a&gt;区块链中的共识算法&lt;/h1&gt;&lt;p&gt;在比特币公链架构解析中，就曾提到过为了实现去中介化的设计，比特币设计了一套共识协议，并通过此协议来保证系统的稳定性和防攻击性。 并且我们知道，截止目前使用最广泛，也是最被大家接受的共识算法，是我们先前介绍过的POW(proof of work)&lt;a href=&quot;https://learnblockchain.cn/2017/11/04/bitcoin-pow/&quot;&gt;工作量证明算法&lt;/a&gt;。目前市值排名前二的比特币和以太坊也是采用的此算法。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://learnblockchain.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/bitcoin/"/>
    
    
      <category term="区块链" scheme="https://learnblockchain.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="权益证明" scheme="https://learnblockchain.cn/tags/%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/"/>
    
      <category term="Python" scheme="https://learnblockchain.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>什么是EOS（柚子）</title>
    <link href="https://learnblockchain.cn/2018/07/17/whatiseos/"/>
    <id>https://learnblockchain.cn/2018/07/17/whatiseos/</id>
    <published>2018-07-17T06:25:44.000Z</published>
    <updated>2018-07-31T02:40:09.016Z</updated>
    
    <content type="html"><![CDATA[<p>是时候给写写EOS了，现在EOS主网已经上线，尽管我个人不是很喜欢EOS项目（不过也一直在关注EOS），但是不可否认EOS这个争议性很大的项目给区块链世界带来的变化。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，如果了解过比特币及以太坊，可以更好的理解本文。欢迎订阅专栏：<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a><br>指引你从头开始学区块链技术。</p><p>本文出现EOS是指EOS.io公链项目，不是指以太坊上的EOS Token。</p><h2 id="EOS-简介"><a href="#EOS-简介" class="headerlink" title="EOS 简介"></a>EOS 简介</h2><p>EOS: Enterprise Operation System 中文意思为：商业级区块链操作系统。</p><p>尽管以太坊创造性引入智能合约概念，极大的简化了区块链应用的开发，但以太坊平台依然有一个很大的限制，就是交易确认时间及交易吞吐量比较小，从而严重影响了以太坊进行商业应用。</p><blockquote><p>交易吞吐量有一个专门的词：TPS （transaction per second 每秒的交易量） 比特币的TPS 是大概7，并且最少几十分钟交易才能被确认，以太坊的TPS大概是20左右，交易的确认一般需要几分钟的时间。<br>不过比特币以太坊也在不断进化以提高TPS，比如比特币的闪电网络，以太坊的Sharding技术（分片）以及Plasma技术（分层）。</p></blockquote><p>EOS 项目的目标是建立可以承载商业级智能合约与应用的区块链基础设施，成为区块链世界的“底层操作系统”。<br>EOS通过<strong>石墨烯技术</strong>解决延迟和数据吞吐量问题，TPS可达到数千，交易的确认时间也只有数秒。同时声称未来使用并行链的方式，最高可以达到数百万TPS。</p><p>EOS 设计了一套账户权限管理系统，EOS不再使用的地址作为账户，可以直接使用字符作为账户名，并设计了一套的账户权限体系。</p><p>此外，在 EOS 上转账交易及运行智能合约不需要消耗 EOS代币。而是EOS 系统当中，抵押代币获取对应的资源，来执行相应交易，在EOS运行程序完全免费的说是不准确的。</p><blockquote><p>值的一提的是EOS项目其ICO也是基于以太坊<a href="https://learnblockchain.cn/2018/01/12/create_token/">ERC20 Token</a>进行的，其ICO 时间长达355天，作为一个当时还未上线的项目，融资额达到40亿美元是前所未有。</p></blockquote><h3 id="充满争议的技术天才BM"><a href="#充满争议的技术天才BM" class="headerlink" title="充满争议的技术天才BM"></a>充满争议的技术天才BM</h3><p>EOS的主要开发者为丹尼尔·拉瑞莫（Daniel Larimer）, 绰号BM(GitHub的昵称：ByteMaster), 它是EOS的项目方，BlockOne公司的CTO。<br>和V神一样，也是一个神奇的人物，网络上两人因理念不合有多次论战。BM有一句牛B 轰轰的话：我终生的使命，是致力于找到一些加密经济的解决方案，给所有人的财产、自由、平等带来保障。</p><p>BM成功创立过三个区块链项目：BitShares、Steem 以及EOS，是一个技术天才，也是一个多变的人。<br>2009年的BM也准备的数字货币一展身手，在其研究比特币之后，2010年BM提出了一些比特币的问题，并想要改进，结果比特币的创始人中本聪（Satoshi Nakamoto）怼会了他“If you don’t believe me or don’t get it, I don’t have time to try to convince you, sorry.”（懂不懂随你，我可没时间理你）。<br>于是BM开始着手创建自己的区块链项目，这就是2013年发布的 BitShares 比特股，世界上第一个数字货币去中心化交易所。</p><p>BitShares在2014年上线时，是当时的明星项目，也由于bug太多、糟糕的体验以及BM在进行个别版本升级的时候都不提供向下兼容，用户逐渐流失，更要命的是，BM利用自己超过1/3的记账节点，在没有达成社区共识的情况下，强行分叉增发了BitShares发行总量。尽管BM在技术提供了改进，发布了石墨烯工具集，不过最终社区投票决定让BM离开了BitShares。</p><p>离开BitShares的BM，于2016年创立了区块链项目Steem，去中心化社交网站Steemit就是基于Steem创建，在Steemit的运营期间，BM和Steemit的CEO Ned有过多次口水战。<br>在2017年，BM离开了自己创建的Steem项目（也许除了BM自己，没有人能知道他离开Steem的真实原因），选择与布鲁默联合创办了BlockOne公司打造EOS项目。</p><h2 id="石墨烯（Graphene）与-DPOS"><a href="#石墨烯（Graphene）与-DPOS" class="headerlink" title="石墨烯（Graphene）与 DPOS"></a>石墨烯（Graphene）与 DPOS</h2><p>和BitShares、Steem 一样，EOS底层使用的也是石墨烯技术，石墨烯是一个开源的区块链底层库，也出自BM之手，它采用的是 DPOS（Delegated Proof-of-Stake 股份授权证明机制 ）的共识机制。<br>在比特币及以太坊网络中，任何人都可以参与记账，而DPOS为了提高出块速度TPS，限制了参与记账了人数，在DPOS中，记账者不在称为矿工，而是改称为见证人 Witness，现在EOS中，又有一个新词：Block Producer，简称BP，大家翻译为超级节点（本文中依旧会使用见证人这个词，超级节点更像是一个市场营销用词）。</p><p>在EOS中，见证人的个数是21个，BitShares中是101个，BitShares的出块时间打开是 1.5秒，在EOS中，出块时间提高到了0.5秒。</p><p>和Pow及Pos共识机制矿工可以自由选择参与挖矿不同，DPOS下节点需要参与见证人选举，只有赢得选举的节点才能负责出块，在EOS中，赢得选举21个节点见证人轮流出块。<br>另外还有100个备用见证人（候选节点），在21个见证人出现问题后做替补。EOS的发行总量是10亿， 见证人在完成打包交易区块后，可以领取到区块的奖励，区块的奖励来自对发行量的通胀增发，通胀率每年接近5%。</p><h2 id="BM特色的去中心化"><a href="#BM特色的去中心化" class="headerlink" title="BM特色的去中心化"></a>BM特色的去中心化</h2><p>我个人理解的区块链，它最大的革命性就是他的中立性，其运行不应该受到任何人的干扰，在POW共识中，矿工、项目方（开发者）以及交易方他们是相互独立的存在。</p><p>在EOS中，BM本人拥有巨量的选票，他可以在一定程度上左右见证人的选举，同时BM还为EOS制定了宪法，要求所有的见证人必须遵照宪法。因此BM某种程度上可以左右EOS系统的运行。</p><p>本文是个人对EOS的理解，受我自己视野局限也许理解有偏差，欢迎大家批准指正，我的微信： xlbxiong。</p><h2 id="EOS相关资料："><a href="#EOS相关资料：" class="headerlink" title="EOS相关资料："></a>EOS相关资料：</h2><ul><li><a href="https://developers.eos.io/" target="_blank" rel="noopener">EOS开发者资源</a></li><li><a href="https://eos.io" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://github.com/EOSIO" target="_blank" rel="noopener">Github 代码</a></li></ul><p>我们为区块链爱者这提供了系统的区块链视频教程，觉得文章学习不过瘾的同学可以戳<a href="https://learnblockchain.cn/course/">区块链视频教程</a>。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是时候给写写EOS了，现在EOS主网已经上线，尽管我个人不是很喜欢EOS项目（不过也一直在关注EOS），但是不可否认EOS这个争议性很大的项目给区块链世界带来的变化。&lt;/p&gt;
    
    </summary>
    
      <category term="EOS" scheme="https://learnblockchain.cn/categories/EOS/"/>
    
    
      <category term="EOS入门" scheme="https://learnblockchain.cn/tags/EOS%E5%85%A5%E9%97%A8/"/>
    
      <category term="柚子" scheme="https://learnblockchain.cn/tags/%E6%9F%9A%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>搭建智能合约开发环境Remix IDE及使用</title>
    <link href="https://learnblockchain.cn/2018/06/07/remix-ide/"/>
    <id>https://learnblockchain.cn/2018/06/07/remix-ide/</id>
    <published>2018-06-07T02:56:04.000Z</published>
    <updated>2018-07-31T02:39:48.191Z</updated>
    
    <content type="html"><![CDATA[<p>目前开发智能的IDE， 首推还是Remix, 而Remix<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a>, 总是由于各种各样的（网络）原因无法使用，本文就来介绍一下如何在本地搭建智能合约开发环境remix-ide并介绍Remix的使用。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Remix 是以太坊智能合约编程语言Solidity IDE，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果还不了解，建议先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>。</p><h2 id="Remix-IDE-介绍"><a href="#Remix-IDE-介绍" class="headerlink" title="Remix IDE 介绍"></a>Remix IDE 介绍</h2><p>Remix IDE 是一款基于浏览器的IDE，跟有些开发聊的时候，发现有一些同学对浏览器的IDE，有一些偏见，其实Atom编辑器就是基于web技术开发的一款编辑器（Atom可以看做一个没有地址栏的浏览器），其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。</p><p>Remix IDE的功能全面（传统IDE有的功能这里都有），比如：</p><ol><li>代码提示补全，代码高亮</li><li>代码警告、错误提示</li><li>运行日志输出</li><li>代码调试</li><li>…</li></ol><h2 id="Remix-IDE-安装"><a href="#Remix-IDE-安装" class="headerlink" title="Remix IDE 安装"></a>Remix IDE 安装</h2><blockquote><p>更新： Remix 现在提供了一个APP, 叫Remix APP， 如果是Mac 电脑，可以直接使用其提供的发布包，地址为：<a href="https://github.com/horizon-games/remix-app/releases" target="_blank" rel="noopener">https://github.com/horizon-games/remix-app/releases</a></p></blockquote><p>如果你有很好的网络环境，可以直接访问Remix<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a>。<br>要不能还是还是像我一样老老实实把Remix IDE安装在本地，我发现要想成功安装选择对应的版本很关键，具体的版本要求如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node --version</span><br><span class="line">v7<span class="number">.10</span><span class="number">.1</span></span><br><span class="line">$ npm --version</span><br><span class="line"><span class="number">4.2</span><span class="number">.0</span></span><br><span class="line">$ nvm --version</span><br><span class="line"><span class="number">0.33</span><span class="number">.11</span></span><br></pre></td></tr></table></figure><h3 id="nvm-安装"><a href="#nvm-安装" class="headerlink" title="nvm 安装"></a>nvm 安装</h3><p>nvm 是一个node 版本工具，我们可以使用nvm来安装不同版本的node。<br>nvm 官方<a href="https://github.com/creationix/nvm/blob/master/README.md" target="_blank" rel="noopener">安装方法</a>如下：</p><ol><li><p>命令行中输入：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br></pre></td></tr></table></figure></li><li><p>在当前用户profile文件，如（~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc）添加加载nvm的脚本：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span><br></pre></td></tr></table></figure></li><li><p>重启下命令行，输入nvm 试试，应该可以看到 nvm 命令的帮助</p></li></ol><h3 id="使用nvm-安装node"><a href="#使用nvm-安装node" class="headerlink" title="使用nvm 安装node"></a>使用nvm 安装node</h3><p>因为Remix IDE 要求使用node 7.10.1, 命令行输入一下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 7</span><br></pre></td></tr></table></figure><p>安装完成之后，使用node –version 和 npm –version检查下版本号，是否和刚刚列出版本要求一致，在版本一值的qing</p><h3 id="命令行安装Remix-ide"><a href="#命令行安装Remix-ide" class="headerlink" title="命令行安装Remix ide"></a>命令行安装Remix ide</h3><p><strong>方法1</strong><br>直接使用npm安装，这也是我安装使用的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install remix-ide -g</span><br><span class="line">remix-ide</span><br></pre></td></tr></table></figure></p><p>如果出现错误：<br>Error: EACCES: permission denied, access ‘/usr/local/lib/node_modules’<br>可以尝试用以下方法解决：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们使用的是正确的node 和npm 版本的话，应该都可以安装成功，安装成功之后，remix-ide命令用来启动ide.</p><p><strong>方法2</strong><br>remix-ide的github 上还提供了另一个方法进行安装，通过clone 代码来安装，方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ethereum/remix-ide.git</span><br><span class="line"><span class="built_in">cd</span> remix-ide</span><br><span class="line">npm install</span><br><span class="line">npm run setupremix  <span class="comment"># this will clone https://github.com/ethereum/remix for you and link it to remix-ide</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h2 id="Remix-ide-使用"><a href="#Remix-ide-使用" class="headerlink" title="Remix ide 使用"></a>Remix ide 使用</h2><p>Remix IDE 默认是使用8080端口启动的，启动之后在浏览器打开：<code>http://localhost:8080/</code>, 如图：</p><p><img src="/images/remix-setup.jpg" alt=""></p><p>和大多数IDE一样，最左边是文件浏览，中间是代码编辑区域，右边是功能区域，下边是日志区域。<br>在右侧的功能区域，常用的是<code>Compile</code>、<code>Run</code>及<code>Debuger</code>几个标签页（Tab）。</p><p>在<code>Compile</code>页，会动态的显示当前编辑区域合约的编译信息，如显示错误和警告。编译的直接码信息及ABI接口可以通过点击<code>Details</code>查看到。<br>在<a href="https://learnblockchain.cn/2017/11/24/init-env/">这篇文章里</a> 也有截图说明。<br>在<code>Run</code>页，可以部署合约，以及调用合约函数等，使用非常简单，我们前面也有多篇文章讲解。<br><code>Debuger</code>页在下面调试一节单独讲解。</p><h3 id="Remix-ide-加载本地磁盘文件"><a href="#Remix-ide-加载本地磁盘文件" class="headerlink" title="Remix ide 加载本地磁盘文件"></a>Remix ide 加载本地磁盘文件</h3><p>这是一个非常用的功能，但发现使用的人非常少，通过加载本地磁盘文件，就可以方便代码管理工具（如 git）管理我们的合约代码。<br>我详细介绍下如何这个功能怎么使用？</p><blockquote><p>使用在线版本的Remix可以使用这个功能， 不过需要安装一下<a href="https://github.com/ethereum/remixd" target="_blank" rel="noopener">remixd</a>, 安装使用命令<code>npm install -g remixd</code>。</p></blockquote><ol><li><p>在需要的本地合约代码的目录下启动<code>remix-ide</code>, Remix IDE 会自动把当前目录做为共享目录。如果是使用在线的Remix，需要使用命令<code>remixd -s shared-folder</code> 来指定共享目录。</p></li><li><p>加载共享目录，在文件浏览区域上有，有这样一个图标，他用来加载本地共享目录，如图：<br><img src="https://learnblockchain.cn/images/remixd_connectionok.png" alt=""></p></li></ol><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在合约编写过程中，合约调试是必不可少的一部分，为了模拟调试的过程，我故意在代码中加入一ge错误的逻辑代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line">​</span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    </span><br><span class="line">    uint storedData;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData += x;    <span class="comment">// 错误的，多加了一个加号</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入了错误的逻辑之后，我第2次调用set函数，合约状态变量的值，可能会出错（如果第一次不是用参数0去调用的话）。<br>注意如果需要调试合约，在部署合约的环境应该选择：JavaScript VM。</p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>在我们每次执行一个交易（不管是方式调用还是函数执行）的时候，在日志都会输出一条记录，如图：<br><img src="https://learnblockchain.cn/images/remix-debug-console.png" alt=""></p><p>点击上图中的“Debug”按钮，在Remix右侧的功能区域会切换到调试面板，如下图：<br><img src="/images/remix-debug-panel.png" alt=""><br>调试过程过程中，有下面几项需要重点关注：</p><ul><li><p>Transactions: 可以查看交易及交易的执行过程，并且提供了7个调试的按钮，如下图：<br><img src="https://learnblockchain.cn/images/remix-debug-buttons.png" alt=""></p><p>  为了方便介绍，我为每个按钮编了号，每个按钮的含义是：</p><ol><li>后退一步（不进入函数内部）</li><li>后退一步（进入函数内部）</li><li>前进一步（进入函数内部）</li><li>前进一步（不进入函数内部）</li><li>跳到上一个断点</li><li>跳出当前调用</li><li>跳到下一个断点</li></ol></li><li>Solidity Locals：显示当前上下文的局部变量的值， 如图：</li></ul><p><img src="https://learnblockchain.cn/images/remix-debug-locals.png" alt=""></p><ul><li>Solidity State： 显示当前执行合约的状态变量，如下图:<br><img src="https://learnblockchain.cn/images/remix-debug-state.png" alt=""></li></ul><p>在本例中，我们跟踪运行步骤的时候，可以看到局部变量的值为2，赋值给状态变量之后，状态变量的值更改为了3，所以可以判断运行当前语句的时候出错了。</p><ul><li>Step detail： 显示当前步骤的gas详情等，如下图:<br><img src="https://learnblockchain.cn/images/remix-debug-gas.png" alt=""></li></ul><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>这部分为小专栏读者准备，欢迎订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/ethereum/remix-ide" target="_blank" rel="noopener">remix-ide github</a></li><li><a href="http://remix.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Remix Document</a></li></ol><p>我们还为区块链技术爱好者提供了系统的区块链视频教程，觉得文章学习不过瘾的同学可以戳<a href="https://wiki.learnblockchain.cn/course/beginner.html" target="_blank" rel="noopener">入门视频教程</a>及<a href="https://wiki.learnblockchain.cn/course/solidity.html" target="_blank" rel="noopener">以太坊智能合约开发</a>。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你学习区块链中遇到问题，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>问答社区，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了300多位区块链技术牛人和爱好者。</p><!---在本例中，我们的代码比较简单，执行的不多，可以不用设置断点，如果代码比较多，这可以设置断点，利用上面介绍的第7个按钮快速的调转到断点处，设置断点的方法很简单，在编辑区域，点击代码的行号，就可以在当前行设置一个断点，如下图：![](/images/remix-debug-break.png)上图在第8行出设置了一个断点，成功设置断点会在行号处，加上一个色块来标示断点。取消断点的方式是，再次点击断点处。有一点需要注意一下，如果在声明变量的地方设置断点，这断点可能会触发两次，第一次是初始化为0，第二次是赋实际的值。-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前开发智能的IDE， 首推还是Remix, 而Remix&lt;a href=&quot;https://remix.ethereum.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;, 总是由于各种各样的（网络）原因无法使用，本文就来介绍一下如何在本地搭建智能合约开发环境remix-ide并介绍Remix的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="IDE" scheme="https://learnblockchain.cn/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Solidity 教程系列11 - 视图函数、虚函数讲解</title>
    <link href="https://learnblockchain.cn/2018/05/17/solidity-functions/"/>
    <id>https://learnblockchain.cn/2018/05/17/solidity-functions/</id>
    <published>2018-05-17T14:16:29.000Z</published>
    <updated>2018-08-09T02:58:50.242Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第11篇 - Solidity 视图函数、虚函数讲解。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="视图函数（View-Functions）"><a href="#视图函数（View-Functions）" class="headerlink" title="视图函数（View Functions）"></a>视图函数（View Functions）</h2><p>一个函数如果它不修改状态变量，应该声明为<strong>view</strong>函数，不过下面几种情况认为是修改了状态：</p><ol><li>写状态变量</li><li>触发事件（events）</li><li>创建其他的合约</li><li>call调用附加了以太币</li><li>调用了任何没有<strong>view</strong>或<strong>pure</strong>修饰的函数</li><li>使用了低级别的调用（low-level calls）</li><li>使用了包含特定操作符的内联汇编</li></ol><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>) + now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误做法，虽然可以编译通过</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">df</span>(<span class="params">uint a</span>) <span class="title">public</span> <span class="title">view</span>  </span>&#123;</span><br><span class="line">        data = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个地方需要注意一下：</p><ol><li>声明为<strong>view</strong> 和声明为<strong>constant</strong>是等价的，constant是view的别名，constant在计划Solidity 0.5.0版本之后会弃用（constant这个词有歧义，view 也更能表达返回值可视）。</li><li>访问函数都被标记为view。</li></ol><p>当前编译器并未强制要求声明为view，但建议大家对于不会修改状态的函数的标记为view。</p><h2 id="纯函数（Pure-Functions）"><a href="#纯函数（Pure-Functions）" class="headerlink" title="纯函数（Pure Functions）"></a>纯函数（Pure Functions）</h2><p>函数可以声明为<strong>view</strong>，表示它即不读取状态，也不修改状态，除了上一节介绍的几种修改状态的情况，以下几种情况被认为是读取了状态：</p><ol><li>读状态变量</li><li>访问了 <strong>this.balance</strong> 或 <strong>\<address>.balance</address></strong></li><li>访问了<strong>block</strong>, <strong>tx</strong>, <strong>msg</strong> 的成员 (msg.sig 和 msg.data除外).</li><li>调用了任何没有<strong>pure</strong>修饰的函数</li><li>使用了包含特定操作符的内联汇编</li></ol><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管view 和 pure 修饰符编译器并未强制要求使用，view 和 pure 修饰也不会带来gas 消耗的改变，但是更好的编码习惯让我们跟容易发现智能合约中的错误。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/develop/contracts.html#functions" target="_blank" rel="noopener">官方文档-函数</a></p><p>欢迎来<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>提问，星球内已经聚集了300多位区块链技术爱好者。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第11篇 - Solidity 视图函数、虚函数讲解。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/Solidity/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>详解 Solidity 事件Event - 完全搞懂事件的使用</title>
    <link href="https://learnblockchain.cn/2018/05/09/solidity-event/"/>
    <id>https://learnblockchain.cn/2018/05/09/solidity-event/</id>
    <published>2018-05-09T12:37:03.000Z</published>
    <updated>2018-08-15T14:42:41.180Z</updated>
    
    <content type="html"><![CDATA[<p>很多同学对Solidity 中的Event有疑问，这篇文章就来详细的看看Solidity 中Event到底有什么用？</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>，另外<br>本文在监听合约事件是对上一篇<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>进行补充，如果阅读了上一篇可以更好的理解本文。</p><h2 id="什么是事件Evnet"><a href="#什么是事件Evnet" class="headerlink" title="什么是事件Evnet"></a>什么是事件Evnet</h2><p>事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并记录到区块链中.<br>来捋这个关系：区块链是打包一系列交易的区块组成的链条，每一个交易“收据”会包含0到多个日志记录，日志代表着智能合约所触发的事件。</p><p><strong>在DAPP的应用中，如果监听了某事件，当事件发生时，会进行回调。</strong><br>不过要注意：日志和事件在合约内是无法被访问的，即使是创建日志的合约。</p><p>在Solidity 代码中，使用event 关键字来定义一个事件，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event EventName(address bidder, uint amount);</span><br></pre></td></tr></table></figure><p>这个用法和定义函数式一样的，并且事件在合约中同样可以被继承。触发一个事件使用emit(说明，之前的版本里并不需要使用emit)，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emit EventName(msg.sender, msg.value);</span><br></pre></td></tr></table></figure><p>触发事件可以在任何函数中调用，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testEvent</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发一个事件</span></span><br><span class="line">     emit EventName(msg.sender, msg.value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>通过上面的介绍，可能大家还是不清楚事件有什么作用，如果你跟过<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>这篇文章，你会发现点击”Updata Info”按钮之后，虽然调用智能合约成功，但是当前的界面并没有得到更新。<br>使用事件监听，就可以很好的解决这个问题，让看看如何实现。</p><h3 id="修改合约，定义事件及触发事件"><a href="#修改合约，定义事件及触发事件" class="headerlink" title="修改合约，定义事件及触发事件"></a>修改合约，定义事件及触发事件</h3><p>先回顾一下合约代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract InfoContract &#123;</span><br><span class="line">    </span><br><span class="line">   string fName;</span><br><span class="line">   uint age;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">       fName = _fName;</span><br><span class="line">       age = _age;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">string, uint</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (fName, age);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，需要定义一个事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">event Instructor(</span><br><span class="line">      string name,</span><br><span class="line">      uint age</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>这个事件中，会接受两个参数：name 和  age , 也就是需要跟踪的两个信息。</p><p>然后，需要在setInfo函数中，触发Instructor事件，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    fName = _fName;</span><br><span class="line">    age = _age;</span><br><span class="line">    emit Instructor(_fName, _age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://learnblockchain.cn/2018/04/15/web3-html/">Web3与智能合约交互实战</a>, 点击”Updata Info”按钮之后，会调用setInfo函数，函数时触发Instructor事件。</p><h3 id="使用Web3监听事件，刷新UI"><a href="#使用Web3监听事件，刷新UI" class="headerlink" title="使用Web3监听事件，刷新UI"></a>使用Web3监听事件，刷新UI</h3><p>现在需要使用Web3监听事件，刷新UI。<br>先回顾下之前的使用Web3和智能合约交互的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">"http://localhost:7545"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> infoContract = web3.eth.contract(ABI INFO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> info = infoContract.at(<span class="string">'CONTRACT ADDRESS'</span>);</span><br><span class="line"></span><br><span class="line">    info.getInfo(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!error)</span><br><span class="line">            &#123;</span><br><span class="line">                $(<span class="string">"#info"</span>).html(result[<span class="number">0</span>]+<span class="string">' ('</span>+result[<span class="number">1</span>]+<span class="string">' years old)'</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(result);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">"#button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        info.setInfo($(<span class="string">"#name"</span>).val(), $(<span class="string">"#age"</span>).val());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>现在可以不需要 info.getInfo()来获取信息，而改用监听事件获取信息，先定义一个变量引用事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor();</span><br></pre></td></tr></table></figure><p>然后使用<strong>.watch()</strong>方法来添加一个回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">instructorEvent.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            &#123;</span><br><span class="line">                $(<span class="string">"#info"</span>).html(result.args.name + <span class="string">' ('</span> + result.args.age + <span class="string">' years old)'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(error);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>代码更新之后，可以在浏览器查看效果，这是点击”Updata Info”按钮之后，会及时更新界面，如图：<br><img src="/images/solidity_event.jpg" alt=""></p><p>完整的代码请订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="事件高级用法-过滤器"><a href="#事件高级用法-过滤器" class="headerlink" title="事件高级用法-过滤器"></a>事件高级用法-过滤器</h2><p>有时我们会有这样的需求：获取当前所有姓名及年龄记录，或者是，要过滤出年龄28岁的记录，应该如何做呢？<br>以及另外一个常见的场景：想要获取到代币合约中所有的转账记录，也同样需要使用事件过滤器功能，这部分内容请大家订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>阅读。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://coursetro.com/posts/code/100/Solidity-Events-Tutorial---Using-Web3.js-to-Listen-for-Smart-Contract-Events" target="_blank" rel="noopener">https://coursetro.com/posts/code/100/Solidity-Events-Tutorial---Using-Web3.js-to-Listen-for-Smart-Contract-Events</a><br><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了300多位区块链技术牛人和爱好者。</p><!-- 有时我们会有这样的需求：获取当前所有姓名及年龄记录，应该如何做呢？实际上事件支持过滤器，可以从所有的区块中过滤出符合要求的事件，如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor(&#123;&#125;, &#123;<span class="attr">fromBlock</span>: <span class="number">0</span>, <span class="attr">toBlock</span>: <span class="string">'latest'</span>&#125;);</span><br></pre></td></tr></table></figure><p>或者是，要过滤出年龄28岁的记录，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instructorEvent = info.Instructor(&#123; <span class="string">'age'</span>: <span class="number">28</span>&#125;);</span><br></pre></td></tr></table></figure><p>比如，我们要获取到代币合约中，所有的转账记录， 就可以使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transferEvent = token.Transfer(&#123;&#125;, &#123;<span class="attr">fromBlock</span>: <span class="number">0</span>, <span class="attr">toBlock</span>: <span class="string">'latest'</span>&#125;)</span><br><span class="line"><span class="keyword">var</span> transferEvent.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// handle result.args.from  result.args.to</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> –&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多同学对Solidity 中的Event有疑问，这篇文章就来详细的看看Solidity 中Event到底有什么用？&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
      <category term="Event" scheme="https://learnblockchain.cn/tags/Event/"/>
    
      <category term="web3" scheme="https://learnblockchain.cn/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>智能合约最佳实践 之 Solidity 编码规范</title>
    <link href="https://learnblockchain.cn/2018/05/04/solidity-style-guide/"/>
    <id>https://learnblockchain.cn/2018/05/04/solidity-style-guide/</id>
    <published>2018-05-04T02:22:08.000Z</published>
    <updated>2018-05-07T06:42:11.127Z</updated>
    
    <content type="html"><![CDATA[<p>每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。</p><a id="more"></a><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="避免使用"><a href="#避免使用" class="headerlink" title="避免使用"></a>避免使用</h3><p>小写的l，大写的I，大写的O 应该避免在命名中单独出现，因为很容易产生混淆。</p><h3 id="合约、库、事件、枚举及结构体命名"><a href="#合约、库、事件、枚举及结构体命名" class="headerlink" title="合约、库、事件、枚举及结构体命名"></a>合约、库、事件、枚举及结构体命名</h3><p>  合约、库、事件及结构体命名应该使用单词首字母大写的方式，这个方式也称为：帕斯卡命名法或大驼峰式命名法，比如：SimpleToken， SmartBank， CertificateHashRepository，Player。</p><h3 id="函数、参数、变量及修饰器"><a href="#函数、参数、变量及修饰器" class="headerlink" title="函数、参数、变量及修饰器"></a>函数、参数、变量及修饰器</h3><p>函数、参数、变量及修饰器应该使用首单词小写后面单词大写的方式，这个方式也称为：（小）驼峰式命名法，是一种混合大小写的方式，如：</p><ul><li>函数名应该如：getBalance，transfer，verifyOwner，addMember。</li><li>参数和变量应该如：initialSupply，senderAddress，account，isPreSale。</li><li>修饰器应该如：onlyAfter，onlyOwner。</li></ul><h2 id="代码格式相关"><a href="#代码格式相关" class="headerlink" title="代码格式相关"></a>代码格式相关</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>使用空格（spaces）而不是Tab, 缩进应该是4个空格</p><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>合约之间应该有空行，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数之间应该有空行，例如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有实现的话，空行可以省去，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ham</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左括号应该跟定义在一行"><a href="#左括号应该跟定义在一行" class="headerlink" title="左括号应该跟定义在一行"></a>左括号应该跟定义在一行</h3><p>定义包括合约定义、函数定义、库定义、结构体定义等等，例如推荐使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> contract Coin &#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Coin</span><br><span class="line">&#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左括号应该跟条件控制在一行"><a href="#左括号应该跟条件控制在一行" class="headerlink" title="左括号应该跟条件控制在一行"></a>左括号应该跟条件控制在一行</h3><p>在使用if, else, while, for 时，推荐的写法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    ...;&#125;</span><br></pre></td></tr></table></figure><p>如果控制语句内只有一行，括号可省略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">    x += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但像下面一个语句有多方就不能省略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">    someArray.push(Coin(&#123;</span><br><span class="line">        name: <span class="string">'spam'</span>,</span><br><span class="line">        value: <span class="number">42</span></span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure><h3 id="表达式内的空格"><a href="#表达式内的空格" class="headerlink" title="表达式内的空格"></a>表达式内的空格</h3><ul><li><p>一个单行的表达里，在小括号、中括号、大括号里应该避免不必要的空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam(ham[<span class="number">1</span>], Coin(&#123;<span class="attr">name</span>: <span class="string">"ham"</span>&#125;));</span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam( ham[ <span class="number">1</span> ], Coin( &#123; <span class="attr">name</span>: <span class="string">"ham"</span> &#125; ) );</span><br></pre></td></tr></table></figure>有一种例外是，结尾的括号跟在结束的分号后面， 应该加一个空格，如下面的方式也是推荐的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleLine</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123; spam(); &#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>分号；前不应该有空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params">uint i, Coin coin</span>) <span class="title">public</span>;</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spam</span>(<span class="params">uint i , Coin coin</span>) <span class="title">public</span> ;</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p>不要为对齐添加不必要的空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line">long_variable = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><pre><code>而不是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x             = <span class="number">1</span>;</span><br><span class="line">y             = <span class="number">2</span>;</span><br><span class="line">long_variable = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>回退函数不应该有空格，例如推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而不是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="控制每一行长度"><a href="#控制每一行长度" class="headerlink" title="控制每一行长度"></a>控制每一行长度</h3><p>每行不应该太长，最好在79（或99）个字符以内，函数的参数应该是单独的行，且只有一个缩进，例如推荐的方式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">                              longArgument2,</span><br><span class="line">                              longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1, longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">longArgument1,</span><br><span class="line">longArgument2,</span><br><span class="line">longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3);</span><br></pre></td></tr></table></figure><p>对应的赋值语句应该是这样写：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> thisIsALongNestedMapping[being][set][to_some_value] = someFunction(</span><br><span class="line">    argument1,</span><br><span class="line">    argument2,</span><br><span class="line">    argument3,</span><br><span class="line">    argument4</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1,</span><br><span class="line">                                                                   argument2,</span><br><span class="line">                                                                   argument3,</span><br><span class="line">                                                                   argument4);</span><br></pre></td></tr></table></figure><p>事件定义也应该遵循同样的原则，例如应该使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(</span><br><span class="line">    adress sender,</span><br><span class="line">    adress recipient,</span><br><span class="line">    uint256 publicKey,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes32[] options</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(</span><br><span class="line">    sender,</span><br><span class="line">    recipient,</span><br><span class="line">    publicKey,</span><br><span class="line">    amount,</span><br><span class="line">    options</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(adress sender,</span><br><span class="line">                        adress recipient,</span><br><span class="line">                        uint256 publicKey,</span><br><span class="line">                        uint256 amount,</span><br><span class="line">                        bytes32[] options);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(sender,</span><br><span class="line">                  recipient,</span><br><span class="line">                  publicKey,</span><br><span class="line">                  amount,</span><br><span class="line">                  options);</span><br></pre></td></tr></table></figure><h3 id="文件编码格式"><a href="#文件编码格式" class="headerlink" title="文件编码格式"></a>文件编码格式</h3><p>推荐使用utf-8 及 ASCII 编码</p><h3 id="引入文件应该在最上方"><a href="#引入文件应该在最上方" class="headerlink" title="引入文件应该在最上方"></a>引入文件应该在最上方</h3><p>建议使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"owned"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"owned"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数编写规范"><a href="#函数编写规范" class="headerlink" title="函数编写规范"></a>函数编写规范</h2><h3 id="函数的顺序"><a href="#函数的顺序" class="headerlink" title="函数的顺序"></a>函数的顺序</h3><p>在编写函数的时候，应该让大家容易找到构造函数，回退函数，官方推荐的的函数顺序是：</p><ol><li>构造函数</li><li>回退函数 (如果有)</li><li>外部函数（external）</li><li>公有函数(public)</li><li>内部函数(internal)</li><li>私有函数（private）</li></ol><p>同一类函数时，constant函数放在后面， 例如推荐方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> contract A &#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回退函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带有constant 外部函数 </span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是下面的函数顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> contract A &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="明确函数的可见性"><a href="#明确函数的可见性" class="headerlink" title="明确函数的可见性"></a>明确函数的可见性</h3><p>所有的函数（包括构造函数）应该在定义的时候明确函数的可见性，例如应该使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">explicitlyPublic</span>(<span class="params">uint val</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">implicitlyPublic</span>(<span class="params">uint val</span>) </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可见性应该在修饰符前面"><a href="#可见性应该在修饰符前面" class="headerlink" title="可见性应该在修饰符前面"></a>可见性应该在修饰符前面</h3><p>函数的可见性应该写在自定义的函数修饰符前面，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyowner</span> </span>&#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) <span class="title">onlyowner</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区分函数和事件"><a href="#区分函数和事件" class="headerlink" title="区分函数和事件"></a>区分函数和事件</h3><p>为了防止函数和事件（Event）产生混淆，声明一个事件使用大写并加入前缀（可使用LOG）。对于函数， 始终以小写字母开头，构造函数除外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议</span></span><br><span class="line">event Transfer() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议</span></span><br><span class="line">event LogTransfer() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量应该使用全大写及下划线分割大词的方式，如：MAX_BLOCKS，TOKEN_NAME， CONTRACT_VERSION。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/v0.4.23/style-guide.html" target="_blank" rel="noopener">Solidity style-guide</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>美链BEC合约漏洞技术分析</title>
    <link href="https://learnblockchain.cn/2018/04/25/bec-overflow/"/>
    <id>https://learnblockchain.cn/2018/04/25/bec-overflow/</id>
    <published>2018-04-25T02:13:07.000Z</published>
    <updated>2018-04-26T01:49:16.484Z</updated>
    
    <content type="html"><![CDATA[<p>这两天币圈链圈被美链BEC智能合约的漏洞导致代币价值几乎归零的事件刷遍朋友圈。这篇文章就来分析下BEC智能合约的漏洞</p><a id="more"></a><h2 id="漏洞攻击交易"><a href="#漏洞攻击交易" class="headerlink" title="漏洞攻击交易"></a>漏洞攻击交易</h2><p>我们先来还原下攻击交易，这个交易可以在这个<a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f" target="_blank" rel="noopener">链接</a>查询到。<br>我截图给大家看一下：<br><img src="https://learnblockchain.cn/images/BEC_transfer.jpg" alt=""></p><p>攻击者向两个账号转移57896044618…000.792003956564819968个BEC，相当于BEC凭空进行了一个巨大的增发，几乎导致BEC价格瞬间归零。<br>下面我们来分析下这个攻击过程。</p><h2 id="合约漏洞分析"><a href="#合约漏洞分析" class="headerlink" title="合约漏洞分析"></a>合约漏洞分析</h2><p>我们先来看看<a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" target="_blank" rel="noopener">BEC智能合约的代码</a>，<br>BEC在合约中加入一个批量转账的函数，它的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchTransfer</span>(<span class="params">address[] _receivers, uint256 _value</span>) <span class="title">public</span> <span class="title">whenNotPaused</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    uint cnt = _receivers.length;</span><br><span class="line">    uint256 amount = uint256(cnt) * _value;</span><br><span class="line">    <span class="built_in">require</span>(cnt &gt; <span class="number">0</span> &amp;&amp; cnt &lt;= <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">require</span>(_value &gt; <span class="number">0</span> &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(amount);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        balances[_receivers[i]] = balances[_receivers[i]].add(_value);</span><br><span class="line">        Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是，调用者传入若干个地址和转账金额，在经过一些条件检查之后，对msg.sender的余额进行减操作，对每一个对每一个传入的地址进行加操作，以实现BEC的转移。<br>问题出在 <code>uint256 amount = uint256(cnt) * _value;</code> 这句代码，当传入值<code>_value</code>过大时（接近uint256的取值范围的最大值），<code>uint256 amount = uint256(cnt) * _value</code>计算时会发生溢出，导致amount实际的值是一个非常小的数（此时amount不再是<code>cnt * _value</code>的实际值），amount很小，也使得后面对调用者余额校验可正常通过（即<code>require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount)</code>语句通过）。</p><p>我们来结合实际攻击交易使用的参数来分析一下：</p><p><img src="https://learnblockchain.cn/images/BEC_transfer_params.jpg" alt=""></p><p><code>batchTransfer</code>的参数<code>_value</code>值为16进制的<code>800000000000000000000...</code>，参数<code>_receivers</code>数组的大小为2，相乘之后刚好可超过uint256所能表示的整数大小上限，引发溢出问题<code>amount</code>实际的值为0，后面的转账操作实际上msg.sender的余额减0， 而对两个账号进行了加16进制的<code>800000000000000000000...</code>，最终的结果是相当于增发了2 * 16进制的<code>800000000000000000000...</code>。</p><p>实际上对于这种整数溢出漏洞，最简单的方法是采用 SafeMath 数学计算库来避免。有趣的是BEC智能合约代码中，其实其他的都使用了SafeMath， 而关键的<code>uint256 amount = uint256(cnt) * _value</code>却没有使用。<br>心痛程序员，也心痛韭菜。这句代码改为<code>uint256 amount = _value.mul(uint256(cnt));</code>就可以防止溢出问题</p><p>所以在做加减乘除的时候请记得一定使用：SafeMath，代码在<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" target="_blank" rel="noopener">这里</a></p><h2 id="溢出补充说明"><a href="#溢出补充说明" class="headerlink" title="溢出补充说明"></a>溢出补充说明</h2><p>溢出补充说明为小专栏订阅用户福利，小专栏的文章内介绍了什么时候会发生上溢，什么时候会发生下溢，并且给出了代码事例。<br>大家可请前往我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>阅读。</p><p>知识星球<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a></strong>做好的区块链技术问答社区，欢迎来提问，作为星球成员福利，成员可加入区块链技术付费交流群。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><!--Solidity最大可以处理256位数字, 最大值为 `2**256 - 1`, 对(`2**256 - 1`) 加1的结果会溢出归0。`2**255` 乘2也同样会溢出归0。对无符号类型最小值是零，对零做减1会得到 (`2**256 - 1`)。我们用一段代码验证一下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity <span class="number">0.4</span><span class="number">.20</span>;</span><br><span class="line">contract TestFlow &#123;</span><br><span class="line">    uint256 public zero = <span class="number">0</span>;</span><br><span class="line">    uint256 public max = <span class="number">2</span>**<span class="number">256</span> - <span class="number">1</span>;</span><br><span class="line">    uint256 public mm = <span class="number">2</span>**<span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subUnderFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  zero - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addOverFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  max + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mulOverFlow</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        uint256 a =  mm * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约部署和运行，之前已经经过很多次，我直接贴运行结果：<br><img src="https://learnblockchain.cn/images/BEC_transfer_flow.jpg" alt=""></p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天币圈链圈被美链BEC智能合约的漏洞导致代币价值几乎归零的事件刷遍朋友圈。这篇文章就来分析下BEC智能合约的漏洞&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Web3与智能合约交互实战</title>
    <link href="https://learnblockchain.cn/2018/04/15/web3-html/"/>
    <id>https://learnblockchain.cn/2018/04/15/web3-html/</id>
    <published>2018-04-15T13:24:16.000Z</published>
    <updated>2018-08-09T03:17:04.701Z</updated>
    
    <content type="html"><![CDATA[<p>Web3与智能合约交互实战</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在最初学习以太坊的时候，很多人都是自己创建以太坊节点后，使用geth与之交互。这种使用命令行交互的方法虽然让很多程序员感到兴奋（黑客帝国的既视感？），但不可能指望普通用户通过命令行使用Dapp。因此，我们需要一种友好的方式（比如一个web页面）来与智能合约交互，于是问题的答案就是<code>web3.js</code>。</p><h2 id="Web3-js"><a href="#Web3-js" class="headerlink" title="Web3.js"></a>Web3.js</h2><p><a href="https://web3js.readthedocs.io/en/1.0/" target="_blank" rel="noopener">Web3.js</a>是以太坊官方的Javascript API，可以帮助智能合约开发者使用HTTP或者IPC与本地的或者远程的以太坊节点交互。实际上就是一个库的集合，主要包括下面几个库：</p><ul><li><code>web3-eth</code>用来与以太坊区块链和智能合约交互</li><li><code>web3-shh</code>用来控制whisper协议与p2p通信以及广播</li><li><code>web3-bzz</code>用来与swarm协议交互</li><li><code>web3-utils</code>包含了一些Dapp开发有用的功能</li></ul><p>Web3与geth通信使用的是 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON-RPC</a> ，这是一种轻量级的RPC（Remote Procedure Call）协议，整个通信的模型可以抽象为下图。</p><p><img src="/images/Communication_Model.jpg" alt="Web3 Communication Model"></p><h2 id="搭建测试链"><a href="#搭建测试链" class="headerlink" title="搭建测试链"></a>搭建测试链</h2><p>在开发初期，我们并没有必要使用真实的公链，为了开发效率，一般选择在本地搭建测试链。在本文我们选择的<a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a>（在此之前使用的是testrpc，Ganache属于它的升级版），一个图形化测试软件（也有命令行版本），可以一键在本地搭建以太坊区块链测试环境，并且将区块链的状态通过图形界面显示出来，Ganache的运行界面如下图所示。</p><p><img src="/images/Ganache.png" alt="Ganache"></p><p>从图中可以看到Ganache会默认创建10个账户，监听地址是<code>http://127.0.0.1:7545</code>，可以实时看到<code>Current Block</code>、<code>Gas Price</code>、<code>Gas Limit</code>等信息。</p><h2 id="创建智能合约"><a href="#创建智能合约" class="headerlink" title="创建智能合约"></a>创建智能合约</h2><p>目前以太坊官方全力支持的智能合约开发环境是<a href="https://remix.ethereum.org" target="_blank" rel="noopener">Remix IDE</a>，我们在合约编辑页面编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract InfoContract &#123;</span><br><span class="line">    </span><br><span class="line">   string fName;</span><br><span class="line">   uint age;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">       fName = _fName;</span><br><span class="line">       age = _age;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">string, uint</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (fName, age);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，就是简单的给<code>name</code>和<code>age</code>变量赋值与读取，接下来切换到 run 的 tab 下，将<code>Environment</code>切换成<code>Web3 Provider</code>，并输入我们的测试链的地址<code>http://127.0.0.1:7545</code>，这里对这三个选项做一简单说明：</p><ul><li><code>Javascript VM</code>：简单的Javascript虚拟机环境，纯粹练习智能合约编写的时候可以选择</li><li><code>Injected Web3</code>：连接到嵌入到页面的Web3，比如连接到MetaMask</li><li><code>Web3 Provider</code>：连接到自定义的节点，如私有的测试网络。</li></ul><p>如果连接成功，那么在下面的<code>Account</code>的选项会默认选择 Ganache 创建的第一个账户地址。接下来我们点击<code>Create</code>就会将我们的智能合约部署到我们的测试网中。接下来 Remix 的页面不要关闭，在后面编写前端代码时还要用到合约的地址以及<code>ABI</code>信息。</p><h2 id="安装Web3"><a href="#安装Web3" class="headerlink" title="安装Web3"></a>安装Web3</h2><p>在这之前，先在终端创建我们的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir info</span><br><span class="line">&gt; <span class="built_in">cd</span> info</span><br></pre></td></tr></table></figure><p>接下来使用 node.js 的包管理工具 npm 初始化项目，创建<code>package.json</code> 文件，其中保存了项目需要的相关依赖环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm init</span><br></pre></td></tr></table></figure><p>一路按回车直到项目创建完成。最后，运行下面命令安装web.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm install web3</span><br></pre></td></tr></table></figure><blockquote><p>   <em>注意：</em> 在实际安装过程中我发现web3在安装完成后并没有 <code>/node_modules/web3/dist/we3.min.js</code> 文件，这个问题在 <a href="https://github.com/ethereum/web3.js/issues/1041" target="_blank" rel="noopener">issue#1041</a>中有体现，但官方好像一直没解决。不过可以在这里<a href="https://codeload.github.com/ethereum/web3.js/zip/develop" target="_blank" rel="noopener">下载</a>所需的文件，解压后将<code>dist</code>文件夹的内容拷贝到 <code>/node_modules/web3</code>路径下。</p></blockquote><h2 id="创建-UI"><a href="#创建-UI" class="headerlink" title="创建 UI"></a>创建 UI</h2><p>在项目目录下创建<code>index.html</code>，在这里我们将创建基础的 UI，功能包括<code>name</code>和<code>age</code>的输入框，以及一个按钮，这些将通过 jQuery 实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"main.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/web3/dist/web3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Info Contract<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"info"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span> <span class="attr">class</span>=<span class="string">"col-lg-2 control-label"</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span> <span class="attr">class</span>=<span class="string">"col-lg-2 control-label"</span>&gt;</span>Age<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>Update Info<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.slim.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">       <span class="comment">// Our future code here..</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来需要编写<code>main.css</code>文件设定基本的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#F0F0F0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Raleway'</span>,<span class="string">'Source Sans Pro'</span>, <span class="string">'Arial'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2em</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#info</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##使用Web3与智能合约交互<br>UI 创建好之后，在<code>&lt;script&gt;</code>标签中间编写<code>web.js</code>的代码与智能合约交互。首先创建<code>web3</code>实例，并与我们的测试环境连接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">        web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">"http://localhost:7545"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码是<a href="https://github.com/ethereum/web3.js/" target="_blank" rel="noopener">web3.js Github</a>提供的样例，意思是如果<code>web3</code>已经被定义，那么就可以直接当作我们的 provider 使用。如果没有定义，则我们手动指定 provider。</p><blockquote><p>这里可能会存在疑问：为什么 web3 会被事先定义呢？实际上，如果你使用类似 <a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>（一个 Chrome 上的插件，迷你型以太坊钱包）这样的软件，provider 就会被自动植入。</p></blockquote><p>在上面代码的基础上，接下来设置默认的以太坊账户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>在上文中我们使用 Ganache 已经创建了 10 个账户了，这里我们选择第一个账户当作默认账户。</p><p>接下来需要让我们的<code>web3</code>知道我们的合约是什么样的，这里需要用到合约的 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">ABI（Application Binary Interface）</a>。<code>ABI</code>可以使我们调用合约的函数，并且从合约中获取数据。</p><p>在上文中我们已经在 Remix 中创建了我们的合约，这时重新回到 Remix，在 Compile 的 tab 下我们点击<code>Details</code> 出现的页面中我们可以拷贝合约的<code>ABI</code>，如下图所示。<br><img src="/images/ABI.png" alt=""><br>将其复制到代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> infoContract = web3.eth.contract(PASTE ABI HERE!);</span><br></pre></td></tr></table></figure><p>接下来转到 run 的tab，拷贝合约的地址，将其复制到下面的代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info = InfoContract.at(<span class="string">'PASTE CONTRACT ADDRESS HERE'</span>);</span><br></pre></td></tr></table></figure><p>完成这些我们就可以调用合约中的函数了，下面我们使用 jQuery 与我们的合约进行交互：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">info.getInfo(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)</span><br><span class="line">        &#123;</span><br><span class="line">            $(<span class="string">"#info"</span>).html(result[<span class="number">0</span>]+<span class="string">' ('</span>+result[<span class="number">1</span>]+<span class="string">' years old)'</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(result);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    info.setInfo($(<span class="string">"#name"</span>).val(), $(<span class="string">"#age"</span>).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上的代码就简单地实现了对合约中两个函数的调用，分别读取和显示<code>name</code>和<code>age</code>变量。</p><p>到此我们就完成了全部的代码，完整代码可以在 <a href="https://github.com/xilibi2003/InfoContract" target="_blank" rel="noopener">InfoContract</a> 中找到。在浏览器中打开<code>index.html</code>测试效果如下图（输入名字和年龄后刷新）。</p><p><img src="/images/page.png" alt=""></p><p>本文中点击”Updata Info”按钮之后，虽然调用智能合约成功，但是当前的界面并没有得到更新，下一篇文章会介绍<a href="https://learnblockchain.cn/2018/05/09/solidity-event/">Web3监听合约事件更新界面</a>。</p><p>本文的作者是盖盖，他的微信公众号: chainlab</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://coursetro.com/posts/code/99/Interacting-with-a-Smart-Contract-through-Web3.js-(Tutorial" target="_blank" rel="noopener">Interacting with a Smart Contract through Web3.js (Tutorial)</a>)</li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了300多位区块链技术牛人和爱好者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web3与智能合约交互实战&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Web3" scheme="https://learnblockchain.cn/tags/Web3/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列10 - 完全理解函数修改器</title>
    <link href="https://learnblockchain.cn/2018/04/09/solidity-modify/"/>
    <id>https://learnblockchain.cn/2018/04/09/solidity-modify/</id>
    <published>2018-04-09T12:35:47.000Z</published>
    <updated>2018-05-17T15:10:40.883Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第10篇，带大家完全理解Solidity的函数修改器。<br>Solidity系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="函数修改器-Function-Modifiers"><a href="#函数修改器-Function-Modifiers" class="headerlink" title="函数修改器(Function Modifiers)"></a>函数修改器(Function Modifiers)</h2><p>函数修改器(Modifiers)可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。</p><blockquote><p>如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。</p></blockquote><p>修改器是一种可被继承合约属性，同时还可被继承的合约重写(override)。下面我们来看一段示例代码： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">owned</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义了一个函数修改器，可被继承</span></span><br><span class="line">    <span class="comment">//  修饰时，函数体被插入到 “_;” 处</span></span><br><span class="line">    <span class="comment">// 不符合条件时，将抛出异常</span></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    <span class="comment">//  使用继承的`onlyOwner` </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    <span class="comment">// 函数修改器可接收参数</span></span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Register</span>(<span class="params">uint initialPrice</span>) <span class="title">public</span> </span>&#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要提供payable 以接受以太</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">costs</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">        registeredAddresses[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changePrice</span>(<span class="params">uint _price</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面onlyOwner就是定义的一个函数修改器，当用这个修改器区修饰一个函数时，则函数必须满足onlyOwner的条件才能运行，这里的条件是：必须是合约的创建这才能调用函数，否则抛出异常。<br>我们在<a href="https://learnblockchain.cn/2018/01/27/create-token2/">实现一个可管理、增发、兑换、冻结等高级功能的代币</a>文章中就使用了这个函数修改器。</p><h3 id="多个修改器"><a href="#多个修改器" class="headerlink" title="多个修改器"></a>多个修改器</h3><p>如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。</p><p>在修改器中或函数内的显式的return语句，仅仅跳出当前的修改器或函数。返回的变量会被赋值，但执行流会在前一个修改器后面定义的”_”后继续执行， 如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        <span class="built_in">require</span>(!locked);</span><br><span class="line">        locked = <span class="literal">true</span>;</span><br><span class="line">        _;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止递归调用</span></span><br><span class="line">    <span class="comment">// return 7 之后，locked = false 依然会执行</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">noReentrancy</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender.call());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改器的参数可以是任意表达式。在此上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。</p><h3 id="深入理解修改器的执行次序"><a href="#深入理解修改器的执行次序" class="headerlink" title="深入理解修改器的执行次序"></a>深入理解修改器的执行次序</h3><p>再来看一个复杂一点的例子，来深入理解修改器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract modifysample &#123;</span><br><span class="line"></span><br><span class="line">    uint a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    modifier mf1 (uint b) &#123;</span><br><span class="line">        uint c = b;</span><br><span class="line">        _;</span><br><span class="line">        c = a;</span><br><span class="line">        a = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     modifier mf2 () &#123;</span><br><span class="line">        uint c = a;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier mf3() &#123;</span><br><span class="line">        a = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        _;</span><br><span class="line">        a = <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) <span class="title">mf1</span>(<span class="params">a</span>) <span class="title">mf2</span> <span class="title">mf3</span> <span class="title">public</span>   </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>)   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的智能合约运行test1()之后，状态变量a的值是多少， 是1， 11， 12，还是13呢？<br>答案是 11, 大家可以运行下test2获取下a值。</p><p>我们来分析一下 test1， 它扩展之后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint c = b;</span><br><span class="line">        uint c = a;</span><br><span class="line">            a = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            _;</span><br><span class="line">            a = <span class="number">13</span>;</span><br><span class="line">c = a;</span><br><span class="line">a = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>这个时候就一目了然了，最后a 为11， 注意第5及第6行是不是执行的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers" target="_blank" rel="noopener">官方文档-Function Modifiers</a></p><p>如果你想和认识我，和我建立联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术爱好者。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第10篇，带大家完全理解Solidity的函数修改器。&lt;br&gt;Solidity系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列9 - 错误处理</title>
    <link href="https://learnblockchain.cn/2018/04/07/solidity-errorhandler/"/>
    <id>https://learnblockchain.cn/2018/04/07/solidity-errorhandler/</id>
    <published>2018-04-07T12:35:47.000Z</published>
    <updated>2018-04-07T14:37:06.216Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第9篇介绍Solidity 错误处理。<br>Solidity系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="什么是错误处理"><a href="#什么是错误处理" class="headerlink" title="什么是错误处理"></a>什么是错误处理</h2><p>错误处理是指在程序发生错误时的处理方式，Solidity处理错误和我们常见的语言不一样，Solidity是通过回退状态的方式来处理错误。发生异常时会撤消当前调用（及其所有子调用）所改变的状态，同时给调用者返回一个错误标识。注意<strong>捕捉异常是不可能的</strong>，因此没有try … catch…。</p><p>为什么Solidity处理错误要这样设计呢？<br>我们可以把区块链理解为是全球共享的分布式事务性数据库。<strong>全球共享</strong>意味着参与这个网络的每一个人都可以读写其中的记录。如果想修改这个数据库中的内容，就必须创建一个事务，<strong>事务</strong>意味着要做的修改（假如我们想同时修改两个值）只能被完全的应用或者一点都没有进行。<br>学习过数据库的同学，应该理解事务的含义，如果你对事务一词不是很理解，建议你搜索一下“数据库事务“。<br>Solidity错误处理就是要保证每次调用都是事务性的。</p><h2 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h2><p>Solidity提供了两个函数assert和require来进行条件检查，如果条件不满足则抛出异常。assert函数通常用来检查（测试）内部错误，而require函数来检查输入变量或合同状态变量是否满足条件以及验证调用外部合约返回值。<br>另外，如果我们正确使用assert，有一个Solidity分析工具就可以帮我们分析出智能合约中的错误，帮助我们发现合约中有逻辑错误的bug。</p><p>除了可以两个函数assert和require来进行条件检查，另外还有两种方式来触发异常：</p><ol><li><strong>revert</strong>函数可以用来标记错误并回退当前调用</li><li>使用<strong>throw</strong>关键字抛出异常（从0.4.13版本，throw关键字已被弃用，将来会被淘汰。）</li></ol><p>当子调用中发生异常时，异常会自动向上“冒泡”。 不过也有一些例外：send，和底层的函数调用call, delegatecall，callcode，当发生异常时，这些函数返回false。</p><p>注意：在一个不存在的地址上调用底层的函数call，delegatecall，callcode 也会返回成功，所以我们在进行调用时，应该总是优先进行函数存在性检查。</p><p>在下面通过一个示例来说明如何使用require来检查输入条件，以及assert用于内部错误检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendHalf</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 仅允许偶数</span></span><br><span class="line">        uint balanceBeforeTransfer = <span class="keyword">this</span>.balance;</span><br><span class="line">        addr.transfer(msg.value / <span class="number">2</span>);  <span class="comment">// 如果失败，会抛出异常，下面的代码就不是执行</span></span><br><span class="line">        assert(<span class="keyword">this</span>.balance == balanceBeforeTransfer - msg.value / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际运行下，看看异常是如何发生的：</p><ol><li><p>首先打开<a href="https://remix.ethereum.org" target="_blank" rel="noopener">Remix</a>，贴入代码，点击创建合约。如下图：<br><img src="/images/solidity_error1.jpg" alt=""></p></li><li><p>运行测试1：附加1wei (奇数)去调用sendHalf，这时会发生异常，如下图:</p></li></ol><p><img src="/images/solidity_error2.jpg" alt=""></p><ol><li>运行测试2：附加2wei 去调用sendHalf，运行正常。</li><li>运行测试3：附加2wei以及sendHalf参数为当前合约本身，在转账是发生异常，因为合约无法接收转账，错误提示上图类似。</li></ol><h2 id="assert类型异常"><a href="#assert类型异常" class="headerlink" title="assert类型异常"></a>assert类型异常</h2><p>在下述场景中自动产生assert类型的异常:</p><ol><li>如果越界，或负的序号值访问数组，如i &gt;= x.length 或 i &lt; 0时访问x[i]</li><li>如果序号越界，或负的序号值时访问一个定长的bytesN。</li><li>被除数为0， 如5/0 或 23 % 0。</li><li>对一个二进制移动一个负的值。如:5&lt;&lt;i; i为-1时。</li><li>整数进行可以显式转换为枚举时，如果将过大值，负值转为枚举类型则抛出异常</li><li>如果调用未初始化内部<a href="https://learnblockchain.cn/2017/12/12/solidity_func/">函数类型</a>的变量。</li><li>如果调用<strong>assert</strong>的参数为false</li></ol><h2 id="require类型异常"><a href="#require类型异常" class="headerlink" title="require类型异常"></a>require类型异常</h2><p>在下述场景中自动产生require类型的异常:</p><ol><li>调用<strong>throw</strong></li><li>如果调用<strong>require</strong>的参数为false</li><li>如果你通过消息调用一个函数，但在调用的过程中，并没有正确结束(gas不足，没有匹配到对应的函数，或被调用的函数出现异常)。底层操作如call,send,delegatecall或callcode除外，它们不会抛出异常，但它们会通过返回false来表示失败。</li><li>如果在使用new创建一个新合约时出现第3条的原因没有正常完成。</li><li>如果调用外部函数调用时，被调用的对象不包含代码。</li><li>如果合约没有payable修饰符的public的函数在接收以太币时（包括构造函数，和回退函数）。</li><li>如果合约通过一个public的getter函数（public getter funciton）接收以太币。</li><li>如果<strong>.transfer()</strong>执行失败</li></ol><p>当发生require类型的异常时，Solidity会执行一个回退操作（指令0xfd）。<br>当发生assert类型的异常时，Solidity会执行一个无效操作（指令0xfe）。<br>在上述的两种情况下，EVM都会撤回所有的状态改变。是因为期望的结果没有发生，就没法继续安全执行。必须保证交易的原子性（一致性，要么全部执行，要么一点改变都没有，不能只改变一部分），所以需要撤销所有操作，让整个交易没有任何影响。</p><p>注意assert类型的异常会消耗掉所有的gas, 而require从大都会版本（Metropolis， 即目前主网所在的版本）起不会消耗gas。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#error-handling-assert-require-revert-and-exceptions" target="_blank" rel="noopener">Solidity 错误处理</a></li></ul><p>欢迎来我的知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener"><strong>深入浅出区块链</strong></a>讨论区块链技术，同时我也会为大家提供区块链技术解答，作为星友福利，星友可加入区块链技术付费交流群。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第9篇介绍Solidity 错误处理。&lt;br&gt;Solidity系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>剖析非同质化代币ERC721-全面解析ERC721标准</title>
    <link href="https://learnblockchain.cn/2018/03/23/token-erc721/"/>
    <id>https://learnblockchain.cn/2018/03/23/token-erc721/</id>
    <published>2018-03-23T13:54:50.000Z</published>
    <updated>2018-03-26T01:58:47.076Z</updated>
    
    <content type="html"><![CDATA[<p>什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721.</p><a id="more"></a><h2 id="ERC721是什么"><a href="#ERC721是什么" class="headerlink" title="ERC721是什么"></a>ERC721是什么</h2><p>在<a href="https://learnblockchain.cn/2018/01/12/create_token/">创建代币</a>一篇，我们讲到过ERC20代币，<br>和ERC20一样，ERC721同样是一个代币标准，ERC721官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 </p><blockquote><p>ERC721 是由Dieter Shirley 在2017年9月提出。Dieter Shirley 正是谜恋猫CryptoKitties背后的公司Axiom Zen的技术总监。因此谜恋猫也是第一个实现了ERC721 标准的去中心化应用。ERC721号提议已经被以太坊作为标准接受，但该标准仍处于草稿阶段。本文介绍的ERC721标准基于最新(2018/03/23官方提议。</p></blockquote><p>那怎么理解<strong>非同质</strong>代币呢?</p><p>非同质代表独一无二，谜恋猫为例，每只猫都被赋予拥有基因，是独一无二的（一只猫就是一个NFTs），猫之间是不能置换的。这种独特性使得某些稀有猫具有收藏价值，也因此受到追捧。</p><p>ERC20代币是可置换的，且可细分为N份（1 = 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。</p><blockquote><p>如果同一个集合的两个物品具有不同的特征，这两个物品是非同质的，而同质是某个部分或数量可以被另一个同等部分或数量所代替。</p></blockquote><p>非同质性其实广泛存在于我们的生活中，如图书馆的每一本，宠物商店的每一只宠物，歌手所演唱的歌曲，花店里不同的花等等，因此ERC721合约必定有广泛的应用场景。通过这样一个标准，也可建立跨功能的NFTs管理和销售平台（就像有支持ERC20的交易所和钱包一样），使生态更加强大。</p><h2 id="ERC721标准"><a href="#ERC721标准" class="headerlink" title="ERC721标准"></a>ERC721标准</h2><p>ERC721最为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line">interface ERC721 <span class="comment">/* is ERC165 */</span> &#123;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">ownerOf</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">safeTransferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId, bytes data</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">safeTransferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address _approved, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">setApprovalForAll</span>(<span class="params">address _operator, bool _approved</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">getApproved</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">isApprovedForAll</span>(<span class="params">address _owner, address _operator</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>接口说明：</strong></p><ul><li>balanceOf(): 返回由_owner 持有的NFTs的数量。</li><li>ownerOf(): 返回tokenId代币持有者的地址。</li><li>approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。</li><li>setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。</li><li><p>getApproved()、isApprovedForAll(): 用来查询授权。</p></li><li><p>safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查：</p></li></ul><ol><li>调用者msg.sender应该是当前tokenId的所有者或被授权的地址</li><li>_from 必须是 _tokenId的所有者</li><li>_tokenId 应该是当前合约正在监测的NFTs 中的任何一个</li><li>_to 地址不应该为 0</li><li>如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为<code>bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))</code>抛出异常。<br>一个可接收NFT的合约必须实现ERC721TokenReceiver接口：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721TokenReceiver &#123;</span><br><span class="line">    <span class="comment">/// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onERC721Received</span>(<span class="params">address _from, uint256 _tokenId, bytes data</span>) <span class="title">external</span> <span class="title">returns</span>(<span class="params">bytes4</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。</li></ul><h2 id="ERC165-标准"><a href="#ERC165-标准" class="headerlink" title="ERC165 标准"></a>ERC165 标准</h2><p>ERC721标准同时要求必须符合ERC165标准 ，其接口如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ERC165 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceID</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">ERC165</a>同样是一个合约标准，这个标准要求合约提供其实现了哪些接口，这样再与合约进行交互的时候可以先调用此接口进行查询。<br>interfaceID为函数选择器，计算方式有两种，如：<code>bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));</code>或<code>ERC165.supportsInterface.selector</code>，多个函数的接口ID为函数选择器的异或值。<br>关于ERC165，这里不深入介绍，有兴趣的同学可以阅读<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">官方提案</a>。</p><h2 id="可选实现接口：ERC721Metadata"><a href="#可选实现接口：ERC721Metadata" class="headerlink" title="可选实现接口：ERC721Metadata"></a>可选实现接口：ERC721Metadata</h2><p>ERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT所对应的资源）。<br>其接口定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721Metadata <span class="comment">/* is ERC721 */</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">string _name</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">symbol</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">string _symbol</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenURI</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>接口说明：</strong></p><ul><li>name(): 返回合约名字，尽管是可选，但强烈建议实现，即便是返回空字符串。</li><li>symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。</li><li>tokenURI(): 返回_tokenId所对应的外部资源文件的URI（通常是IPFS或HTTP(S)路径）。外部资源文件需要包含名字、描述、图片，其格式的要求如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Asset Metadata"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"Identifies the asset to which this NFT represents"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"description"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"Describes the asset to which this NFT represents"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"image"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>tokenURI通常是被web3调用，以便在应用层做相应的查询和展示。</p><h2 id="可选实现接口：ERC721Enumerable"><a href="#可选实现接口：ERC721Enumerable" class="headerlink" title="可选实现接口：ERC721Enumerable"></a>可选实现接口：ERC721Enumerable</h2><p>ERC721Enumerable的主要目的是提高合约中NTF的可访问性，其接口定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721Enumerable <span class="comment">/* is ERC721 */</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenByIndex</span>(<span class="params">uint256 _index</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenOfOwnerByIndex</span>(<span class="params">address _owner, uint256 _index</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>接口说明：</strong></p><ul><li>totalSupply(): 返回NFT总量</li><li>tokenByIndex(): 通过索引返回对应的tokenId。</li><li>tokenOfOwnerByIndex(): 所有者可以一次拥有多个的NFT, 此函数返回_owner拥有的NFT列表中对应索引的tokenId。</li></ul><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="NTF-IDs"><a href="#NTF-IDs" class="headerlink" title="NTF IDs"></a>NTF IDs</h3><p>NTF ID，即tokenId，在合约中用唯一的uint265进行标识，每个NFT的ID在智能合约的生命周期内不允许改变。推荐的实现方式有：</p><ol><li>从0开始，每新加一个NFT，NTF ID加1</li><li>使用sha3后uuid 转换为 NTF ID</li></ol><h3 id="与ERC-20的兼容性"><a href="#与ERC-20的兼容性" class="headerlink" title="与ERC-20的兼容性"></a>与ERC-20的兼容性</h3><p>ERC721标准尽可能遵循 ERC-20 的语义，但由于同质代币与非同质代币之间的根本差异，并不能完全兼容ERC-20。</p><h3 id="交易、挖矿、销毁"><a href="#交易、挖矿、销毁" class="headerlink" title="交易、挖矿、销毁"></a>交易、挖矿、销毁</h3><p>在实现transter相关接口时除了满足上面的的条件外，我们可以根据需要添加自己的逻辑，如加入黑名单等。<br>同时挖矿、销毁尽管不是标准的一部分，我们可以根据需要实现。</p><h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><p>参考实现为订阅用户专有福利，请订阅我的小专栏：<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。<br><!-- 1. [CryptoKitties Deployed Contract.](https://ethfiddle.com/09YbyJRfiI) 2. [XXXXERC721](https://github.com/fulldecent/erc721-example)3. [ERC721ExampleDeed](https://github.com/nastassiasachs/ERC721ExampleDeed) --></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">EIPS-165</a></li><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md" target="_blank" rel="noopener">EIPS-721</a></li></ol><p>欢迎来我的知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener"><strong>深入浅出区块链</strong></a>讨论区块链，作为星友福利，星友可加入区块链技术付费交流群。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721.&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
      <category term="ERC721" scheme="https://learnblockchain.cn/tags/ERC721/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建以太坊私有链</title>
    <link href="https://learnblockchain.cn/2018/03/18/create_private_blockchain/"/>
    <id>https://learnblockchain.cn/2018/03/18/create_private_blockchain/</id>
    <published>2018-03-18T12:05:59.000Z</published>
    <updated>2018-03-19T02:13:22.401Z</updated>
    
    <content type="html"><![CDATA[<p>在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊语言有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="go-ethereum客户端安装"><a href="#go-ethereum客户端安装" class="headerlink" title="go-ethereum客户端安装"></a>go-ethereum客户端安装</h2><p>Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择geth工具来进行开发。由于本人是mac，所以优先使用mac进行开发啦。mac中geth安装如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap ethereum/ethereum</span><br><span class="line">brew install ethereum</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --help</span><br></pre></td></tr></table></figure><p>如果输出一些帮助提示命令，则说明安装成功。<br>其他平台可参考<a href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum" target="_blank" rel="noopener">Geth 安装</a></p><h2 id="搭建私有链"><a href="#搭建私有链" class="headerlink" title="搭建私有链"></a>搭建私有链</h2><p>以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。首先将下面的内容保存到一个json文件中，例如genesis.json。<br>json文件内容如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">        <span class="attr">"chainId"</span>: <span class="number">10</span>, </span><br><span class="line">        <span class="attr">"homesteadBlock"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"eip155Block"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"eip158Block"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="attr">"alloc"</span>      : &#123;&#125;,</span><br><span class="line">  <span class="attr">"coinbase"</span>   : <span class="string">"0x0000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"difficulty"</span> : <span class="string">"0x20000"</span>,</span><br><span class="line">  <span class="attr">"extraData"</span>  : <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"gasLimit"</span>   : <span class="string">"0x2fefd8"</span>,</span><br><span class="line">  <span class="attr">"nonce"</span>      : <span class="string">"0x0000000000000042"</span>,</span><br><span class="line">  <span class="attr">"mixhash"</span>    : <span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"parentHash"</span> : <span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"timestamp"</span>  : <span class="string">"0x00"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化：写入创世区块"><a href="#初始化：写入创世区块" class="headerlink" title="初始化：写入创世区块"></a>初始化：写入创世区块</h2><p>准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示：</p><p><img src="/images/create_private_blockchain_1.png" alt=""></p><p>接下来进入privatechain目录中，执行初始化命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd privatechain</span><br><span class="line">geth --datadir data0 init genesis.json</span><br></pre></td></tr></table></figure><p>上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。</p><p>运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有<code>Successfully wrote genesis state</code>字样，说明初始化成功。</p><p>初始化成功后的目录如下：<br><img src="/images/create_private_blockchain_2.png" alt=""><br>其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。</p><h2 id="启动私有链节点"><a href="#启动私有链节点" class="headerlink" title="启动私有链节点"></a>启动私有链节点</h2><p>初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir data0 --networkid 1108 console</span><br></pre></td></tr></table></figure><p>上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id(上面命令可能会运行失败，我直接重启mac，再进入到privateChain目录中，简单粗暴)。</p><p>运行上面的命令后，就启动了区块链节点并进入了Javascript Console：<br><img src="/images/create_private_blockchain_3.png" alt=""><br>这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括：</p><p><strong>eth：</strong>包含一些跟操作区块链相关的方法<br><strong>net：</strong>包含以下查看p2p网络状态的方法<br><strong>admin：</strong>包含一些与管理节点相关的方法<br><strong>miner：</strong>包含启动&amp;停止挖矿的一些方法<br><strong>personal：</strong>主要包含一些管理账户的方法<br><strong>txpool：</strong>包含一些查看交易内存池的方法<br><strong>web3：</strong>包含了以上对象，还包含一些单位换算的方法</p><h2 id="玩转Javascript-Console"><a href="#玩转Javascript-Console" class="headerlink" title="玩转Javascript Console"></a>玩转Javascript Console</h2><p>进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。</p><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>此时没有账户，接下来使用personal对象来创建一个账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">&gt; Passphrase:</span><br><span class="line">&gt; Repeat passphrase:</span><br><span class="line">&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><br></pre></td></tr></table></figure><p>Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">&gt; Passphrase:</span><br><span class="line">&gt; Repeat passphrase:</span><br><span class="line">&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;</span><br></pre></td></tr></table></figure><p>这时候再去看账户，就有两个了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;]</span><br></pre></td></tr></table></figure><p>账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。</p><p><img src="/images/create_private_blockchain_4.png" alt=""><br>json文件中信息格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;address&quot;: &quot;4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  &quot;crypto&quot;: &#123;</span><br><span class="line">    &quot;cipher&quot;: &quot;aes-128-ctr&quot;,</span><br><span class="line">    &quot;ciphertext&quot;: &quot;238d6d48126b762c8f13e84622b1bbb7713f7244c2f24555c99b76396fae8355&quot;,</span><br><span class="line">    &quot;cipherparams&quot;: &#123;</span><br><span class="line">      &quot;iv&quot;: &quot;d0f5a3d3e6c1eeec77bf631bc938725d&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;kdf&quot;: &quot;scrypt&quot;,</span><br><span class="line">    &quot;kdfparams&quot;: &#123;</span><br><span class="line">      &quot;dklen&quot;: 32,</span><br><span class="line">      &quot;n&quot;: 262144,</span><br><span class="line">      &quot;p&quot;: 1,</span><br><span class="line">      &quot;r&quot;: 8,</span><br><span class="line">      &quot;salt&quot;: &quot;70dc72c4eb63bea50f7637d9ff85bb53f6ca8ace17f4245feae9c0bc9abaad82&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mac&quot;: &quot;bd7fc0c937c39f1cbbf1ca654c33b53d7f9c644c6dacfeefe1641d2f3decea04&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;id&quot;: &quot;57803d82-0cd4-4a78-9c29-9f9252fdcf60&quot;,</span><br><span class="line">  &quot;version&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看账户余额"><a href="#查看账户余额" class="headerlink" title="查看账户余额"></a>查看账户余额</h3><p>eth对象提供了查看账户余额的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">0</span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。</p><h3 id="启动-amp-停止挖矿"><a href="#启动-amp-停止挖矿" class="headerlink" title="启动&amp;停止挖矿"></a>启动&amp;停止挖矿</h3><p>通过miner.start()来启动挖矿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(10)</span><br></pre></td></tr></table></figure><p>其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</p><p>如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miner.stop()：</span><br></pre></td></tr></table></figure><p>注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。</p><p>挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.coinbase</span><br><span class="line">&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><br></pre></td></tr></table></figure><p>现在的coinbase是账户0，要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.setEtherbase(eth.accounts[1])</span><br><span class="line">true</span><br><span class="line">&gt; eth.coinbase</span><br><span class="line">&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;</span><br></pre></td></tr></table></figure><p>挖到区块以后，账户0里面应该就有余额了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">2.31e+21</span><br></pre></td></tr></table></figure><p>getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&apos;ether&apos;)</span><br><span class="line">2310</span><br></pre></td></tr></table></figure><h3 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h3><p>截止目前，账户一的余额还是0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>可以通过发送一笔交易，从账户0转移10个以太币到账户1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(10,&apos;ether&apos;)</span><br><span class="line">&quot;10000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">Error: authentication needed: password or unlock</span><br><span class="line">    at web3.js:3143:20</span><br><span class="line">    at web3.js:6347:15</span><br><span class="line">    at web3.js:5081:36</span><br><span class="line">    at &lt;anonymous&gt;:1:1</span><br></pre></td></tr></table></figure><p>这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[0])</span><br><span class="line">Unlock account 0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f</span><br><span class="line">Passphrase: </span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(10,&apos;ether&apos;)</span><br><span class="line">&quot;10000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">INFO [03-07|11:13:11] Submitted transaction                    fullhash=0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6 recipient=0x46B24d04105551498587e3C6CE2c3341d5988938</span><br><span class="line">&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;</span><br></pre></td></tr></table></figure><p>我们去查看账户1中的余额：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; txpool.status</span><br><span class="line">&#123;</span><br><span class="line">  pending: 1,</span><br><span class="line">  queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一条pending的交易，pending表示已提交但还未被处理的交易。</p><p>要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(1);admin.sleepBlocks(1);miner.stop();</span><br></pre></td></tr></table></figure><p>当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&apos;ether&apos;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="查看交易和区块"><a href="#查看交易和区块" class="headerlink" title="查看交易和区块"></a>查看交易和区块</h3><p>eth对象封装了查看交易和区块信息的方法。</p><p>查看当前区块总数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.blockNumber</span><br><span class="line">463</span><br></pre></td></tr></table></figure><p>通过区块号查看区块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBlock(66)</span><br><span class="line">&#123;</span><br><span class="line">  difficulty: 135266,</span><br><span class="line">  extraData: &quot;0xd783010802846765746886676f312e31308664617277696e&quot;,</span><br><span class="line">  gasLimit: 3350537,</span><br><span class="line">  gasUsed: 0,</span><br><span class="line">  hash: &quot;0x265dfcc0649bf6240812256b2b9b4e3ae48d51fd8e43e25329ac111556eacdc8&quot;,</span><br><span class="line">  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  miner: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  mixHash: &quot;0xaf755722f62cac9b483d3437dbc795f2d3a02e28ec03d39d8ecbb6012906263c&quot;,</span><br><span class="line">  nonce: &quot;0x3cd80f6ec5c2f3e9&quot;,</span><br><span class="line">  number: 66,</span><br><span class="line">  parentHash: &quot;0x099776a52223b892d13266bb3aec3cc04c455dc797185f0b3300d39f9fc0a8ec&quot;,</span><br><span class="line">  receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</span><br><span class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</span><br><span class="line">  size: 535,</span><br><span class="line">  stateRoot: &quot;0x0c9feec5a201c8c98618331aecbfd2d4d93da1c6064abd0c41ae649fc08d8d06&quot;,</span><br><span class="line">  timestamp: 1520391527,</span><br><span class="line">  totalDifficulty: 8919666,</span><br><span class="line">  transactions: [],</span><br><span class="line">  transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</span><br><span class="line">  uncles: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过交易hash查看交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getTransaction(&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  blockHash: &quot;0x1cb368a27cc23c786ff5cdf7cd4351d48f4c8e8aea2e084a5e9d7c480449c79a&quot;,</span><br><span class="line">  blockNumber: 463,</span><br><span class="line">  from: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  gas: 90000,</span><br><span class="line">  gasPrice: 18000000000,</span><br><span class="line">  hash: &quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;,</span><br><span class="line">  input: &quot;0x&quot;,</span><br><span class="line">  nonce: 0,</span><br><span class="line">  r: &quot;0x31d22686e0d408a16497becf6d47fbfdffe6692d91727e5b7ed3d73ede9e66ea&quot;,</span><br><span class="line">  s: &quot;0x7ff7c14a20991e2dfdb813c2237b08a5611c8c8cb3c2dcb03a55ed282ce4d9c3&quot;,</span><br><span class="line">  to: &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;,</span><br><span class="line">  transactionIndex: 0,</span><br><span class="line">  v: &quot;0x38&quot;,</span><br><span class="line">  value: 10000000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="私有链" scheme="https://learnblockchain.cn/categories/ethereum/%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="私有链" scheme="https://learnblockchain.cn/tags/%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何编写一个可升级的智能合约</title>
    <link href="https://learnblockchain.cn/2018/03/15/contract-upgrade/"/>
    <id>https://learnblockchain.cn/2018/03/15/contract-upgrade/</id>
    <published>2018-03-15T08:14:01.000Z</published>
    <updated>2018-03-19T02:07:02.499Z</updated>
    
    <content type="html"><![CDATA[<p>区块链信任基础的数据不可修改的特性，让它传统应用程序有一个很大的不同的地方是一经发布于区块链上就无法修改（不能直接在原有的合约上直接修改再重新发布）。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约及<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">Solidity语言</a>有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="当智能合约出现bug"><a href="#当智能合约出现bug" class="headerlink" title="当智能合约出现bug"></a>当智能合约出现bug</h2><p>一方面正式由于智能合约的不可修改的特性，因为只要规则确定之后，没人能够修改它，大家才能够信任它。但另一方面，如果规则的实现有Bug, 可能会造成代币被盗，或是调用消耗大量的gas。这时就需要我们去修复错误。</p><p>我们知道一个智能合约包含两部分： 代码逻辑和数据，而代码逻辑又是最容易出问题的部分, 如在实现如下合约时，由于手抖在写addTen()时，10写成了11。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balanceOf[addr] + <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们在部署之后发现了这个问题，想要修复这个bug的话，只好重新部署合约，可是这时会有一个尴尬的问题，原来的合约已经有很多人使用，如果部署新的合约，老合约的数据将会丢失。</p><h2 id="数据合约及控制合约"><a href="#数据合约及控制合约" class="headerlink" title="数据合约及控制合约"></a>数据合约及控制合约</h2><p>那么如何解决上面的问题了，一个解决方案是分离合约中的数据，使用一个单独的合约来存储数据（下文称数据合约），使用一个单独的合约写业务逻辑（下文称控制合约）。<br>我们来看看代码如何实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract DataContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ControlContract &#123;</span><br><span class="line"></span><br><span class="line">    DataContract dataContract;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ControlContract</span>(<span class="params">address _dataContractAddr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        dataContract = DataContract(_dataContractAddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataContract.balanceOf(addr) + <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有两个合约DataContract 专门用来存数据，ControlContract用来处理逻辑，并利用DataContract来读写数据。通过这样的设计，可以在更新控制合约后保持数据合约不变，这样就不会丢失数据，也不用迁移数据。</p><h2 id="读写控制"><a href="#读写控制" class="headerlink" title="读写控制"></a>读写控制</h2><p>通过DataContract我们可以单独更新合约逻辑，不过你也许发现了一个新的问题，DataContract的数据不仅仅可以被ControlContract读写，还可以被其他的合约读写，因此需要对DataContract添加读写控制。我们给DataContract添加一个mapping, 用来控制哪些地址可以访问数据，同时添加了修饰器及设置访问的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract DataContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) accessAllowed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DataContract</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier platform() &#123;</span><br><span class="line">        <span class="built_in">require</span>(accessAllowed[msg.sender] == <span class="literal">true</span>);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowAccess</span>(<span class="params">address _addr</span>) <span class="title">platform</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[_addr] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">denyAccess</span>(<span class="params">address _addr</span>) <span class="title">platform</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[_addr] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>订阅我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>可参看合约的完整代码。</p><p>部署方法如下：</p><ol><li>先部署DataContract合约</li><li>使用DataContract合约地址作为部署ControlContract合约的参数</li><li>用ControlContract合约地址作为参数调用DataContract合约的allowAccess方法。<br>如果需要更新控制合约(如修复了addTen)则重新执行第2-3步，同时对老的控制合约执行denyAccess()。</li></ol><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>当我们在实现数据合约时，它包含的逻辑应该越少越好，并且应该是严格测试过的，因为一旦数据合约部署之后，就没法更改。<br>大多数情况下，和用户交互的是DApp， 因此当控制合约升级之后，需要升级DApp，使之关联新的控制合约。</p><p>尽管合约可以通过本文的方式升级，但我们依然要谨慎升级，因为升级表示你可以重写逻辑，会降低用户对你的信任度。<br>本文介绍升级方法更多的是一种思路，实际项目中可能会对应多个控制合约及数据合约。</p><p>欢迎来我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>讨论区块链技术。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链信任基础的数据不可修改的特性，让它传统应用程序有一个很大的不同的地方是一经发布于区块链上就无法修改（不能直接在原有的合约上直接修改再重新发布）。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列8 - Solidity API</title>
    <link href="https://learnblockchain.cn/2018/03/14/solidity-api/"/>
    <id>https://learnblockchain.cn/2018/03/14/solidity-api/</id>
    <published>2018-03-14T15:04:43.000Z</published>
    <updated>2018-08-09T02:12:29.971Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。</p><p>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><p>Solidity API 主要表现为Solidity 内置的特殊的变量及函数，他们存在于全局命名空间里，主要分为以下几类：</p><ol><li>有关区块和交易的属性</li><li>ABI编码函数</li><li>有关错误处理</li><li>有关数学及加密功能</li><li>地址相关</li><li>合约相关</li></ol><p>下面详细讲解下</p><h2 id="区块和交易的属性（Block-And-Transaction-Properties）"><a href="#区块和交易的属性（Block-And-Transaction-Properties）" class="headerlink" title="区块和交易的属性（Block And Transaction Properties）"></a>区块和交易的属性（Block And Transaction Properties）</h2><p>用来提供一些区块链当前的信息。</p><ul><li>blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。</li><li>block.coinbase (address): 当前块矿工的地址。</li><li>block.difficulty (uint):当前块的难度。</li><li>block.gaslimit (uint):当前块的gaslimit。</li><li>block.number (uint):当前区块的块号。</li><li>block.timestamp (uint): 当前块的Unix时间戳（从1970/1/1 00:00:00 UTC开始所经过的秒数）</li><li>gasleft() (uint256):  获取剩余gas。</li><li>msg.data (bytes): 完整的调用数据（calldata）。</li><li>msg.gas (uint): 当前还剩的gas（弃用）。</li><li>msg.sender (address): 当前调用发起人的地址。</li><li>msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。</li><li>msg.value (uint): 这个消息所附带的以太币，单位为wei。</li><li>now (uint): 当前块的时间戳(block.timestamp的别名)</li><li>tx.gasprice (uint) : 交易的gas价格。</li><li>tx.origin (address): 交易的发送者（全调用链）</li></ul><p>注意：<br>msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。</p><p>不应该依据 block.timestamp, now 和 block.blockhash来产生一个随机数（除非你确实需要这样做），这几个值在一定程度上被矿工影响（比如在赌博合约里，不诚实的矿工可能会重试去选择一个对自己有利的hash）。</p><p>对于同一个链上连续的区块来说，当前区块的时间戳（timestamp）总是会大于上一个区块的时间戳。</p><p>为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0.</p><h2 id="ABI编码函数"><a href="#ABI编码函数" class="headerlink" title="ABI编码函数"></a>ABI编码函数</h2><p>Solidity 提供了一下函数，用来直接得到ABI编码信息，这些函数有：</p><pre><code>* abi.encode(...) returns (bytes)：计算参数的ABI编码。* abi.encodePacked(...) returns (bytes)：计算参数的紧密打包编码* abi. encodeWithSelector(bytes4 selector, ...) returns (bytes)： 计算函数选择器和参数的ABI编码* abi.encodeWithSignature(string signature, ...) returns (bytes): 等价于* abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></pre><p>通过ABI编码函数可以在不用调用函数的情况下，获得ABI编码值，下面通过一段代码来看看这些方式的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line"></span><br><span class="line">contract testABI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abiEncode</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">        abi.encode(<span class="number">1</span>);  <span class="comment">// 计算 1 的ABI编码</span></span><br><span class="line">        <span class="keyword">return</span> abi.encodeWithSignature(<span class="string">"set(uint256)"</span>, <span class="number">1</span>); <span class="comment">//计算函数set(uint256) 及参数1 的ABI 编码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>assert(bool condition)<br>用于判断内部错误，条件不满足时抛出异常</li><li>require(bool condition):<br>用于判断输入或外部组件错误，条件不满足时抛出异常</li><li>require(bool condition, string message)<br>同上，多了一个错误信息。</li><li>revert():<br>终止执行并还原改变的状态</li><li>revert(string reason)<br>同上，提供一个错误信息。</li></ul><p>之前老的错误处理方式用throw 及 if … throw，这种方式会消耗掉所有剩余的gas。目前throw 的方式已经被弃用。</p><h2 id="数学及加密功能"><a href="#数学及加密功能" class="headerlink" title="数学及加密功能"></a>数学及加密功能</h2><ul><li>addmod(uint x, uint y, uint k) returns (uint):<br>计算(x + y) % k，加法支持任意的精度且不会在2**256处溢出，从0.5.0版本开始断言k != 0。</li><li>mulmod(uint x, uint y, uint k) returns (uint):<br>计算 (x <em> y) % k， 乘法支持任意的精度且不会在2*</em>256处溢出， 从0.5.0版本开始断言k != 0。</li><li>keccak256(…) returns (bytes32):<br>使用以太坊的（Keccak-256）计算HASH值。紧密打包参数。</li><li>sha256(…) returns (bytes32):<br>使用SHA-256计算hash值，紧密打包参数。</li><li>sha3(…) returns (bytes32):<br>keccak256的别名</li><li>ripemd160(…) returns (bytes20):<br>使用RIPEMD-160计算HASH值。紧密打包参数。</li><li>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):<br>通过椭圆曲线签名来恢复与公钥关联的地址，或者在错误时返回零。可用于签名数据的校验，如果返回结果是签名者的公匙地址，那么说明数据是正确的。<blockquote><p>ecrecover函数需要四个参数，需要被签名数据的哈希结果值，r，s，v分别来自签名结果串。<br>r = signature[0:64]<br>s = signature[64:128]<br>v = signature[128:130]<br>其中v取出来的值或者是00或01。要使用时，我们先要将其转为整型，再加上27，所以我们将得到27或28。在调用函数时v将填入27或28。</p></blockquote></li></ul><p>用javascript表达如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'0x8CbaC5e4d803bE2A3A5cd3DbE7174504c6DD0c1C'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hash = web3.sha3(msg)</span><br><span class="line"><span class="keyword">var</span> sig = web3.eth.sign(address, h).slice(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> r = <span class="string">`0x<span class="subst">$&#123;sig.slice(<span class="number">0</span>, <span class="number">64</span>)&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">`0x<span class="subst">$&#123;sig.slice(<span class="number">64</span>, <span class="number">128</span>)&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> v = web3.toDecimal(sig.slice(<span class="number">128</span>, <span class="number">130</span>)) + <span class="number">27</span></span><br></pre></td></tr></table></figure></p><p>订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>可以参考到完整的使用例子。<br><!-- [例子](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio)： --></p><p>紧密打包参数（tightly packed）意思是说参数不会补位，是直接连接在一起的，下面几个是相等的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class="line">keccak256(&quot;abc&quot;)</span><br><span class="line"></span><br><span class="line">keccak256(0x616263)  // hex</span><br><span class="line">keccak256(6382179)</span><br><span class="line">keccak256(97, 98, 99)   //ascii</span><br></pre></td></tr></table></figure><p>如果需要填充，可以使用显式类型转换：keccak256(“\x00\x12”) 与keccak256(uint16(0x12))相同。</p><p>注意，常量将使用存储它们所需的最少字节数来打包，例如keccak256(0) == keccak256(uint8(0))和keccak256(0x12345678) == keccak256(uint32(0x12345678))</p><p>在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为私链实现了一种预编译合约，合约要在收到第一个消息后才会真正存在（虽然他们的合约代码是硬编码的）。而向一个不存在的合约发送消息，所以才会导致Out-Of-Gas的问题。一种解决办法（workaround）是每个在你真正使用它们之前先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。</p><h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><ul><li><p><address>.balance (uint256):<br>Address的余额，以wei为单位。</address></p></li><li><p><address>.transfer(uint256 amount):<br>发送给定数量的ether到某个地址，以wei为单位。失败时抛出异常。</address></p></li><li><p><address>.send(uint256 amount) returns (bool):<br>发送给定数量的ether到某个地址，以wei为单位, 失败时返回false。</address></p></li><li><p><address>.call(…) returns (bool):<br>发起底层的call调用。失败时返回false。</address></p></li><li><p><address>.callcode(…) returns (bool):<br>发起底层的callcode调用，失败时返回false。<br>不鼓励使用，未来可能会移除。</address></p></li><li><p><address>.delegatecall(…) returns (bool):<br>发起底层的delegatecall调用，失败时返回false</address></p></li></ul><p>更多信息参考<a href="https://xiaozhuanlan.com/topic/7921803456" target="_blank" rel="noopener">地址篇</a>。</p><p><strong>警告</strong>：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p><h2 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h2><ul><li>this（当前合约的类型）:<br>表示当前合约，可以显式的转换为Address</li><li>selfdestruct(address recipient):<br>销毁当前合约，并把它所有资金发送到给定的地址。</li><li>suicide(address recipient):<br>selfdestruct的别名</li></ul><p>另外，当前合约里的所有函数均可支持调用，包括当前函数本身。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables" target="_blank" rel="noopener">Special Variables and Functions</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。&lt;/p&gt;
&lt;p&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何通过以太坊智能合约来进行众筹（ICO）</title>
    <link href="https://learnblockchain.cn/2018/02/28/ico-crowdsale/"/>
    <id>https://learnblockchain.cn/2018/02/28/ico-crowdsale/</id>
    <published>2018-02-28T12:30:42.000Z</published>
    <updated>2018-07-26T08:46:38.303Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="众筹"><a href="#众筹" class="headerlink" title="众筹"></a>众筹</h2><p>先简单说下众筹的概念：一般是这样的，我一个非常好的想法，但是我没有钱来做这事，于是我把这个想法发给大家看，说：我做这件事需要5百万，大家有没有兴趣投些钱，如果大家在30天内投够了5百万我就开始做，到时大家都是原始股东，如果募资额不到5百万，大家投的钱就还给大家。</p><p>现在ICO众筹已经被各路大佬拿来割韭菜而被玩坏了（不管有无达标，都把钱卷走）。</p><p>其实区块链技术本事非常适合解决众筹的信任问题，借助于智能合约，可以实现当募资额完成时，募资款自动打到指定账户，当募资额未完成时，可退款。这个过程不需要看众筹大佬的人品，不用依靠第三方平台信用担保。</p><h2 id="代币"><a href="#代币" class="headerlink" title="代币"></a>代币</h2><p>传统的众筹在参与之后通常不容易交易（参与之后无法转给其他人），而通过用代币来参与众筹，则很容易进行交易，众筹的参与人可随时进行买卖，待众筹项目实施完成的时候，完全根据代币持有量进行回馈。</p><p>举个例子说明下，大家会更容易理解，有这一个众筹：A有技术做一个能监测健康的指环，为此向公众募资200百万，募资时100块对应一个代币，约定在指环上市之后，代币的持有人可以用一个代币来兑换一个指环。而指环的研发周期是一年，因此在指环还未上市的一年里，众筹的参与人可以随时交易所持有的代币。</p><h2 id="众筹智能合约代码"><a href="#众筹智能合约代码" class="headerlink" title="众筹智能合约代码"></a>众筹智能合约代码</h2><p>接下来就看看如何实现一个众筹智能合约。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">interface token &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address receiver, uint amount</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">Crowdsale</span> </span>&#123;</span><br><span class="line">    address public beneficiary;  <span class="comment">// 募资成功后的收款方</span></span><br><span class="line">    uint public fundingGoal;   <span class="comment">// 募资额度</span></span><br><span class="line">    uint public amountRaised;   <span class="comment">// 参与数量</span></span><br><span class="line">    uint public deadline;      <span class="comment">// 募资截止期</span></span><br><span class="line"></span><br><span class="line">    uint public price;    <span class="comment">//  token 与以太坊的汇率 , token卖多少钱</span></span><br><span class="line">    token public tokenReward;   <span class="comment">// 要卖的token</span></span><br><span class="line"></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    bool fundingGoalReached = <span class="literal">false</span>;  <span class="comment">// 众筹是否达到目标</span></span><br><span class="line">    bool crowdsaleClosed = <span class="literal">false</span>;   <span class="comment">//  众筹是否结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事件可以用来跟踪信息</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    event GoalReached(address recipient, uint totalAmountRaised);</span><br><span class="line">    event FundTransfer(address backer, uint amount, bool isContribution);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数, 设置相关属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Crowdsale</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address ifSuccessfulSendTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint fundingGoalInEthers,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint durationInMinutes,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint finneyCostOfEachToken,</span></span></span><br><span class="line"><span class="function"><span class="params">        address addressOfTokenUsedAsReward</span>) </span>&#123;</span><br><span class="line">            beneficiary = ifSuccessfulSendTo;</span><br><span class="line">            fundingGoal = fundingGoalInEthers * <span class="number">1</span> ether;</span><br><span class="line">            deadline = now + durationInMinutes * <span class="number">1</span> minutes;</span><br><span class="line">            price = finneyCostOfEachToken * <span class="number">1</span> finney;</span><br><span class="line">            tokenReward = token(addressOfTokenUsedAsReward);   <span class="comment">// 传入已发布的 token 合约的地址来创建实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无函数名的Fallback函数，</span></span><br><span class="line"><span class="comment">     * 在向合约转账时，这个函数会被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!crowdsaleClosed);</span><br><span class="line">        uint amount = msg.value;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        amountRaised += amount;</span><br><span class="line">        tokenReward.transfer(msg.sender, amount / price);</span><br><span class="line">        FundTransfer(msg.sender, amount, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  定义函数修改器modifier（作用和Python的装饰器很相似）</span></span><br><span class="line"><span class="comment">    * 用于在函数执行前检查某种前置条件（判断通过之后才会继续执行该方法）</span></span><br><span class="line"><span class="comment">    * _ 表示继续执行之后的代码</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    modifier afterDeadline() &#123; <span class="keyword">if</span> (now &gt;= deadline) _; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断众筹是否完成融资目标， 这个方法使用了afterDeadline函数修改器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkGoalReached</span>(<span class="params"></span>) <span class="title">afterDeadline</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amountRaised &gt;= fundingGoal) &#123;</span><br><span class="line">            fundingGoalReached = <span class="literal">true</span>;</span><br><span class="line">            GoalReached(beneficiary, amountRaised);</span><br><span class="line">        &#125;</span><br><span class="line">        crowdsaleClosed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成融资目标时，融资款发送到收款方</span></span><br><span class="line"><span class="comment">     * 未完成融资目标时，执行退款</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">safeWithdrawal</span>(<span class="params"></span>) <span class="title">afterDeadline</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fundingGoalReached) &#123;</span><br><span class="line">            uint amount = balanceOf[msg.sender];</span><br><span class="line">            balanceOf[msg.sender] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.sender.send(amount)) &#123;</span><br><span class="line">                    FundTransfer(msg.sender, amount, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    balanceOf[msg.sender] = amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fundingGoalReached &amp;&amp; beneficiary == msg.sender) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beneficiary.send(amountRaised)) &#123;</span><br><span class="line">                FundTransfer(beneficiary, amountRaised, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//If we fail to send the funds to beneficiary, unlock funders balance</span></span><br><span class="line">                fundingGoalReached = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署及说明"><a href="#部署及说明" class="headerlink" title="部署及说明"></a>部署及说明</h2><p>在部署这个合约之前，我们需要先部署一个代币合约，请参考<a href="https://learnblockchain.cn/2018/01/12/create_token/">一步步教你创建自己的数字货币</a>。</p><ol><li><p>创建众筹合约我们需要提供一下几个参数：<br>ifSuccessfulSendTo： 募资成功后的收款方（其实这里可以默认为合约创建者）<br>fundingGoalInEthers： 募资额度， 为了方便我们仅募3个ether<br>durationInMinutes： 募资时间<br>finneyCostOfEachToken 每个代币的价格, 这里为了方便使用了<a href="https://learnblockchain.cn/2018/02/02/solidity-unit/">单位finney</a>及值为：1 （1 ether =  1000 finney）<br>addressOfTokenUsedAsReward： 代币合约地址。<br>如：<br><img src="https://learnblockchain.cn/images/crowdsale_create.jpeg" alt=""><br>本文使用的参数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;0xc6f9ea59d424733e8e1902c7837ea75e20abfb49&quot;,3, 100, 1,&quot;0xad8972e2b583f580fc52f737b98327eb65d08f8c&quot;</span><br></pre></td></tr></table></figure></li><li><p>参与人投资的时候实际购买众筹合约代币，所以需要先向合约预存代币，代币的数量为：募资额度 / 代币的价格 ， 这里为：3 * 1000/1 = 3000 （当能也可以大于3000）。<br>向合约预存代币可以使用<a href="https://www.myetherwallet.com/#send-transaction" target="_blank" rel="noopener">myetherwallet</a>钱包，或在remix中重新加载代币合约，执行代币合约tranfer()函数进行代币转账，转账的地址就是我们创建合约的地址。如使用myetherwallet转账如图：<br><img src="https://learnblockchain.cn//images/crowdsale_send_token.jpeg" alt=""></p></li><li><p>投资人向众筹合约转账（发送以太币）即是参与众筹行为，转账时，会执行Fallback回退函数（即无名函数）向其账户打回相应的代币。</p></li><li><p>safeWithdrawl() 可以被参与人或收益人调用，如果融资不达标参与人可收回之前投资款，如果融资达标收益人可以拿到所有的融资款。</p></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>上面是一个很正规的募资合约。接下来讲两个募资合约的扩展，如何实现无限募资合约及割韭菜合约。<br>这部分内容独家发布在我的小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a></p><p>如何创建代币发行代币，现在也录制了对应的<strong><a href="https://wiki.learnblockchain.cn/course/token.html" target="_blank" rel="noopener">视频教程:通过代币学以太坊智能合约开发</a></strong>，目前我们也在<strong>招募体验师</strong>，可以点击<a href="https://learnblockchain.cn/course">链接</a>了解。</p><p>如果你在学习中遇到问题，欢迎到我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>提问，作为星球成员福利，成员可加入区块链技术付费交流群。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://ethereum.org/crowdsale" target="_blank" rel="noopener">Create a crowdsale</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
      <category term="ICO" scheme="https://learnblockchain.cn/tags/ICO/"/>
    
  </entry>
  
  <entry>
    <title>什么是拜占庭将军问题</title>
    <link href="https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/"/>
    <id>https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-07-16T04:44:51.302Z</updated>
    
    <content type="html"><![CDATA[<p>接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢?</p><a id="more"></a><h2 id="什么是拜占庭将军问题"><a href="#什么是拜占庭将军问题" class="headerlink" title="什么是拜占庭将军问题"></a>什么是拜占庭将军问题</h2><p>也被称为“拜占庭容错”、“拜占庭将军问题”。<br>拜占庭将军问题是Leslie Lamport（2013年的图灵讲得主）用来为描述<strong>分布式系统一致性问题</strong>（Distributed Consensus）在<a href="http://lamport.azurewebsites.net/pubs/byz.pdf" target="_blank" rel="noopener">论文</a>中抽象出来一个著名的例子。</p><p>这个例子大意是这样的：</p><p>拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？</p><blockquote><p>拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的.</p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>单从上面的说明可能无法理解这个问题的复杂性，我们来简单分析一下：</p><ol><li><p>先看在没有叛徒情况下，假如一个将军A提一个进攻提议（如：明日下午1点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午2点、3点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现A提议有3个支持者，B提议有4个支持者，C提议有2个支持者等等。</p></li><li><p>再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知A明日下午1点进攻， 通知B明日下午2点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午1点进攻又同意下午2点进攻）。</p><blockquote><p>叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为「Byzantine fault tolerance」，简称为BFT。</p></blockquote></li></ol><p>相信大家已经可以明白这个问题的复杂性了。</p><h2 id="中本聪的解决方案"><a href="#中本聪的解决方案" class="headerlink" title="中本聪的解决方案"></a>中本聪的解决方案</h2><p>在出现比特币之前，解决分布式系统一致性问题主要是Lamport提出的Paxos算法或其衍生算法。Paxos类算法仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。</p><p>中本聪在比特币中创造性的引入了“工作量证明（POW : Proof of Work）”来解决这个问题，有兴趣可进一步阅读<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">工作量证明</a>。<br>通过工作量证明就增加了发送信息的成本，降低节点发送消息速率，这样就以保证在一个时间只有一个节点(或是很少)在进行广播，同时在广播时会附上自己的签名。<br>这个过程就像一位将军A在向其他的将军（B、C、D…）发起一个进攻提议一样，将军B、C、D…看到将军A签过名的进攻提议书，如果是诚实的将军就会立刻同意进攻提议，而不会发起自己新的进攻提议。</p><p>以上就是比特币网络中是单个区块（账本）达成共识的方法（取得一致性）。</p><p>理解了单个区块取得一致性的方法，那么整个区块链（总账本）如果达成一致也好理解。<br>我们稍微把将军问题改一下：假设攻下一个城堡需要多次的进攻，每次进攻的提议必须基于之前最多次数的胜利进攻下提出的（只有这样敌方已有损失最大，我方进攻胜利的可能性就更大），这样约定之后，将军A在收到进攻提议时，就会检查一下这个提议是不是基于最多的胜利提出的，如果不是（基于最多的胜利）将军A就不会同意这样的提议，如果是的，将军A就会把这次提议记下来。</p><p>这就是比特币网络<a href="https://xiaozhuanlan.com/topic/0298513746" target="_blank" rel="noopener">最长链选择</a>。</p><h2 id="经济学分析"><a href="#经济学分析" class="headerlink" title="经济学分析"></a>经济学分析</h2><p>工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。</p><p>很多人批评工作量证明造成巨大的电力浪费，促使人们去探索新的解决一致性（共识）问题的机制：权益证明机制（POS: Proof of Stake）是一个代表。在拜占庭将军问题的角度来看，它同样提高了做叛徒的成本，因为账户需要首先持有大量余额才能有更多的几率广播区块，POS不是本文重点，以后在讲。</p><blockquote><p>共识算法的核心就是解决拜占庭将军问题（分布式网络一致性问题）。</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://lamport.azurewebsites.net/pubs/byz.pdf" target="_blank" rel="noopener">The Byzantine Generals Problem</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢?&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="共识协议" scheme="https://learnblockchain.cn/tags/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
